// Code generated by MockGen. DO NOT EDIT.
// Source: ./types.go
//
// Generated by this command:
//
//	mockgen -destination=./internal/mocks/gateway.mock.go -package=mocks -typed -source=./types.go
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	net "net"
	reflect "reflect"
	time "time"

	gateway "gitee.com/flycash/ws-gateway"
	gatewayapiv1 "gitee.com/flycash/ws-gateway/api/proto/gen/gatewayapi/v1"
	compression "gitee.com/flycash/ws-gateway/pkg/compression"
	session "gitee.com/flycash/ws-gateway/pkg/session"
	server "github.com/gotomicro/ego/server"
	clientv3 "go.etcd.io/etcd/client/v3"
	gomock "go.uber.org/mock/gomock"
)

// MockServer is a mock of Server interface.
type MockServer struct {
	ctrl     *gomock.Controller
	recorder *MockServerMockRecorder
	isgomock struct{}
}

// MockServerMockRecorder is the mock recorder for MockServer.
type MockServerMockRecorder struct {
	mock *MockServer
}

// NewMockServer creates a new mock instance.
func NewMockServer(ctrl *gomock.Controller) *MockServer {
	mock := &MockServer{ctrl: ctrl}
	mock.recorder = &MockServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServer) EXPECT() *MockServerMockRecorder {
	return m.recorder
}

// GracefulStop mocks base method.
func (m *MockServer) GracefulStop(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GracefulStop", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// GracefulStop indicates an expected call of GracefulStop.
func (mr *MockServerMockRecorder) GracefulStop(ctx any) *MockServerGracefulStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GracefulStop", reflect.TypeOf((*MockServer)(nil).GracefulStop), ctx)
	return &MockServerGracefulStopCall{Call: call}
}

// MockServerGracefulStopCall wrap *gomock.Call
type MockServerGracefulStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServerGracefulStopCall) Return(arg0 error) *MockServerGracefulStopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServerGracefulStopCall) Do(f func(context.Context) error) *MockServerGracefulStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServerGracefulStopCall) DoAndReturn(f func(context.Context) error) *MockServerGracefulStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Info mocks base method.
func (m *MockServer) Info() *server.ServiceInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info")
	ret0, _ := ret[0].(*server.ServiceInfo)
	return ret0
}

// Info indicates an expected call of Info.
func (mr *MockServerMockRecorder) Info() *MockServerInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockServer)(nil).Info))
	return &MockServerInfoCall{Call: call}
}

// MockServerInfoCall wrap *gomock.Call
type MockServerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServerInfoCall) Return(arg0 *server.ServiceInfo) *MockServerInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServerInfoCall) Do(f func() *server.ServiceInfo) *MockServerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServerInfoCall) DoAndReturn(f func() *server.ServiceInfo) *MockServerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Init mocks base method.
func (m *MockServer) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockServerMockRecorder) Init() *MockServerInitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockServer)(nil).Init))
	return &MockServerInitCall{Call: call}
}

// MockServerInitCall wrap *gomock.Call
type MockServerInitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServerInitCall) Return(arg0 error) *MockServerInitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServerInitCall) Do(f func() error) *MockServerInitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServerInitCall) DoAndReturn(f func() error) *MockServerInitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Name mocks base method.
func (m *MockServer) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockServerMockRecorder) Name() *MockServerNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockServer)(nil).Name))
	return &MockServerNameCall{Call: call}
}

// MockServerNameCall wrap *gomock.Call
type MockServerNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServerNameCall) Return(arg0 string) *MockServerNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServerNameCall) Do(f func() string) *MockServerNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServerNameCall) DoAndReturn(f func() string) *MockServerNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PackageName mocks base method.
func (m *MockServer) PackageName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PackageName")
	ret0, _ := ret[0].(string)
	return ret0
}

// PackageName indicates an expected call of PackageName.
func (mr *MockServerMockRecorder) PackageName() *MockServerPackageNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PackageName", reflect.TypeOf((*MockServer)(nil).PackageName))
	return &MockServerPackageNameCall{Call: call}
}

// MockServerPackageNameCall wrap *gomock.Call
type MockServerPackageNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServerPackageNameCall) Return(arg0 string) *MockServerPackageNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServerPackageNameCall) Do(f func() string) *MockServerPackageNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServerPackageNameCall) DoAndReturn(f func() string) *MockServerPackageNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockServer) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockServerMockRecorder) Start() *MockServerStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockServer)(nil).Start))
	return &MockServerStartCall{Call: call}
}

// MockServerStartCall wrap *gomock.Call
type MockServerStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServerStartCall) Return(arg0 error) *MockServerStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServerStartCall) Do(f func() error) *MockServerStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServerStartCall) DoAndReturn(f func() error) *MockServerStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockServer) Stop() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop")
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockServerMockRecorder) Stop() *MockServerStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockServer)(nil).Stop))
	return &MockServerStopCall{Call: call}
}

// MockServerStopCall wrap *gomock.Call
type MockServerStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServerStopCall) Return(arg0 error) *MockServerStopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServerStopCall) Do(f func() error) *MockServerStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServerStopCall) DoAndReturn(f func() error) *MockServerStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockLink is a mock of Link interface.
type MockLink struct {
	ctrl     *gomock.Controller
	recorder *MockLinkMockRecorder
	isgomock struct{}
}

// MockLinkMockRecorder is the mock recorder for MockLink.
type MockLinkMockRecorder struct {
	mock *MockLink
}

// NewMockLink creates a new mock instance.
func NewMockLink(ctrl *gomock.Controller) *MockLink {
	mock := &MockLink{ctrl: ctrl}
	mock.recorder = &MockLinkMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLink) EXPECT() *MockLinkMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockLink) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockLinkMockRecorder) Close() *MockLinkCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLink)(nil).Close))
	return &MockLinkCloseCall{Call: call}
}

// MockLinkCloseCall wrap *gomock.Call
type MockLinkCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkCloseCall) Return(arg0 error) *MockLinkCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkCloseCall) Do(f func() error) *MockLinkCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkCloseCall) DoAndReturn(f func() error) *MockLinkCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasClosed mocks base method.
func (m *MockLink) HasClosed() <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasClosed")
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// HasClosed indicates an expected call of HasClosed.
func (mr *MockLinkMockRecorder) HasClosed() *MockLinkHasClosedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasClosed", reflect.TypeOf((*MockLink)(nil).HasClosed))
	return &MockLinkHasClosedCall{Call: call}
}

// MockLinkHasClosedCall wrap *gomock.Call
type MockLinkHasClosedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkHasClosedCall) Return(arg0 <-chan struct{}) *MockLinkHasClosedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkHasClosedCall) Do(f func() <-chan struct{}) *MockLinkHasClosedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkHasClosedCall) DoAndReturn(f func() <-chan struct{}) *MockLinkHasClosedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ID mocks base method.
func (m *MockLink) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockLinkMockRecorder) ID() *MockLinkIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockLink)(nil).ID))
	return &MockLinkIDCall{Call: call}
}

// MockLinkIDCall wrap *gomock.Call
type MockLinkIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkIDCall) Return(arg0 string) *MockLinkIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkIDCall) Do(f func() string) *MockLinkIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkIDCall) DoAndReturn(f func() string) *MockLinkIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Receive mocks base method.
func (m *MockLink) Receive() <-chan []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Receive")
	ret0, _ := ret[0].(<-chan []byte)
	return ret0
}

// Receive indicates an expected call of Receive.
func (mr *MockLinkMockRecorder) Receive() *MockLinkReceiveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Receive", reflect.TypeOf((*MockLink)(nil).Receive))
	return &MockLinkReceiveCall{Call: call}
}

// MockLinkReceiveCall wrap *gomock.Call
type MockLinkReceiveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkReceiveCall) Return(arg0 <-chan []byte) *MockLinkReceiveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkReceiveCall) Do(f func() <-chan []byte) *MockLinkReceiveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkReceiveCall) DoAndReturn(f func() <-chan []byte) *MockLinkReceiveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Send mocks base method.
func (m *MockLink) Send(payload []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Send", payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// Send indicates an expected call of Send.
func (mr *MockLinkMockRecorder) Send(payload any) *MockLinkSendCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockLink)(nil).Send), payload)
	return &MockLinkSendCall{Call: call}
}

// MockLinkSendCall wrap *gomock.Call
type MockLinkSendCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkSendCall) Return(arg0 error) *MockLinkSendCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkSendCall) Do(f func([]byte) error) *MockLinkSendCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkSendCall) DoAndReturn(f func([]byte) error) *MockLinkSendCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Session mocks base method.
func (m *MockLink) Session() session.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Session")
	ret0, _ := ret[0].(session.Session)
	return ret0
}

// Session indicates an expected call of Session.
func (mr *MockLinkMockRecorder) Session() *MockLinkSessionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Session", reflect.TypeOf((*MockLink)(nil).Session))
	return &MockLinkSessionCall{Call: call}
}

// MockLinkSessionCall wrap *gomock.Call
type MockLinkSessionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkSessionCall) Return(arg0 session.Session) *MockLinkSessionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkSessionCall) Do(f func() session.Session) *MockLinkSessionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkSessionCall) DoAndReturn(f func() session.Session) *MockLinkSessionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TryCloseIfIdle mocks base method.
func (m *MockLink) TryCloseIfIdle(timeout time.Duration) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryCloseIfIdle", timeout)
	ret0, _ := ret[0].(bool)
	return ret0
}

// TryCloseIfIdle indicates an expected call of TryCloseIfIdle.
func (mr *MockLinkMockRecorder) TryCloseIfIdle(timeout any) *MockLinkTryCloseIfIdleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryCloseIfIdle", reflect.TypeOf((*MockLink)(nil).TryCloseIfIdle), timeout)
	return &MockLinkTryCloseIfIdleCall{Call: call}
}

// MockLinkTryCloseIfIdleCall wrap *gomock.Call
type MockLinkTryCloseIfIdleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkTryCloseIfIdleCall) Return(arg0 bool) *MockLinkTryCloseIfIdleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkTryCloseIfIdleCall) Do(f func(time.Duration) bool) *MockLinkTryCloseIfIdleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkTryCloseIfIdleCall) DoAndReturn(f func(time.Duration) bool) *MockLinkTryCloseIfIdleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateActiveTime mocks base method.
func (m *MockLink) UpdateActiveTime() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateActiveTime")
}

// UpdateActiveTime indicates an expected call of UpdateActiveTime.
func (mr *MockLinkMockRecorder) UpdateActiveTime() *MockLinkUpdateActiveTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateActiveTime", reflect.TypeOf((*MockLink)(nil).UpdateActiveTime))
	return &MockLinkUpdateActiveTimeCall{Call: call}
}

// MockLinkUpdateActiveTimeCall wrap *gomock.Call
type MockLinkUpdateActiveTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkUpdateActiveTimeCall) Return() *MockLinkUpdateActiveTimeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkUpdateActiveTimeCall) Do(f func()) *MockLinkUpdateActiveTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkUpdateActiveTimeCall) DoAndReturn(f func()) *MockLinkUpdateActiveTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockLinkEventHandler is a mock of LinkEventHandler interface.
type MockLinkEventHandler struct {
	ctrl     *gomock.Controller
	recorder *MockLinkEventHandlerMockRecorder
	isgomock struct{}
}

// MockLinkEventHandlerMockRecorder is the mock recorder for MockLinkEventHandler.
type MockLinkEventHandlerMockRecorder struct {
	mock *MockLinkEventHandler
}

// NewMockLinkEventHandler creates a new mock instance.
func NewMockLinkEventHandler(ctrl *gomock.Controller) *MockLinkEventHandler {
	mock := &MockLinkEventHandler{ctrl: ctrl}
	mock.recorder = &MockLinkEventHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLinkEventHandler) EXPECT() *MockLinkEventHandlerMockRecorder {
	return m.recorder
}

// OnBackendPushMessage mocks base method.
func (m *MockLinkEventHandler) OnBackendPushMessage(link gateway.Link, message *gatewayapiv1.PushMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnBackendPushMessage", link, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnBackendPushMessage indicates an expected call of OnBackendPushMessage.
func (mr *MockLinkEventHandlerMockRecorder) OnBackendPushMessage(link, message any) *MockLinkEventHandlerOnBackendPushMessageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnBackendPushMessage", reflect.TypeOf((*MockLinkEventHandler)(nil).OnBackendPushMessage), link, message)
	return &MockLinkEventHandlerOnBackendPushMessageCall{Call: call}
}

// MockLinkEventHandlerOnBackendPushMessageCall wrap *gomock.Call
type MockLinkEventHandlerOnBackendPushMessageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkEventHandlerOnBackendPushMessageCall) Return(arg0 error) *MockLinkEventHandlerOnBackendPushMessageCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkEventHandlerOnBackendPushMessageCall) Do(f func(gateway.Link, *gatewayapiv1.PushMessage) error) *MockLinkEventHandlerOnBackendPushMessageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkEventHandlerOnBackendPushMessageCall) DoAndReturn(f func(gateway.Link, *gatewayapiv1.PushMessage) error) *MockLinkEventHandlerOnBackendPushMessageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OnConnect mocks base method.
func (m *MockLinkEventHandler) OnConnect(link gateway.Link) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnConnect", link)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnConnect indicates an expected call of OnConnect.
func (mr *MockLinkEventHandlerMockRecorder) OnConnect(link any) *MockLinkEventHandlerOnConnectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnConnect", reflect.TypeOf((*MockLinkEventHandler)(nil).OnConnect), link)
	return &MockLinkEventHandlerOnConnectCall{Call: call}
}

// MockLinkEventHandlerOnConnectCall wrap *gomock.Call
type MockLinkEventHandlerOnConnectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkEventHandlerOnConnectCall) Return(arg0 error) *MockLinkEventHandlerOnConnectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkEventHandlerOnConnectCall) Do(f func(gateway.Link) error) *MockLinkEventHandlerOnConnectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkEventHandlerOnConnectCall) DoAndReturn(f func(gateway.Link) error) *MockLinkEventHandlerOnConnectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OnDisconnect mocks base method.
func (m *MockLinkEventHandler) OnDisconnect(link gateway.Link) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnDisconnect", link)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnDisconnect indicates an expected call of OnDisconnect.
func (mr *MockLinkEventHandlerMockRecorder) OnDisconnect(link any) *MockLinkEventHandlerOnDisconnectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnDisconnect", reflect.TypeOf((*MockLinkEventHandler)(nil).OnDisconnect), link)
	return &MockLinkEventHandlerOnDisconnectCall{Call: call}
}

// MockLinkEventHandlerOnDisconnectCall wrap *gomock.Call
type MockLinkEventHandlerOnDisconnectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkEventHandlerOnDisconnectCall) Return(arg0 error) *MockLinkEventHandlerOnDisconnectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkEventHandlerOnDisconnectCall) Do(f func(gateway.Link) error) *MockLinkEventHandlerOnDisconnectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkEventHandlerOnDisconnectCall) DoAndReturn(f func(gateway.Link) error) *MockLinkEventHandlerOnDisconnectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OnFrontendSendMessage mocks base method.
func (m *MockLinkEventHandler) OnFrontendSendMessage(link gateway.Link, payload []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnFrontendSendMessage", link, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnFrontendSendMessage indicates an expected call of OnFrontendSendMessage.
func (mr *MockLinkEventHandlerMockRecorder) OnFrontendSendMessage(link, payload any) *MockLinkEventHandlerOnFrontendSendMessageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnFrontendSendMessage", reflect.TypeOf((*MockLinkEventHandler)(nil).OnFrontendSendMessage), link, payload)
	return &MockLinkEventHandlerOnFrontendSendMessageCall{Call: call}
}

// MockLinkEventHandlerOnFrontendSendMessageCall wrap *gomock.Call
type MockLinkEventHandlerOnFrontendSendMessageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkEventHandlerOnFrontendSendMessageCall) Return(arg0 error) *MockLinkEventHandlerOnFrontendSendMessageCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkEventHandlerOnFrontendSendMessageCall) Do(f func(gateway.Link, []byte) error) *MockLinkEventHandlerOnFrontendSendMessageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkEventHandlerOnFrontendSendMessageCall) DoAndReturn(f func(gateway.Link, []byte) error) *MockLinkEventHandlerOnFrontendSendMessageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUpgrader is a mock of Upgrader interface.
type MockUpgrader struct {
	ctrl     *gomock.Controller
	recorder *MockUpgraderMockRecorder
	isgomock struct{}
}

// MockUpgraderMockRecorder is the mock recorder for MockUpgrader.
type MockUpgraderMockRecorder struct {
	mock *MockUpgrader
}

// NewMockUpgrader creates a new mock instance.
func NewMockUpgrader(ctrl *gomock.Controller) *MockUpgrader {
	mock := &MockUpgrader{ctrl: ctrl}
	mock.recorder = &MockUpgraderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUpgrader) EXPECT() *MockUpgraderMockRecorder {
	return m.recorder
}

// Name mocks base method.
func (m *MockUpgrader) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockUpgraderMockRecorder) Name() *MockUpgraderNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockUpgrader)(nil).Name))
	return &MockUpgraderNameCall{Call: call}
}

// MockUpgraderNameCall wrap *gomock.Call
type MockUpgraderNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgraderNameCall) Return(arg0 string) *MockUpgraderNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgraderNameCall) Do(f func() string) *MockUpgraderNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgraderNameCall) DoAndReturn(f func() string) *MockUpgraderNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Upgrade mocks base method.
func (m *MockUpgrader) Upgrade(conn net.Conn) (session.Session, *compression.State, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upgrade", conn)
	ret0, _ := ret[0].(session.Session)
	ret1, _ := ret[1].(*compression.State)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Upgrade indicates an expected call of Upgrade.
func (mr *MockUpgraderMockRecorder) Upgrade(conn any) *MockUpgraderUpgradeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upgrade", reflect.TypeOf((*MockUpgrader)(nil).Upgrade), conn)
	return &MockUpgraderUpgradeCall{Call: call}
}

// MockUpgraderUpgradeCall wrap *gomock.Call
type MockUpgraderUpgradeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUpgraderUpgradeCall) Return(arg0 session.Session, arg1 *compression.State, arg2 error) *MockUpgraderUpgradeCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUpgraderUpgradeCall) Do(f func(net.Conn) (session.Session, *compression.State, error)) *MockUpgraderUpgradeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUpgraderUpgradeCall) DoAndReturn(f func(net.Conn) (session.Session, *compression.State, error)) *MockUpgraderUpgradeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockLinkManager is a mock of LinkManager interface.
type MockLinkManager struct {
	ctrl     *gomock.Controller
	recorder *MockLinkManagerMockRecorder
	isgomock struct{}
}

// MockLinkManagerMockRecorder is the mock recorder for MockLinkManager.
type MockLinkManagerMockRecorder struct {
	mock *MockLinkManager
}

// NewMockLinkManager creates a new mock instance.
func NewMockLinkManager(ctrl *gomock.Controller) *MockLinkManager {
	mock := &MockLinkManager{ctrl: ctrl}
	mock.recorder = &MockLinkManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLinkManager) EXPECT() *MockLinkManagerMockRecorder {
	return m.recorder
}

// CleanIdleLinks mocks base method.
func (m *MockLinkManager) CleanIdleLinks(idleTimeout time.Duration) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanIdleLinks", idleTimeout)
	ret0, _ := ret[0].(int)
	return ret0
}

// CleanIdleLinks indicates an expected call of CleanIdleLinks.
func (mr *MockLinkManagerMockRecorder) CleanIdleLinks(idleTimeout any) *MockLinkManagerCleanIdleLinksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanIdleLinks", reflect.TypeOf((*MockLinkManager)(nil).CleanIdleLinks), idleTimeout)
	return &MockLinkManagerCleanIdleLinksCall{Call: call}
}

// MockLinkManagerCleanIdleLinksCall wrap *gomock.Call
type MockLinkManagerCleanIdleLinksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerCleanIdleLinksCall) Return(arg0 int) *MockLinkManagerCleanIdleLinksCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerCleanIdleLinksCall) Do(f func(time.Duration) int) *MockLinkManagerCleanIdleLinksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerCleanIdleLinksCall) DoAndReturn(f func(time.Duration) int) *MockLinkManagerCleanIdleLinksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockLinkManager) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockLinkManagerMockRecorder) Close() *MockLinkManagerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLinkManager)(nil).Close))
	return &MockLinkManagerCloseCall{Call: call}
}

// MockLinkManagerCloseCall wrap *gomock.Call
type MockLinkManagerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerCloseCall) Return(arg0 error) *MockLinkManagerCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerCloseCall) Do(f func() error) *MockLinkManagerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerCloseCall) DoAndReturn(f func() error) *MockLinkManagerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindLinkByUserInfo mocks base method.
func (m *MockLinkManager) FindLinkByUserInfo(userInfo session.UserInfo) (gateway.Link, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindLinkByUserInfo", userInfo)
	ret0, _ := ret[0].(gateway.Link)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// FindLinkByUserInfo indicates an expected call of FindLinkByUserInfo.
func (mr *MockLinkManagerMockRecorder) FindLinkByUserInfo(userInfo any) *MockLinkManagerFindLinkByUserInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindLinkByUserInfo", reflect.TypeOf((*MockLinkManager)(nil).FindLinkByUserInfo), userInfo)
	return &MockLinkManagerFindLinkByUserInfoCall{Call: call}
}

// MockLinkManagerFindLinkByUserInfoCall wrap *gomock.Call
type MockLinkManagerFindLinkByUserInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerFindLinkByUserInfoCall) Return(arg0 gateway.Link, arg1 bool) *MockLinkManagerFindLinkByUserInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerFindLinkByUserInfoCall) Do(f func(session.UserInfo) (gateway.Link, bool)) *MockLinkManagerFindLinkByUserInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerFindLinkByUserInfoCall) DoAndReturn(f func(session.UserInfo) (gateway.Link, bool)) *MockLinkManagerFindLinkByUserInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GracefulClose mocks base method.
func (m *MockLinkManager) GracefulClose(ctx context.Context, availableNodes *gatewayapiv1.NodeList) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GracefulClose", ctx, availableNodes)
	ret0, _ := ret[0].(error)
	return ret0
}

// GracefulClose indicates an expected call of GracefulClose.
func (mr *MockLinkManagerMockRecorder) GracefulClose(ctx, availableNodes any) *MockLinkManagerGracefulCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GracefulClose", reflect.TypeOf((*MockLinkManager)(nil).GracefulClose), ctx, availableNodes)
	return &MockLinkManagerGracefulCloseCall{Call: call}
}

// MockLinkManagerGracefulCloseCall wrap *gomock.Call
type MockLinkManagerGracefulCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerGracefulCloseCall) Return(arg0 error) *MockLinkManagerGracefulCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerGracefulCloseCall) Do(f func(context.Context, *gatewayapiv1.NodeList) error) *MockLinkManagerGracefulCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerGracefulCloseCall) DoAndReturn(f func(context.Context, *gatewayapiv1.NodeList) error) *MockLinkManagerGracefulCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Len mocks base method.
func (m *MockLinkManager) Len() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int64)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockLinkManagerMockRecorder) Len() *MockLinkManagerLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockLinkManager)(nil).Len))
	return &MockLinkManagerLenCall{Call: call}
}

// MockLinkManagerLenCall wrap *gomock.Call
type MockLinkManagerLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerLenCall) Return(arg0 int64) *MockLinkManagerLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerLenCall) Do(f func() int64) *MockLinkManagerLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerLenCall) DoAndReturn(f func() int64) *MockLinkManagerLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Links mocks base method.
func (m *MockLinkManager) Links() []gateway.Link {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Links")
	ret0, _ := ret[0].([]gateway.Link)
	return ret0
}

// Links indicates an expected call of Links.
func (mr *MockLinkManagerMockRecorder) Links() *MockLinkManagerLinksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Links", reflect.TypeOf((*MockLinkManager)(nil).Links))
	return &MockLinkManagerLinksCall{Call: call}
}

// MockLinkManagerLinksCall wrap *gomock.Call
type MockLinkManagerLinksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerLinksCall) Return(arg0 []gateway.Link) *MockLinkManagerLinksCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerLinksCall) Do(f func() []gateway.Link) *MockLinkManagerLinksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerLinksCall) DoAndReturn(f func() []gateway.Link) *MockLinkManagerLinksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewLink mocks base method.
func (m *MockLinkManager) NewLink(ctx context.Context, conn net.Conn, sess session.Session, compressionState *compression.State) (gateway.Link, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewLink", ctx, conn, sess, compressionState)
	ret0, _ := ret[0].(gateway.Link)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewLink indicates an expected call of NewLink.
func (mr *MockLinkManagerMockRecorder) NewLink(ctx, conn, sess, compressionState any) *MockLinkManagerNewLinkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewLink", reflect.TypeOf((*MockLinkManager)(nil).NewLink), ctx, conn, sess, compressionState)
	return &MockLinkManagerNewLinkCall{Call: call}
}

// MockLinkManagerNewLinkCall wrap *gomock.Call
type MockLinkManagerNewLinkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerNewLinkCall) Return(arg0 gateway.Link, arg1 error) *MockLinkManagerNewLinkCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerNewLinkCall) Do(f func(context.Context, net.Conn, session.Session, *compression.State) (gateway.Link, error)) *MockLinkManagerNewLinkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerNewLinkCall) DoAndReturn(f func(context.Context, net.Conn, session.Session, *compression.State) (gateway.Link, error)) *MockLinkManagerNewLinkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RedirectLinks mocks base method.
func (m *MockLinkManager) RedirectLinks(ctx context.Context, selector gateway.LinkSelector, availableNodes *gatewayapiv1.NodeList) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RedirectLinks", ctx, selector, availableNodes)
	ret0, _ := ret[0].(error)
	return ret0
}

// RedirectLinks indicates an expected call of RedirectLinks.
func (mr *MockLinkManagerMockRecorder) RedirectLinks(ctx, selector, availableNodes any) *MockLinkManagerRedirectLinksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RedirectLinks", reflect.TypeOf((*MockLinkManager)(nil).RedirectLinks), ctx, selector, availableNodes)
	return &MockLinkManagerRedirectLinksCall{Call: call}
}

// MockLinkManagerRedirectLinksCall wrap *gomock.Call
type MockLinkManagerRedirectLinksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerRedirectLinksCall) Return(arg0 error) *MockLinkManagerRedirectLinksCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerRedirectLinksCall) Do(f func(context.Context, gateway.LinkSelector, *gatewayapiv1.NodeList) error) *MockLinkManagerRedirectLinksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerRedirectLinksCall) DoAndReturn(f func(context.Context, gateway.LinkSelector, *gatewayapiv1.NodeList) error) *MockLinkManagerRedirectLinksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveLink mocks base method.
func (m *MockLinkManager) RemoveLink(linkID string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveLink", linkID)
	ret0, _ := ret[0].(bool)
	return ret0
}

// RemoveLink indicates an expected call of RemoveLink.
func (mr *MockLinkManagerMockRecorder) RemoveLink(linkID any) *MockLinkManagerRemoveLinkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveLink", reflect.TypeOf((*MockLinkManager)(nil).RemoveLink), linkID)
	return &MockLinkManagerRemoveLinkCall{Call: call}
}

// MockLinkManagerRemoveLinkCall wrap *gomock.Call
type MockLinkManagerRemoveLinkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkManagerRemoveLinkCall) Return(arg0 bool) *MockLinkManagerRemoveLinkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkManagerRemoveLinkCall) Do(f func(string) bool) *MockLinkManagerRemoveLinkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkManagerRemoveLinkCall) DoAndReturn(f func(string) bool) *MockLinkManagerRemoveLinkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockLinkSelector is a mock of LinkSelector interface.
type MockLinkSelector struct {
	ctrl     *gomock.Controller
	recorder *MockLinkSelectorMockRecorder
	isgomock struct{}
}

// MockLinkSelectorMockRecorder is the mock recorder for MockLinkSelector.
type MockLinkSelectorMockRecorder struct {
	mock *MockLinkSelector
}

// NewMockLinkSelector creates a new mock instance.
func NewMockLinkSelector(ctrl *gomock.Controller) *MockLinkSelector {
	mock := &MockLinkSelector{ctrl: ctrl}
	mock.recorder = &MockLinkSelectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLinkSelector) EXPECT() *MockLinkSelectorMockRecorder {
	return m.recorder
}

// Select mocks base method.
func (m *MockLinkSelector) Select(links []gateway.Link) []gateway.Link {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Select", links)
	ret0, _ := ret[0].([]gateway.Link)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockLinkSelectorMockRecorder) Select(links any) *MockLinkSelectorSelectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockLinkSelector)(nil).Select), links)
	return &MockLinkSelectorSelectCall{Call: call}
}

// MockLinkSelectorSelectCall wrap *gomock.Call
type MockLinkSelectorSelectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLinkSelectorSelectCall) Return(arg0 []gateway.Link) *MockLinkSelectorSelectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLinkSelectorSelectCall) Do(f func([]gateway.Link) []gateway.Link) *MockLinkSelectorSelectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLinkSelectorSelectCall) DoAndReturn(f func([]gateway.Link) []gateway.Link) *MockLinkSelectorSelectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockServiceRegistry is a mock of ServiceRegistry interface.
type MockServiceRegistry struct {
	ctrl     *gomock.Controller
	recorder *MockServiceRegistryMockRecorder
	isgomock struct{}
}

// MockServiceRegistryMockRecorder is the mock recorder for MockServiceRegistry.
type MockServiceRegistryMockRecorder struct {
	mock *MockServiceRegistry
}

// NewMockServiceRegistry creates a new mock instance.
func NewMockServiceRegistry(ctrl *gomock.Controller) *MockServiceRegistry {
	mock := &MockServiceRegistry{ctrl: ctrl}
	mock.recorder = &MockServiceRegistryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServiceRegistry) EXPECT() *MockServiceRegistryMockRecorder {
	return m.recorder
}

// Deregister mocks base method.
func (m *MockServiceRegistry) Deregister(ctx context.Context, leaseID clientv3.LeaseID, nodeID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deregister", ctx, leaseID, nodeID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deregister indicates an expected call of Deregister.
func (mr *MockServiceRegistryMockRecorder) Deregister(ctx, leaseID, nodeID any) *MockServiceRegistryDeregisterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deregister", reflect.TypeOf((*MockServiceRegistry)(nil).Deregister), ctx, leaseID, nodeID)
	return &MockServiceRegistryDeregisterCall{Call: call}
}

// MockServiceRegistryDeregisterCall wrap *gomock.Call
type MockServiceRegistryDeregisterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceRegistryDeregisterCall) Return(arg0 error) *MockServiceRegistryDeregisterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceRegistryDeregisterCall) Do(f func(context.Context, clientv3.LeaseID, string) error) *MockServiceRegistryDeregisterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceRegistryDeregisterCall) DoAndReturn(f func(context.Context, clientv3.LeaseID, string) error) *MockServiceRegistryDeregisterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAvailableNodes mocks base method.
func (m *MockServiceRegistry) GetAvailableNodes(ctx context.Context, selfID string) (*gatewayapiv1.NodeList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAvailableNodes", ctx, selfID)
	ret0, _ := ret[0].(*gatewayapiv1.NodeList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAvailableNodes indicates an expected call of GetAvailableNodes.
func (mr *MockServiceRegistryMockRecorder) GetAvailableNodes(ctx, selfID any) *MockServiceRegistryGetAvailableNodesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAvailableNodes", reflect.TypeOf((*MockServiceRegistry)(nil).GetAvailableNodes), ctx, selfID)
	return &MockServiceRegistryGetAvailableNodesCall{Call: call}
}

// MockServiceRegistryGetAvailableNodesCall wrap *gomock.Call
type MockServiceRegistryGetAvailableNodesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceRegistryGetAvailableNodesCall) Return(arg0 *gatewayapiv1.NodeList, arg1 error) *MockServiceRegistryGetAvailableNodesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceRegistryGetAvailableNodesCall) Do(f func(context.Context, string) (*gatewayapiv1.NodeList, error)) *MockServiceRegistryGetAvailableNodesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceRegistryGetAvailableNodesCall) DoAndReturn(f func(context.Context, string) (*gatewayapiv1.NodeList, error)) *MockServiceRegistryGetAvailableNodesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GracefulDeregister mocks base method.
func (m *MockServiceRegistry) GracefulDeregister(ctx context.Context, leaseID clientv3.LeaseID, nodeID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GracefulDeregister", ctx, leaseID, nodeID)
	ret0, _ := ret[0].(error)
	return ret0
}

// GracefulDeregister indicates an expected call of GracefulDeregister.
func (mr *MockServiceRegistryMockRecorder) GracefulDeregister(ctx, leaseID, nodeID any) *MockServiceRegistryGracefulDeregisterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GracefulDeregister", reflect.TypeOf((*MockServiceRegistry)(nil).GracefulDeregister), ctx, leaseID, nodeID)
	return &MockServiceRegistryGracefulDeregisterCall{Call: call}
}

// MockServiceRegistryGracefulDeregisterCall wrap *gomock.Call
type MockServiceRegistryGracefulDeregisterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceRegistryGracefulDeregisterCall) Return(arg0 error) *MockServiceRegistryGracefulDeregisterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceRegistryGracefulDeregisterCall) Do(f func(context.Context, clientv3.LeaseID, string) error) *MockServiceRegistryGracefulDeregisterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceRegistryGracefulDeregisterCall) DoAndReturn(f func(context.Context, clientv3.LeaseID, string) error) *MockServiceRegistryGracefulDeregisterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// KeepAlive mocks base method.
func (m *MockServiceRegistry) KeepAlive(ctx context.Context, leaseID clientv3.LeaseID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "KeepAlive", ctx, leaseID)
	ret0, _ := ret[0].(error)
	return ret0
}

// KeepAlive indicates an expected call of KeepAlive.
func (mr *MockServiceRegistryMockRecorder) KeepAlive(ctx, leaseID any) *MockServiceRegistryKeepAliveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KeepAlive", reflect.TypeOf((*MockServiceRegistry)(nil).KeepAlive), ctx, leaseID)
	return &MockServiceRegistryKeepAliveCall{Call: call}
}

// MockServiceRegistryKeepAliveCall wrap *gomock.Call
type MockServiceRegistryKeepAliveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceRegistryKeepAliveCall) Return(arg0 error) *MockServiceRegistryKeepAliveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceRegistryKeepAliveCall) Do(f func(context.Context, clientv3.LeaseID) error) *MockServiceRegistryKeepAliveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceRegistryKeepAliveCall) DoAndReturn(f func(context.Context, clientv3.LeaseID) error) *MockServiceRegistryKeepAliveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Register mocks base method.
func (m *MockServiceRegistry) Register(ctx context.Context, node *gatewayapiv1.Node) (clientv3.LeaseID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Register", ctx, node)
	ret0, _ := ret[0].(clientv3.LeaseID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Register indicates an expected call of Register.
func (mr *MockServiceRegistryMockRecorder) Register(ctx, node any) *MockServiceRegistryRegisterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockServiceRegistry)(nil).Register), ctx, node)
	return &MockServiceRegistryRegisterCall{Call: call}
}

// MockServiceRegistryRegisterCall wrap *gomock.Call
type MockServiceRegistryRegisterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceRegistryRegisterCall) Return(leaseID clientv3.LeaseID, err error) *MockServiceRegistryRegisterCall {
	c.Call = c.Call.Return(leaseID, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceRegistryRegisterCall) Do(f func(context.Context, *gatewayapiv1.Node) (clientv3.LeaseID, error)) *MockServiceRegistryRegisterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceRegistryRegisterCall) DoAndReturn(f func(context.Context, *gatewayapiv1.Node) (clientv3.LeaseID, error)) *MockServiceRegistryRegisterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartNodeStateUpdater mocks base method.
func (m *MockServiceRegistry) StartNodeStateUpdater(ctx context.Context, leaseID clientv3.LeaseID, nodeID string, updateFunc func(*gatewayapiv1.Node) bool, interval time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartNodeStateUpdater", ctx, leaseID, nodeID, updateFunc, interval)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartNodeStateUpdater indicates an expected call of StartNodeStateUpdater.
func (mr *MockServiceRegistryMockRecorder) StartNodeStateUpdater(ctx, leaseID, nodeID, updateFunc, interval any) *MockServiceRegistryStartNodeStateUpdaterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartNodeStateUpdater", reflect.TypeOf((*MockServiceRegistry)(nil).StartNodeStateUpdater), ctx, leaseID, nodeID, updateFunc, interval)
	return &MockServiceRegistryStartNodeStateUpdaterCall{Call: call}
}

// MockServiceRegistryStartNodeStateUpdaterCall wrap *gomock.Call
type MockServiceRegistryStartNodeStateUpdaterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceRegistryStartNodeStateUpdaterCall) Return(arg0 error) *MockServiceRegistryStartNodeStateUpdaterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceRegistryStartNodeStateUpdaterCall) Do(f func(context.Context, clientv3.LeaseID, string, func(*gatewayapiv1.Node) bool, time.Duration) error) *MockServiceRegistryStartNodeStateUpdaterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceRegistryStartNodeStateUpdaterCall) DoAndReturn(f func(context.Context, clientv3.LeaseID, string, func(*gatewayapiv1.Node) bool, time.Duration) error) *MockServiceRegistryStartNodeStateUpdaterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateNodeInfo mocks base method.
func (m *MockServiceRegistry) UpdateNodeInfo(ctx context.Context, leaseID clientv3.LeaseID, node *gatewayapiv1.Node) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateNodeInfo", ctx, leaseID, node)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateNodeInfo indicates an expected call of UpdateNodeInfo.
func (mr *MockServiceRegistryMockRecorder) UpdateNodeInfo(ctx, leaseID, node any) *MockServiceRegistryUpdateNodeInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNodeInfo", reflect.TypeOf((*MockServiceRegistry)(nil).UpdateNodeInfo), ctx, leaseID, node)
	return &MockServiceRegistryUpdateNodeInfoCall{Call: call}
}

// MockServiceRegistryUpdateNodeInfoCall wrap *gomock.Call
type MockServiceRegistryUpdateNodeInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceRegistryUpdateNodeInfoCall) Return(arg0 error) *MockServiceRegistryUpdateNodeInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceRegistryUpdateNodeInfoCall) Do(f func(context.Context, clientv3.LeaseID, *gatewayapiv1.Node) error) *MockServiceRegistryUpdateNodeInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceRegistryUpdateNodeInfoCall) DoAndReturn(f func(context.Context, clientv3.LeaseID, *gatewayapiv1.Node) error) *MockServiceRegistryUpdateNodeInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
