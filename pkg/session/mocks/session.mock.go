// Code generated by MockGen. DO NOT EDIT.
// Source: ./session.go
//
// Generated by this command:
//
//	mockgen -destination=./mocks/session.mock.go -package=sessmocks -typed -source=./session.go Session
//

// Package sessmocks is a generated GoMock package.
package sessmocks

import (
	context "context"
	reflect "reflect"

	session "gitee.com/flycash/ws-gateway/pkg/session"
	ekit "github.com/ecodeclub/ekit"
	gomock "go.uber.org/mock/gomock"
)

// MockSession is a mock of Session interface.
type MockSession struct {
	ctrl     *gomock.Controller
	recorder *MockSessionMockRecorder
	isgomock struct{}
}

// MockSessionMockRecorder is the mock recorder for MockSession.
type MockSessionMockRecorder struct {
	mock *MockSession
}

// NewMockSession creates a new mock instance.
func NewMockSession(ctrl *gomock.Controller) *MockSession {
	mock := &MockSession{ctrl: ctrl}
	mock.recorder = &MockSessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSession) EXPECT() *MockSessionMockRecorder {
	return m.recorder
}

// Destroy mocks base method.
func (m *MockSession) Destroy(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy.
func (mr *MockSessionMockRecorder) Destroy(ctx any) *MockSessionDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockSession)(nil).Destroy), ctx)
	return &MockSessionDestroyCall{Call: call}
}

// MockSessionDestroyCall wrap *gomock.Call
type MockSessionDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSessionDestroyCall) Return(arg0 error) *MockSessionDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSessionDestroyCall) Do(f func(context.Context) error) *MockSessionDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSessionDestroyCall) DoAndReturn(f func(context.Context) error) *MockSessionDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockSession) Get(ctx context.Context, key string) (ekit.AnyValue, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(ekit.AnyValue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockSessionMockRecorder) Get(ctx, key any) *MockSessionGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockSession)(nil).Get), ctx, key)
	return &MockSessionGetCall{Call: call}
}

// MockSessionGetCall wrap *gomock.Call
type MockSessionGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSessionGetCall) Return(arg0 ekit.AnyValue, arg1 error) *MockSessionGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSessionGetCall) Do(f func(context.Context, string) (ekit.AnyValue, error)) *MockSessionGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSessionGetCall) DoAndReturn(f func(context.Context, string) (ekit.AnyValue, error)) *MockSessionGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Set mocks base method.
func (m *MockSession) Set(ctx context.Context, key, value string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockSessionMockRecorder) Set(ctx, key, value any) *MockSessionSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockSession)(nil).Set), ctx, key, value)
	return &MockSessionSetCall{Call: call}
}

// MockSessionSetCall wrap *gomock.Call
type MockSessionSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSessionSetCall) Return(arg0 error) *MockSessionSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSessionSetCall) Do(f func(context.Context, string, string) error) *MockSessionSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSessionSetCall) DoAndReturn(f func(context.Context, string, string) error) *MockSessionSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UserInfo mocks base method.
func (m *MockSession) UserInfo() session.UserInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserInfo")
	ret0, _ := ret[0].(session.UserInfo)
	return ret0
}

// UserInfo indicates an expected call of UserInfo.
func (mr *MockSessionMockRecorder) UserInfo() *MockSessionUserInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserInfo", reflect.TypeOf((*MockSession)(nil).UserInfo))
	return &MockSessionUserInfoCall{Call: call}
}

// MockSessionUserInfoCall wrap *gomock.Call
type MockSessionUserInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSessionUserInfoCall) Return(arg0 session.UserInfo) *MockSessionUserInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSessionUserInfoCall) Do(f func() session.UserInfo) *MockSessionUserInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSessionUserInfoCall) DoAndReturn(f func() session.UserInfo) *MockSessionUserInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockBuilder is a mock of Builder interface.
type MockBuilder struct {
	ctrl     *gomock.Controller
	recorder *MockBuilderMockRecorder
	isgomock struct{}
}

// MockBuilderMockRecorder is the mock recorder for MockBuilder.
type MockBuilderMockRecorder struct {
	mock *MockBuilder
}

// NewMockBuilder creates a new mock instance.
func NewMockBuilder(ctrl *gomock.Controller) *MockBuilder {
	mock := &MockBuilder{ctrl: ctrl}
	mock.recorder = &MockBuilderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBuilder) EXPECT() *MockBuilderMockRecorder {
	return m.recorder
}

// Build mocks base method.
func (m *MockBuilder) Build(ctx context.Context, info session.UserInfo) (session.Session, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Build", ctx, info)
	ret0, _ := ret[0].(session.Session)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Build indicates an expected call of Build.
func (mr *MockBuilderMockRecorder) Build(ctx, info any) *MockBuilderBuildCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Build", reflect.TypeOf((*MockBuilder)(nil).Build), ctx, info)
	return &MockBuilderBuildCall{Call: call}
}

// MockBuilderBuildCall wrap *gomock.Call
type MockBuilderBuildCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockBuilderBuildCall) Return(arg0 session.Session, isNew bool, err error) *MockBuilderBuildCall {
	c.Call = c.Call.Return(arg0, isNew, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockBuilderBuildCall) Do(f func(context.Context, session.UserInfo) (session.Session, bool, error)) *MockBuilderBuildCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockBuilderBuildCall) DoAndReturn(f func(context.Context, session.UserInfo) (session.Session, bool, error)) *MockBuilderBuildCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
