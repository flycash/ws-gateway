// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/redis/go-redis/v9 (interfaces: Cmdable)
//
// Generated by this command:
//
//	mockgen -destination=./pkg/session/mocks/redis.mock.go -package=sessmocks -typed github.com/redis/go-redis/v9 Cmdable
//

// Package sessmocks is a generated GoMock package.
package sessmocks

import (
	context "context"
	reflect "reflect"
	time "time"

	redis "github.com/redis/go-redis/v9"
	gomock "go.uber.org/mock/gomock"
)

// MockCmdable is a mock of Cmdable interface.
type MockCmdable struct {
	ctrl     *gomock.Controller
	recorder *MockCmdableMockRecorder
	isgomock struct{}
}

// MockCmdableMockRecorder is the mock recorder for MockCmdable.
type MockCmdableMockRecorder struct {
	mock *MockCmdable
}

// NewMockCmdable creates a new mock instance.
func NewMockCmdable(ctrl *gomock.Controller) *MockCmdable {
	mock := &MockCmdable{ctrl: ctrl}
	mock.recorder = &MockCmdableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCmdable) EXPECT() *MockCmdableMockRecorder {
	return m.recorder
}

// ACLCat mocks base method.
func (m *MockCmdable) ACLCat(ctx context.Context) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ACLCat", ctx)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ACLCat indicates an expected call of ACLCat.
func (mr *MockCmdableMockRecorder) ACLCat(ctx any) *MockCmdableACLCatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLCat", reflect.TypeOf((*MockCmdable)(nil).ACLCat), ctx)
	return &MockCmdableACLCatCall{Call: call}
}

// MockCmdableACLCatCall wrap *gomock.Call
type MockCmdableACLCatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLCatCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableACLCatCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLCatCall) Do(f func(context.Context) *redis.StringSliceCmd) *MockCmdableACLCatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLCatCall) DoAndReturn(f func(context.Context) *redis.StringSliceCmd) *MockCmdableACLCatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ACLCatArgs mocks base method.
func (m *MockCmdable) ACLCatArgs(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ACLCatArgs", ctx, options)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ACLCatArgs indicates an expected call of ACLCatArgs.
func (mr *MockCmdableMockRecorder) ACLCatArgs(ctx, options any) *MockCmdableACLCatArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLCatArgs", reflect.TypeOf((*MockCmdable)(nil).ACLCatArgs), ctx, options)
	return &MockCmdableACLCatArgsCall{Call: call}
}

// MockCmdableACLCatArgsCall wrap *gomock.Call
type MockCmdableACLCatArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLCatArgsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableACLCatArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLCatArgsCall) Do(f func(context.Context, *redis.ACLCatArgs) *redis.StringSliceCmd) *MockCmdableACLCatArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLCatArgsCall) DoAndReturn(f func(context.Context, *redis.ACLCatArgs) *redis.StringSliceCmd) *MockCmdableACLCatArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ACLDelUser mocks base method.
func (m *MockCmdable) ACLDelUser(ctx context.Context, username string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ACLDelUser", ctx, username)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ACLDelUser indicates an expected call of ACLDelUser.
func (mr *MockCmdableMockRecorder) ACLDelUser(ctx, username any) *MockCmdableACLDelUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLDelUser", reflect.TypeOf((*MockCmdable)(nil).ACLDelUser), ctx, username)
	return &MockCmdableACLDelUserCall{Call: call}
}

// MockCmdableACLDelUserCall wrap *gomock.Call
type MockCmdableACLDelUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLDelUserCall) Return(arg0 *redis.IntCmd) *MockCmdableACLDelUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLDelUserCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableACLDelUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLDelUserCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableACLDelUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ACLDryRun mocks base method.
func (m *MockCmdable) ACLDryRun(ctx context.Context, username string, command ...any) *redis.StringCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, username}
	for _, a := range command {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ACLDryRun", varargs...)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ACLDryRun indicates an expected call of ACLDryRun.
func (mr *MockCmdableMockRecorder) ACLDryRun(ctx, username any, command ...any) *MockCmdableACLDryRunCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, username}, command...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLDryRun", reflect.TypeOf((*MockCmdable)(nil).ACLDryRun), varargs...)
	return &MockCmdableACLDryRunCall{Call: call}
}

// MockCmdableACLDryRunCall wrap *gomock.Call
type MockCmdableACLDryRunCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLDryRunCall) Return(arg0 *redis.StringCmd) *MockCmdableACLDryRunCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLDryRunCall) Do(f func(context.Context, string, ...any) *redis.StringCmd) *MockCmdableACLDryRunCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLDryRunCall) DoAndReturn(f func(context.Context, string, ...any) *redis.StringCmd) *MockCmdableACLDryRunCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ACLList mocks base method.
func (m *MockCmdable) ACLList(ctx context.Context) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ACLList", ctx)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ACLList indicates an expected call of ACLList.
func (mr *MockCmdableMockRecorder) ACLList(ctx any) *MockCmdableACLListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLList", reflect.TypeOf((*MockCmdable)(nil).ACLList), ctx)
	return &MockCmdableACLListCall{Call: call}
}

// MockCmdableACLListCall wrap *gomock.Call
type MockCmdableACLListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLListCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableACLListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLListCall) Do(f func(context.Context) *redis.StringSliceCmd) *MockCmdableACLListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLListCall) DoAndReturn(f func(context.Context) *redis.StringSliceCmd) *MockCmdableACLListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ACLLog mocks base method.
func (m *MockCmdable) ACLLog(ctx context.Context, count int64) *redis.ACLLogCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ACLLog", ctx, count)
	ret0, _ := ret[0].(*redis.ACLLogCmd)
	return ret0
}

// ACLLog indicates an expected call of ACLLog.
func (mr *MockCmdableMockRecorder) ACLLog(ctx, count any) *MockCmdableACLLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLLog", reflect.TypeOf((*MockCmdable)(nil).ACLLog), ctx, count)
	return &MockCmdableACLLogCall{Call: call}
}

// MockCmdableACLLogCall wrap *gomock.Call
type MockCmdableACLLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLLogCall) Return(arg0 *redis.ACLLogCmd) *MockCmdableACLLogCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLLogCall) Do(f func(context.Context, int64) *redis.ACLLogCmd) *MockCmdableACLLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLLogCall) DoAndReturn(f func(context.Context, int64) *redis.ACLLogCmd) *MockCmdableACLLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ACLLogReset mocks base method.
func (m *MockCmdable) ACLLogReset(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ACLLogReset", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ACLLogReset indicates an expected call of ACLLogReset.
func (mr *MockCmdableMockRecorder) ACLLogReset(ctx any) *MockCmdableACLLogResetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLLogReset", reflect.TypeOf((*MockCmdable)(nil).ACLLogReset), ctx)
	return &MockCmdableACLLogResetCall{Call: call}
}

// MockCmdableACLLogResetCall wrap *gomock.Call
type MockCmdableACLLogResetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLLogResetCall) Return(arg0 *redis.StatusCmd) *MockCmdableACLLogResetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLLogResetCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableACLLogResetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLLogResetCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableACLLogResetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ACLSetUser mocks base method.
func (m *MockCmdable) ACLSetUser(ctx context.Context, username string, rules ...string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, username}
	for _, a := range rules {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ACLSetUser", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ACLSetUser indicates an expected call of ACLSetUser.
func (mr *MockCmdableMockRecorder) ACLSetUser(ctx, username any, rules ...any) *MockCmdableACLSetUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, username}, rules...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ACLSetUser", reflect.TypeOf((*MockCmdable)(nil).ACLSetUser), varargs...)
	return &MockCmdableACLSetUserCall{Call: call}
}

// MockCmdableACLSetUserCall wrap *gomock.Call
type MockCmdableACLSetUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableACLSetUserCall) Return(arg0 *redis.StatusCmd) *MockCmdableACLSetUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableACLSetUserCall) Do(f func(context.Context, string, ...string) *redis.StatusCmd) *MockCmdableACLSetUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableACLSetUserCall) DoAndReturn(f func(context.Context, string, ...string) *redis.StatusCmd) *MockCmdableACLSetUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Append mocks base method.
func (m *MockCmdable) Append(ctx context.Context, key, value string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Append", ctx, key, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockCmdableMockRecorder) Append(ctx, key, value any) *MockCmdableAppendCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockCmdable)(nil).Append), ctx, key, value)
	return &MockCmdableAppendCall{Call: call}
}

// MockCmdableAppendCall wrap *gomock.Call
type MockCmdableAppendCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableAppendCall) Return(arg0 *redis.IntCmd) *MockCmdableAppendCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableAppendCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableAppendCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableAppendCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableAppendCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFAdd mocks base method.
func (m *MockCmdable) BFAdd(ctx context.Context, key string, element any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFAdd", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// BFAdd indicates an expected call of BFAdd.
func (mr *MockCmdableMockRecorder) BFAdd(ctx, key, element any) *MockCmdableBFAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFAdd", reflect.TypeOf((*MockCmdable)(nil).BFAdd), ctx, key, element)
	return &MockCmdableBFAddCall{Call: call}
}

// MockCmdableBFAddCall wrap *gomock.Call
type MockCmdableBFAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFAddCall) Return(arg0 *redis.BoolCmd) *MockCmdableBFAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFAddCall) Do(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableBFAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFAddCall) DoAndReturn(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableBFAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFCard mocks base method.
func (m *MockCmdable) BFCard(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFCard", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BFCard indicates an expected call of BFCard.
func (mr *MockCmdableMockRecorder) BFCard(ctx, key any) *MockCmdableBFCardCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFCard", reflect.TypeOf((*MockCmdable)(nil).BFCard), ctx, key)
	return &MockCmdableBFCardCall{Call: call}
}

// MockCmdableBFCardCall wrap *gomock.Call
type MockCmdableBFCardCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFCardCall) Return(arg0 *redis.IntCmd) *MockCmdableBFCardCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFCardCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableBFCardCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFCardCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableBFCardCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFExists mocks base method.
func (m *MockCmdable) BFExists(ctx context.Context, key string, element any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFExists", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// BFExists indicates an expected call of BFExists.
func (mr *MockCmdableMockRecorder) BFExists(ctx, key, element any) *MockCmdableBFExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFExists", reflect.TypeOf((*MockCmdable)(nil).BFExists), ctx, key, element)
	return &MockCmdableBFExistsCall{Call: call}
}

// MockCmdableBFExistsCall wrap *gomock.Call
type MockCmdableBFExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFExistsCall) Return(arg0 *redis.BoolCmd) *MockCmdableBFExistsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFExistsCall) Do(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableBFExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFExistsCall) DoAndReturn(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableBFExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInfo mocks base method.
func (m *MockCmdable) BFInfo(ctx context.Context, key string) *redis.BFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFInfo", ctx, key)
	ret0, _ := ret[0].(*redis.BFInfoCmd)
	return ret0
}

// BFInfo indicates an expected call of BFInfo.
func (mr *MockCmdableMockRecorder) BFInfo(ctx, key any) *MockCmdableBFInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInfo", reflect.TypeOf((*MockCmdable)(nil).BFInfo), ctx, key)
	return &MockCmdableBFInfoCall{Call: call}
}

// MockCmdableBFInfoCall wrap *gomock.Call
type MockCmdableBFInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInfoCall) Return(arg0 *redis.BFInfoCmd) *MockCmdableBFInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInfoCall) Do(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInfoCall) DoAndReturn(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInfoArg mocks base method.
func (m *MockCmdable) BFInfoArg(ctx context.Context, key, option string) *redis.BFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFInfoArg", ctx, key, option)
	ret0, _ := ret[0].(*redis.BFInfoCmd)
	return ret0
}

// BFInfoArg indicates an expected call of BFInfoArg.
func (mr *MockCmdableMockRecorder) BFInfoArg(ctx, key, option any) *MockCmdableBFInfoArgCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInfoArg", reflect.TypeOf((*MockCmdable)(nil).BFInfoArg), ctx, key, option)
	return &MockCmdableBFInfoArgCall{Call: call}
}

// MockCmdableBFInfoArgCall wrap *gomock.Call
type MockCmdableBFInfoArgCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInfoArgCall) Return(arg0 *redis.BFInfoCmd) *MockCmdableBFInfoArgCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInfoArgCall) Do(f func(context.Context, string, string) *redis.BFInfoCmd) *MockCmdableBFInfoArgCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInfoArgCall) DoAndReturn(f func(context.Context, string, string) *redis.BFInfoCmd) *MockCmdableBFInfoArgCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInfoCapacity mocks base method.
func (m *MockCmdable) BFInfoCapacity(ctx context.Context, key string) *redis.BFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFInfoCapacity", ctx, key)
	ret0, _ := ret[0].(*redis.BFInfoCmd)
	return ret0
}

// BFInfoCapacity indicates an expected call of BFInfoCapacity.
func (mr *MockCmdableMockRecorder) BFInfoCapacity(ctx, key any) *MockCmdableBFInfoCapacityCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInfoCapacity", reflect.TypeOf((*MockCmdable)(nil).BFInfoCapacity), ctx, key)
	return &MockCmdableBFInfoCapacityCall{Call: call}
}

// MockCmdableBFInfoCapacityCall wrap *gomock.Call
type MockCmdableBFInfoCapacityCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInfoCapacityCall) Return(arg0 *redis.BFInfoCmd) *MockCmdableBFInfoCapacityCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInfoCapacityCall) Do(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoCapacityCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInfoCapacityCall) DoAndReturn(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoCapacityCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInfoExpansion mocks base method.
func (m *MockCmdable) BFInfoExpansion(ctx context.Context, key string) *redis.BFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFInfoExpansion", ctx, key)
	ret0, _ := ret[0].(*redis.BFInfoCmd)
	return ret0
}

// BFInfoExpansion indicates an expected call of BFInfoExpansion.
func (mr *MockCmdableMockRecorder) BFInfoExpansion(ctx, key any) *MockCmdableBFInfoExpansionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInfoExpansion", reflect.TypeOf((*MockCmdable)(nil).BFInfoExpansion), ctx, key)
	return &MockCmdableBFInfoExpansionCall{Call: call}
}

// MockCmdableBFInfoExpansionCall wrap *gomock.Call
type MockCmdableBFInfoExpansionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInfoExpansionCall) Return(arg0 *redis.BFInfoCmd) *MockCmdableBFInfoExpansionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInfoExpansionCall) Do(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoExpansionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInfoExpansionCall) DoAndReturn(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoExpansionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInfoFilters mocks base method.
func (m *MockCmdable) BFInfoFilters(ctx context.Context, key string) *redis.BFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFInfoFilters", ctx, key)
	ret0, _ := ret[0].(*redis.BFInfoCmd)
	return ret0
}

// BFInfoFilters indicates an expected call of BFInfoFilters.
func (mr *MockCmdableMockRecorder) BFInfoFilters(ctx, key any) *MockCmdableBFInfoFiltersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInfoFilters", reflect.TypeOf((*MockCmdable)(nil).BFInfoFilters), ctx, key)
	return &MockCmdableBFInfoFiltersCall{Call: call}
}

// MockCmdableBFInfoFiltersCall wrap *gomock.Call
type MockCmdableBFInfoFiltersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInfoFiltersCall) Return(arg0 *redis.BFInfoCmd) *MockCmdableBFInfoFiltersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInfoFiltersCall) Do(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoFiltersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInfoFiltersCall) DoAndReturn(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoFiltersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInfoItems mocks base method.
func (m *MockCmdable) BFInfoItems(ctx context.Context, key string) *redis.BFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFInfoItems", ctx, key)
	ret0, _ := ret[0].(*redis.BFInfoCmd)
	return ret0
}

// BFInfoItems indicates an expected call of BFInfoItems.
func (mr *MockCmdableMockRecorder) BFInfoItems(ctx, key any) *MockCmdableBFInfoItemsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInfoItems", reflect.TypeOf((*MockCmdable)(nil).BFInfoItems), ctx, key)
	return &MockCmdableBFInfoItemsCall{Call: call}
}

// MockCmdableBFInfoItemsCall wrap *gomock.Call
type MockCmdableBFInfoItemsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInfoItemsCall) Return(arg0 *redis.BFInfoCmd) *MockCmdableBFInfoItemsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInfoItemsCall) Do(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoItemsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInfoItemsCall) DoAndReturn(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoItemsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInfoSize mocks base method.
func (m *MockCmdable) BFInfoSize(ctx context.Context, key string) *redis.BFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFInfoSize", ctx, key)
	ret0, _ := ret[0].(*redis.BFInfoCmd)
	return ret0
}

// BFInfoSize indicates an expected call of BFInfoSize.
func (mr *MockCmdableMockRecorder) BFInfoSize(ctx, key any) *MockCmdableBFInfoSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInfoSize", reflect.TypeOf((*MockCmdable)(nil).BFInfoSize), ctx, key)
	return &MockCmdableBFInfoSizeCall{Call: call}
}

// MockCmdableBFInfoSizeCall wrap *gomock.Call
type MockCmdableBFInfoSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInfoSizeCall) Return(arg0 *redis.BFInfoCmd) *MockCmdableBFInfoSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInfoSizeCall) Do(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInfoSizeCall) DoAndReturn(f func(context.Context, string) *redis.BFInfoCmd) *MockCmdableBFInfoSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFInsert mocks base method.
func (m *MockCmdable) BFInsert(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...any) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, options}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BFInsert", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// BFInsert indicates an expected call of BFInsert.
func (mr *MockCmdableMockRecorder) BFInsert(ctx, key, options any, elements ...any) *MockCmdableBFInsertCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, options}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFInsert", reflect.TypeOf((*MockCmdable)(nil).BFInsert), varargs...)
	return &MockCmdableBFInsertCall{Call: call}
}

// MockCmdableBFInsertCall wrap *gomock.Call
type MockCmdableBFInsertCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFInsertCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableBFInsertCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFInsertCall) Do(f func(context.Context, string, *redis.BFInsertOptions, ...any) *redis.BoolSliceCmd) *MockCmdableBFInsertCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFInsertCall) DoAndReturn(f func(context.Context, string, *redis.BFInsertOptions, ...any) *redis.BoolSliceCmd) *MockCmdableBFInsertCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFLoadChunk mocks base method.
func (m *MockCmdable) BFLoadChunk(ctx context.Context, key string, iterator int64, data any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFLoadChunk", ctx, key, iterator, data)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// BFLoadChunk indicates an expected call of BFLoadChunk.
func (mr *MockCmdableMockRecorder) BFLoadChunk(ctx, key, iterator, data any) *MockCmdableBFLoadChunkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFLoadChunk", reflect.TypeOf((*MockCmdable)(nil).BFLoadChunk), ctx, key, iterator, data)
	return &MockCmdableBFLoadChunkCall{Call: call}
}

// MockCmdableBFLoadChunkCall wrap *gomock.Call
type MockCmdableBFLoadChunkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFLoadChunkCall) Return(arg0 *redis.StatusCmd) *MockCmdableBFLoadChunkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFLoadChunkCall) Do(f func(context.Context, string, int64, any) *redis.StatusCmd) *MockCmdableBFLoadChunkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFLoadChunkCall) DoAndReturn(f func(context.Context, string, int64, any) *redis.StatusCmd) *MockCmdableBFLoadChunkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFMAdd mocks base method.
func (m *MockCmdable) BFMAdd(ctx context.Context, key string, elements ...any) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BFMAdd", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// BFMAdd indicates an expected call of BFMAdd.
func (mr *MockCmdableMockRecorder) BFMAdd(ctx, key any, elements ...any) *MockCmdableBFMAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFMAdd", reflect.TypeOf((*MockCmdable)(nil).BFMAdd), varargs...)
	return &MockCmdableBFMAddCall{Call: call}
}

// MockCmdableBFMAddCall wrap *gomock.Call
type MockCmdableBFMAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFMAddCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableBFMAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFMAddCall) Do(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableBFMAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFMAddCall) DoAndReturn(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableBFMAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFMExists mocks base method.
func (m *MockCmdable) BFMExists(ctx context.Context, key string, elements ...any) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BFMExists", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// BFMExists indicates an expected call of BFMExists.
func (mr *MockCmdableMockRecorder) BFMExists(ctx, key any, elements ...any) *MockCmdableBFMExistsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFMExists", reflect.TypeOf((*MockCmdable)(nil).BFMExists), varargs...)
	return &MockCmdableBFMExistsCall{Call: call}
}

// MockCmdableBFMExistsCall wrap *gomock.Call
type MockCmdableBFMExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFMExistsCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableBFMExistsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFMExistsCall) Do(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableBFMExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFMExistsCall) DoAndReturn(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableBFMExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFReserve mocks base method.
func (m *MockCmdable) BFReserve(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFReserve", ctx, key, errorRate, capacity)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// BFReserve indicates an expected call of BFReserve.
func (mr *MockCmdableMockRecorder) BFReserve(ctx, key, errorRate, capacity any) *MockCmdableBFReserveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFReserve", reflect.TypeOf((*MockCmdable)(nil).BFReserve), ctx, key, errorRate, capacity)
	return &MockCmdableBFReserveCall{Call: call}
}

// MockCmdableBFReserveCall wrap *gomock.Call
type MockCmdableBFReserveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFReserveCall) Return(arg0 *redis.StatusCmd) *MockCmdableBFReserveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFReserveCall) Do(f func(context.Context, string, float64, int64) *redis.StatusCmd) *MockCmdableBFReserveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFReserveCall) DoAndReturn(f func(context.Context, string, float64, int64) *redis.StatusCmd) *MockCmdableBFReserveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFReserveExpansion mocks base method.
func (m *MockCmdable) BFReserveExpansion(ctx context.Context, key string, errorRate float64, capacity, expansion int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFReserveExpansion", ctx, key, errorRate, capacity, expansion)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// BFReserveExpansion indicates an expected call of BFReserveExpansion.
func (mr *MockCmdableMockRecorder) BFReserveExpansion(ctx, key, errorRate, capacity, expansion any) *MockCmdableBFReserveExpansionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFReserveExpansion", reflect.TypeOf((*MockCmdable)(nil).BFReserveExpansion), ctx, key, errorRate, capacity, expansion)
	return &MockCmdableBFReserveExpansionCall{Call: call}
}

// MockCmdableBFReserveExpansionCall wrap *gomock.Call
type MockCmdableBFReserveExpansionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFReserveExpansionCall) Return(arg0 *redis.StatusCmd) *MockCmdableBFReserveExpansionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFReserveExpansionCall) Do(f func(context.Context, string, float64, int64, int64) *redis.StatusCmd) *MockCmdableBFReserveExpansionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFReserveExpansionCall) DoAndReturn(f func(context.Context, string, float64, int64, int64) *redis.StatusCmd) *MockCmdableBFReserveExpansionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFReserveNonScaling mocks base method.
func (m *MockCmdable) BFReserveNonScaling(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFReserveNonScaling", ctx, key, errorRate, capacity)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// BFReserveNonScaling indicates an expected call of BFReserveNonScaling.
func (mr *MockCmdableMockRecorder) BFReserveNonScaling(ctx, key, errorRate, capacity any) *MockCmdableBFReserveNonScalingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFReserveNonScaling", reflect.TypeOf((*MockCmdable)(nil).BFReserveNonScaling), ctx, key, errorRate, capacity)
	return &MockCmdableBFReserveNonScalingCall{Call: call}
}

// MockCmdableBFReserveNonScalingCall wrap *gomock.Call
type MockCmdableBFReserveNonScalingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFReserveNonScalingCall) Return(arg0 *redis.StatusCmd) *MockCmdableBFReserveNonScalingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFReserveNonScalingCall) Do(f func(context.Context, string, float64, int64) *redis.StatusCmd) *MockCmdableBFReserveNonScalingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFReserveNonScalingCall) DoAndReturn(f func(context.Context, string, float64, int64) *redis.StatusCmd) *MockCmdableBFReserveNonScalingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFReserveWithArgs mocks base method.
func (m *MockCmdable) BFReserveWithArgs(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFReserveWithArgs", ctx, key, options)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// BFReserveWithArgs indicates an expected call of BFReserveWithArgs.
func (mr *MockCmdableMockRecorder) BFReserveWithArgs(ctx, key, options any) *MockCmdableBFReserveWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFReserveWithArgs", reflect.TypeOf((*MockCmdable)(nil).BFReserveWithArgs), ctx, key, options)
	return &MockCmdableBFReserveWithArgsCall{Call: call}
}

// MockCmdableBFReserveWithArgsCall wrap *gomock.Call
type MockCmdableBFReserveWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFReserveWithArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableBFReserveWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFReserveWithArgsCall) Do(f func(context.Context, string, *redis.BFReserveOptions) *redis.StatusCmd) *MockCmdableBFReserveWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFReserveWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.BFReserveOptions) *redis.StatusCmd) *MockCmdableBFReserveWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BFScanDump mocks base method.
func (m *MockCmdable) BFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BFScanDump", ctx, key, iterator)
	ret0, _ := ret[0].(*redis.ScanDumpCmd)
	return ret0
}

// BFScanDump indicates an expected call of BFScanDump.
func (mr *MockCmdableMockRecorder) BFScanDump(ctx, key, iterator any) *MockCmdableBFScanDumpCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BFScanDump", reflect.TypeOf((*MockCmdable)(nil).BFScanDump), ctx, key, iterator)
	return &MockCmdableBFScanDumpCall{Call: call}
}

// MockCmdableBFScanDumpCall wrap *gomock.Call
type MockCmdableBFScanDumpCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBFScanDumpCall) Return(arg0 *redis.ScanDumpCmd) *MockCmdableBFScanDumpCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBFScanDumpCall) Do(f func(context.Context, string, int64) *redis.ScanDumpCmd) *MockCmdableBFScanDumpCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBFScanDumpCall) DoAndReturn(f func(context.Context, string, int64) *redis.ScanDumpCmd) *MockCmdableBFScanDumpCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BLMPop mocks base method.
func (m *MockCmdable) BLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, timeout, direction, count}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BLMPop", varargs...)
	ret0, _ := ret[0].(*redis.KeyValuesCmd)
	return ret0
}

// BLMPop indicates an expected call of BLMPop.
func (mr *MockCmdableMockRecorder) BLMPop(ctx, timeout, direction, count any, keys ...any) *MockCmdableBLMPopCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, timeout, direction, count}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BLMPop", reflect.TypeOf((*MockCmdable)(nil).BLMPop), varargs...)
	return &MockCmdableBLMPopCall{Call: call}
}

// MockCmdableBLMPopCall wrap *gomock.Call
type MockCmdableBLMPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBLMPopCall) Return(arg0 *redis.KeyValuesCmd) *MockCmdableBLMPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBLMPopCall) Do(f func(context.Context, time.Duration, string, int64, ...string) *redis.KeyValuesCmd) *MockCmdableBLMPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBLMPopCall) DoAndReturn(f func(context.Context, time.Duration, string, int64, ...string) *redis.KeyValuesCmd) *MockCmdableBLMPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BLMove mocks base method.
func (m *MockCmdable) BLMove(ctx context.Context, source, destination, srcpos, destpos string, timeout time.Duration) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BLMove", ctx, source, destination, srcpos, destpos, timeout)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// BLMove indicates an expected call of BLMove.
func (mr *MockCmdableMockRecorder) BLMove(ctx, source, destination, srcpos, destpos, timeout any) *MockCmdableBLMoveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BLMove", reflect.TypeOf((*MockCmdable)(nil).BLMove), ctx, source, destination, srcpos, destpos, timeout)
	return &MockCmdableBLMoveCall{Call: call}
}

// MockCmdableBLMoveCall wrap *gomock.Call
type MockCmdableBLMoveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBLMoveCall) Return(arg0 *redis.StringCmd) *MockCmdableBLMoveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBLMoveCall) Do(f func(context.Context, string, string, string, string, time.Duration) *redis.StringCmd) *MockCmdableBLMoveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBLMoveCall) DoAndReturn(f func(context.Context, string, string, string, string, time.Duration) *redis.StringCmd) *MockCmdableBLMoveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BLPop mocks base method.
func (m *MockCmdable) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, timeout}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BLPop", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// BLPop indicates an expected call of BLPop.
func (mr *MockCmdableMockRecorder) BLPop(ctx, timeout any, keys ...any) *MockCmdableBLPopCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, timeout}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BLPop", reflect.TypeOf((*MockCmdable)(nil).BLPop), varargs...)
	return &MockCmdableBLPopCall{Call: call}
}

// MockCmdableBLPopCall wrap *gomock.Call
type MockCmdableBLPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBLPopCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableBLPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBLPopCall) Do(f func(context.Context, time.Duration, ...string) *redis.StringSliceCmd) *MockCmdableBLPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBLPopCall) DoAndReturn(f func(context.Context, time.Duration, ...string) *redis.StringSliceCmd) *MockCmdableBLPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BRPop mocks base method.
func (m *MockCmdable) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, timeout}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BRPop", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// BRPop indicates an expected call of BRPop.
func (mr *MockCmdableMockRecorder) BRPop(ctx, timeout any, keys ...any) *MockCmdableBRPopCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, timeout}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BRPop", reflect.TypeOf((*MockCmdable)(nil).BRPop), varargs...)
	return &MockCmdableBRPopCall{Call: call}
}

// MockCmdableBRPopCall wrap *gomock.Call
type MockCmdableBRPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBRPopCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableBRPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBRPopCall) Do(f func(context.Context, time.Duration, ...string) *redis.StringSliceCmd) *MockCmdableBRPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBRPopCall) DoAndReturn(f func(context.Context, time.Duration, ...string) *redis.StringSliceCmd) *MockCmdableBRPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BRPopLPush mocks base method.
func (m *MockCmdable) BRPopLPush(ctx context.Context, source, destination string, timeout time.Duration) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BRPopLPush", ctx, source, destination, timeout)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// BRPopLPush indicates an expected call of BRPopLPush.
func (mr *MockCmdableMockRecorder) BRPopLPush(ctx, source, destination, timeout any) *MockCmdableBRPopLPushCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BRPopLPush", reflect.TypeOf((*MockCmdable)(nil).BRPopLPush), ctx, source, destination, timeout)
	return &MockCmdableBRPopLPushCall{Call: call}
}

// MockCmdableBRPopLPushCall wrap *gomock.Call
type MockCmdableBRPopLPushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBRPopLPushCall) Return(arg0 *redis.StringCmd) *MockCmdableBRPopLPushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBRPopLPushCall) Do(f func(context.Context, string, string, time.Duration) *redis.StringCmd) *MockCmdableBRPopLPushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBRPopLPushCall) DoAndReturn(f func(context.Context, string, string, time.Duration) *redis.StringCmd) *MockCmdableBRPopLPushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BZMPop mocks base method.
func (m *MockCmdable) BZMPop(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, timeout, order, count}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BZMPop", varargs...)
	ret0, _ := ret[0].(*redis.ZSliceWithKeyCmd)
	return ret0
}

// BZMPop indicates an expected call of BZMPop.
func (mr *MockCmdableMockRecorder) BZMPop(ctx, timeout, order, count any, keys ...any) *MockCmdableBZMPopCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, timeout, order, count}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BZMPop", reflect.TypeOf((*MockCmdable)(nil).BZMPop), varargs...)
	return &MockCmdableBZMPopCall{Call: call}
}

// MockCmdableBZMPopCall wrap *gomock.Call
type MockCmdableBZMPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBZMPopCall) Return(arg0 *redis.ZSliceWithKeyCmd) *MockCmdableBZMPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBZMPopCall) Do(f func(context.Context, time.Duration, string, int64, ...string) *redis.ZSliceWithKeyCmd) *MockCmdableBZMPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBZMPopCall) DoAndReturn(f func(context.Context, time.Duration, string, int64, ...string) *redis.ZSliceWithKeyCmd) *MockCmdableBZMPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BZPopMax mocks base method.
func (m *MockCmdable) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, timeout}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BZPopMax", varargs...)
	ret0, _ := ret[0].(*redis.ZWithKeyCmd)
	return ret0
}

// BZPopMax indicates an expected call of BZPopMax.
func (mr *MockCmdableMockRecorder) BZPopMax(ctx, timeout any, keys ...any) *MockCmdableBZPopMaxCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, timeout}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BZPopMax", reflect.TypeOf((*MockCmdable)(nil).BZPopMax), varargs...)
	return &MockCmdableBZPopMaxCall{Call: call}
}

// MockCmdableBZPopMaxCall wrap *gomock.Call
type MockCmdableBZPopMaxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBZPopMaxCall) Return(arg0 *redis.ZWithKeyCmd) *MockCmdableBZPopMaxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBZPopMaxCall) Do(f func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd) *MockCmdableBZPopMaxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBZPopMaxCall) DoAndReturn(f func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd) *MockCmdableBZPopMaxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BZPopMin mocks base method.
func (m *MockCmdable) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, timeout}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BZPopMin", varargs...)
	ret0, _ := ret[0].(*redis.ZWithKeyCmd)
	return ret0
}

// BZPopMin indicates an expected call of BZPopMin.
func (mr *MockCmdableMockRecorder) BZPopMin(ctx, timeout any, keys ...any) *MockCmdableBZPopMinCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, timeout}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BZPopMin", reflect.TypeOf((*MockCmdable)(nil).BZPopMin), varargs...)
	return &MockCmdableBZPopMinCall{Call: call}
}

// MockCmdableBZPopMinCall wrap *gomock.Call
type MockCmdableBZPopMinCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBZPopMinCall) Return(arg0 *redis.ZWithKeyCmd) *MockCmdableBZPopMinCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBZPopMinCall) Do(f func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd) *MockCmdableBZPopMinCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBZPopMinCall) DoAndReturn(f func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd) *MockCmdableBZPopMinCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BgRewriteAOF mocks base method.
func (m *MockCmdable) BgRewriteAOF(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BgRewriteAOF", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// BgRewriteAOF indicates an expected call of BgRewriteAOF.
func (mr *MockCmdableMockRecorder) BgRewriteAOF(ctx any) *MockCmdableBgRewriteAOFCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BgRewriteAOF", reflect.TypeOf((*MockCmdable)(nil).BgRewriteAOF), ctx)
	return &MockCmdableBgRewriteAOFCall{Call: call}
}

// MockCmdableBgRewriteAOFCall wrap *gomock.Call
type MockCmdableBgRewriteAOFCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBgRewriteAOFCall) Return(arg0 *redis.StatusCmd) *MockCmdableBgRewriteAOFCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBgRewriteAOFCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableBgRewriteAOFCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBgRewriteAOFCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableBgRewriteAOFCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BgSave mocks base method.
func (m *MockCmdable) BgSave(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BgSave", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// BgSave indicates an expected call of BgSave.
func (mr *MockCmdableMockRecorder) BgSave(ctx any) *MockCmdableBgSaveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BgSave", reflect.TypeOf((*MockCmdable)(nil).BgSave), ctx)
	return &MockCmdableBgSaveCall{Call: call}
}

// MockCmdableBgSaveCall wrap *gomock.Call
type MockCmdableBgSaveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBgSaveCall) Return(arg0 *redis.StatusCmd) *MockCmdableBgSaveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBgSaveCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableBgSaveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBgSaveCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableBgSaveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitCount mocks base method.
func (m *MockCmdable) BitCount(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BitCount", ctx, key, bitCount)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BitCount indicates an expected call of BitCount.
func (mr *MockCmdableMockRecorder) BitCount(ctx, key, bitCount any) *MockCmdableBitCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitCount", reflect.TypeOf((*MockCmdable)(nil).BitCount), ctx, key, bitCount)
	return &MockCmdableBitCountCall{Call: call}
}

// MockCmdableBitCountCall wrap *gomock.Call
type MockCmdableBitCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitCountCall) Return(arg0 *redis.IntCmd) *MockCmdableBitCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitCountCall) Do(f func(context.Context, string, *redis.BitCount) *redis.IntCmd) *MockCmdableBitCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitCountCall) DoAndReturn(f func(context.Context, string, *redis.BitCount) *redis.IntCmd) *MockCmdableBitCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitField mocks base method.
func (m *MockCmdable) BitField(ctx context.Context, key string, values ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BitField", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// BitField indicates an expected call of BitField.
func (mr *MockCmdableMockRecorder) BitField(ctx, key any, values ...any) *MockCmdableBitFieldCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitField", reflect.TypeOf((*MockCmdable)(nil).BitField), varargs...)
	return &MockCmdableBitFieldCall{Call: call}
}

// MockCmdableBitFieldCall wrap *gomock.Call
type MockCmdableBitFieldCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitFieldCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableBitFieldCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitFieldCall) Do(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableBitFieldCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitFieldCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableBitFieldCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitFieldRO mocks base method.
func (m *MockCmdable) BitFieldRO(ctx context.Context, key string, values ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BitFieldRO", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// BitFieldRO indicates an expected call of BitFieldRO.
func (mr *MockCmdableMockRecorder) BitFieldRO(ctx, key any, values ...any) *MockCmdableBitFieldROCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitFieldRO", reflect.TypeOf((*MockCmdable)(nil).BitFieldRO), varargs...)
	return &MockCmdableBitFieldROCall{Call: call}
}

// MockCmdableBitFieldROCall wrap *gomock.Call
type MockCmdableBitFieldROCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitFieldROCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableBitFieldROCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitFieldROCall) Do(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableBitFieldROCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitFieldROCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableBitFieldROCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitOpAnd mocks base method.
func (m *MockCmdable) BitOpAnd(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destKey}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BitOpAnd", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BitOpAnd indicates an expected call of BitOpAnd.
func (mr *MockCmdableMockRecorder) BitOpAnd(ctx, destKey any, keys ...any) *MockCmdableBitOpAndCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destKey}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitOpAnd", reflect.TypeOf((*MockCmdable)(nil).BitOpAnd), varargs...)
	return &MockCmdableBitOpAndCall{Call: call}
}

// MockCmdableBitOpAndCall wrap *gomock.Call
type MockCmdableBitOpAndCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitOpAndCall) Return(arg0 *redis.IntCmd) *MockCmdableBitOpAndCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitOpAndCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableBitOpAndCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitOpAndCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableBitOpAndCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitOpNot mocks base method.
func (m *MockCmdable) BitOpNot(ctx context.Context, destKey, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BitOpNot", ctx, destKey, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BitOpNot indicates an expected call of BitOpNot.
func (mr *MockCmdableMockRecorder) BitOpNot(ctx, destKey, key any) *MockCmdableBitOpNotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitOpNot", reflect.TypeOf((*MockCmdable)(nil).BitOpNot), ctx, destKey, key)
	return &MockCmdableBitOpNotCall{Call: call}
}

// MockCmdableBitOpNotCall wrap *gomock.Call
type MockCmdableBitOpNotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitOpNotCall) Return(arg0 *redis.IntCmd) *MockCmdableBitOpNotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitOpNotCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableBitOpNotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitOpNotCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableBitOpNotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitOpOr mocks base method.
func (m *MockCmdable) BitOpOr(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destKey}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BitOpOr", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BitOpOr indicates an expected call of BitOpOr.
func (mr *MockCmdableMockRecorder) BitOpOr(ctx, destKey any, keys ...any) *MockCmdableBitOpOrCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destKey}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitOpOr", reflect.TypeOf((*MockCmdable)(nil).BitOpOr), varargs...)
	return &MockCmdableBitOpOrCall{Call: call}
}

// MockCmdableBitOpOrCall wrap *gomock.Call
type MockCmdableBitOpOrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitOpOrCall) Return(arg0 *redis.IntCmd) *MockCmdableBitOpOrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitOpOrCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableBitOpOrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitOpOrCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableBitOpOrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitOpXor mocks base method.
func (m *MockCmdable) BitOpXor(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destKey}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BitOpXor", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BitOpXor indicates an expected call of BitOpXor.
func (mr *MockCmdableMockRecorder) BitOpXor(ctx, destKey any, keys ...any) *MockCmdableBitOpXorCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destKey}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitOpXor", reflect.TypeOf((*MockCmdable)(nil).BitOpXor), varargs...)
	return &MockCmdableBitOpXorCall{Call: call}
}

// MockCmdableBitOpXorCall wrap *gomock.Call
type MockCmdableBitOpXorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitOpXorCall) Return(arg0 *redis.IntCmd) *MockCmdableBitOpXorCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitOpXorCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableBitOpXorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitOpXorCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableBitOpXorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitPos mocks base method.
func (m *MockCmdable) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, bit}
	for _, a := range pos {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BitPos", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BitPos indicates an expected call of BitPos.
func (mr *MockCmdableMockRecorder) BitPos(ctx, key, bit any, pos ...any) *MockCmdableBitPosCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, bit}, pos...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitPos", reflect.TypeOf((*MockCmdable)(nil).BitPos), varargs...)
	return &MockCmdableBitPosCall{Call: call}
}

// MockCmdableBitPosCall wrap *gomock.Call
type MockCmdableBitPosCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitPosCall) Return(arg0 *redis.IntCmd) *MockCmdableBitPosCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitPosCall) Do(f func(context.Context, string, int64, ...int64) *redis.IntCmd) *MockCmdableBitPosCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitPosCall) DoAndReturn(f func(context.Context, string, int64, ...int64) *redis.IntCmd) *MockCmdableBitPosCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BitPosSpan mocks base method.
func (m *MockCmdable) BitPosSpan(ctx context.Context, key string, bit int8, start, end int64, span string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BitPosSpan", ctx, key, bit, start, end, span)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// BitPosSpan indicates an expected call of BitPosSpan.
func (mr *MockCmdableMockRecorder) BitPosSpan(ctx, key, bit, start, end, span any) *MockCmdableBitPosSpanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BitPosSpan", reflect.TypeOf((*MockCmdable)(nil).BitPosSpan), ctx, key, bit, start, end, span)
	return &MockCmdableBitPosSpanCall{Call: call}
}

// MockCmdableBitPosSpanCall wrap *gomock.Call
type MockCmdableBitPosSpanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableBitPosSpanCall) Return(arg0 *redis.IntCmd) *MockCmdableBitPosSpanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableBitPosSpanCall) Do(f func(context.Context, string, int8, int64, int64, string) *redis.IntCmd) *MockCmdableBitPosSpanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableBitPosSpanCall) DoAndReturn(f func(context.Context, string, int8, int64, int64, string) *redis.IntCmd) *MockCmdableBitPosSpanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFAdd mocks base method.
func (m *MockCmdable) CFAdd(ctx context.Context, key string, element any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFAdd", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// CFAdd indicates an expected call of CFAdd.
func (mr *MockCmdableMockRecorder) CFAdd(ctx, key, element any) *MockCmdableCFAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFAdd", reflect.TypeOf((*MockCmdable)(nil).CFAdd), ctx, key, element)
	return &MockCmdableCFAddCall{Call: call}
}

// MockCmdableCFAddCall wrap *gomock.Call
type MockCmdableCFAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFAddCall) Return(arg0 *redis.BoolCmd) *MockCmdableCFAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFAddCall) Do(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFAddCall) DoAndReturn(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFAddNX mocks base method.
func (m *MockCmdable) CFAddNX(ctx context.Context, key string, element any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFAddNX", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// CFAddNX indicates an expected call of CFAddNX.
func (mr *MockCmdableMockRecorder) CFAddNX(ctx, key, element any) *MockCmdableCFAddNXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFAddNX", reflect.TypeOf((*MockCmdable)(nil).CFAddNX), ctx, key, element)
	return &MockCmdableCFAddNXCall{Call: call}
}

// MockCmdableCFAddNXCall wrap *gomock.Call
type MockCmdableCFAddNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFAddNXCall) Return(arg0 *redis.BoolCmd) *MockCmdableCFAddNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFAddNXCall) Do(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFAddNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFAddNXCall) DoAndReturn(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFAddNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFCount mocks base method.
func (m *MockCmdable) CFCount(ctx context.Context, key string, element any) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFCount", ctx, key, element)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// CFCount indicates an expected call of CFCount.
func (mr *MockCmdableMockRecorder) CFCount(ctx, key, element any) *MockCmdableCFCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFCount", reflect.TypeOf((*MockCmdable)(nil).CFCount), ctx, key, element)
	return &MockCmdableCFCountCall{Call: call}
}

// MockCmdableCFCountCall wrap *gomock.Call
type MockCmdableCFCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFCountCall) Return(arg0 *redis.IntCmd) *MockCmdableCFCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFCountCall) Do(f func(context.Context, string, any) *redis.IntCmd) *MockCmdableCFCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFCountCall) DoAndReturn(f func(context.Context, string, any) *redis.IntCmd) *MockCmdableCFCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFDel mocks base method.
func (m *MockCmdable) CFDel(ctx context.Context, key string, element any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFDel", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// CFDel indicates an expected call of CFDel.
func (mr *MockCmdableMockRecorder) CFDel(ctx, key, element any) *MockCmdableCFDelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFDel", reflect.TypeOf((*MockCmdable)(nil).CFDel), ctx, key, element)
	return &MockCmdableCFDelCall{Call: call}
}

// MockCmdableCFDelCall wrap *gomock.Call
type MockCmdableCFDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFDelCall) Return(arg0 *redis.BoolCmd) *MockCmdableCFDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFDelCall) Do(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFDelCall) DoAndReturn(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFExists mocks base method.
func (m *MockCmdable) CFExists(ctx context.Context, key string, element any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFExists", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// CFExists indicates an expected call of CFExists.
func (mr *MockCmdableMockRecorder) CFExists(ctx, key, element any) *MockCmdableCFExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFExists", reflect.TypeOf((*MockCmdable)(nil).CFExists), ctx, key, element)
	return &MockCmdableCFExistsCall{Call: call}
}

// MockCmdableCFExistsCall wrap *gomock.Call
type MockCmdableCFExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFExistsCall) Return(arg0 *redis.BoolCmd) *MockCmdableCFExistsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFExistsCall) Do(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFExistsCall) DoAndReturn(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableCFExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFInfo mocks base method.
func (m *MockCmdable) CFInfo(ctx context.Context, key string) *redis.CFInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFInfo", ctx, key)
	ret0, _ := ret[0].(*redis.CFInfoCmd)
	return ret0
}

// CFInfo indicates an expected call of CFInfo.
func (mr *MockCmdableMockRecorder) CFInfo(ctx, key any) *MockCmdableCFInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFInfo", reflect.TypeOf((*MockCmdable)(nil).CFInfo), ctx, key)
	return &MockCmdableCFInfoCall{Call: call}
}

// MockCmdableCFInfoCall wrap *gomock.Call
type MockCmdableCFInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFInfoCall) Return(arg0 *redis.CFInfoCmd) *MockCmdableCFInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFInfoCall) Do(f func(context.Context, string) *redis.CFInfoCmd) *MockCmdableCFInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFInfoCall) DoAndReturn(f func(context.Context, string) *redis.CFInfoCmd) *MockCmdableCFInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFInsert mocks base method.
func (m *MockCmdable) CFInsert(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...any) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, options}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CFInsert", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// CFInsert indicates an expected call of CFInsert.
func (mr *MockCmdableMockRecorder) CFInsert(ctx, key, options any, elements ...any) *MockCmdableCFInsertCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, options}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFInsert", reflect.TypeOf((*MockCmdable)(nil).CFInsert), varargs...)
	return &MockCmdableCFInsertCall{Call: call}
}

// MockCmdableCFInsertCall wrap *gomock.Call
type MockCmdableCFInsertCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFInsertCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableCFInsertCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFInsertCall) Do(f func(context.Context, string, *redis.CFInsertOptions, ...any) *redis.BoolSliceCmd) *MockCmdableCFInsertCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFInsertCall) DoAndReturn(f func(context.Context, string, *redis.CFInsertOptions, ...any) *redis.BoolSliceCmd) *MockCmdableCFInsertCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFInsertNX mocks base method.
func (m *MockCmdable) CFInsertNX(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, options}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CFInsertNX", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// CFInsertNX indicates an expected call of CFInsertNX.
func (mr *MockCmdableMockRecorder) CFInsertNX(ctx, key, options any, elements ...any) *MockCmdableCFInsertNXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, options}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFInsertNX", reflect.TypeOf((*MockCmdable)(nil).CFInsertNX), varargs...)
	return &MockCmdableCFInsertNXCall{Call: call}
}

// MockCmdableCFInsertNXCall wrap *gomock.Call
type MockCmdableCFInsertNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFInsertNXCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableCFInsertNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFInsertNXCall) Do(f func(context.Context, string, *redis.CFInsertOptions, ...any) *redis.IntSliceCmd) *MockCmdableCFInsertNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFInsertNXCall) DoAndReturn(f func(context.Context, string, *redis.CFInsertOptions, ...any) *redis.IntSliceCmd) *MockCmdableCFInsertNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFLoadChunk mocks base method.
func (m *MockCmdable) CFLoadChunk(ctx context.Context, key string, iterator int64, data any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFLoadChunk", ctx, key, iterator, data)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CFLoadChunk indicates an expected call of CFLoadChunk.
func (mr *MockCmdableMockRecorder) CFLoadChunk(ctx, key, iterator, data any) *MockCmdableCFLoadChunkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFLoadChunk", reflect.TypeOf((*MockCmdable)(nil).CFLoadChunk), ctx, key, iterator, data)
	return &MockCmdableCFLoadChunkCall{Call: call}
}

// MockCmdableCFLoadChunkCall wrap *gomock.Call
type MockCmdableCFLoadChunkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFLoadChunkCall) Return(arg0 *redis.StatusCmd) *MockCmdableCFLoadChunkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFLoadChunkCall) Do(f func(context.Context, string, int64, any) *redis.StatusCmd) *MockCmdableCFLoadChunkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFLoadChunkCall) DoAndReturn(f func(context.Context, string, int64, any) *redis.StatusCmd) *MockCmdableCFLoadChunkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFMExists mocks base method.
func (m *MockCmdable) CFMExists(ctx context.Context, key string, elements ...any) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CFMExists", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// CFMExists indicates an expected call of CFMExists.
func (mr *MockCmdableMockRecorder) CFMExists(ctx, key any, elements ...any) *MockCmdableCFMExistsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFMExists", reflect.TypeOf((*MockCmdable)(nil).CFMExists), varargs...)
	return &MockCmdableCFMExistsCall{Call: call}
}

// MockCmdableCFMExistsCall wrap *gomock.Call
type MockCmdableCFMExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFMExistsCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableCFMExistsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFMExistsCall) Do(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableCFMExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFMExistsCall) DoAndReturn(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableCFMExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFReserve mocks base method.
func (m *MockCmdable) CFReserve(ctx context.Context, key string, capacity int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFReserve", ctx, key, capacity)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CFReserve indicates an expected call of CFReserve.
func (mr *MockCmdableMockRecorder) CFReserve(ctx, key, capacity any) *MockCmdableCFReserveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFReserve", reflect.TypeOf((*MockCmdable)(nil).CFReserve), ctx, key, capacity)
	return &MockCmdableCFReserveCall{Call: call}
}

// MockCmdableCFReserveCall wrap *gomock.Call
type MockCmdableCFReserveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFReserveCall) Return(arg0 *redis.StatusCmd) *MockCmdableCFReserveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFReserveCall) Do(f func(context.Context, string, int64) *redis.StatusCmd) *MockCmdableCFReserveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFReserveCall) DoAndReturn(f func(context.Context, string, int64) *redis.StatusCmd) *MockCmdableCFReserveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFReserveBucketSize mocks base method.
func (m *MockCmdable) CFReserveBucketSize(ctx context.Context, key string, capacity, bucketsize int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFReserveBucketSize", ctx, key, capacity, bucketsize)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CFReserveBucketSize indicates an expected call of CFReserveBucketSize.
func (mr *MockCmdableMockRecorder) CFReserveBucketSize(ctx, key, capacity, bucketsize any) *MockCmdableCFReserveBucketSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFReserveBucketSize", reflect.TypeOf((*MockCmdable)(nil).CFReserveBucketSize), ctx, key, capacity, bucketsize)
	return &MockCmdableCFReserveBucketSizeCall{Call: call}
}

// MockCmdableCFReserveBucketSizeCall wrap *gomock.Call
type MockCmdableCFReserveBucketSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFReserveBucketSizeCall) Return(arg0 *redis.StatusCmd) *MockCmdableCFReserveBucketSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFReserveBucketSizeCall) Do(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCFReserveBucketSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFReserveBucketSizeCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCFReserveBucketSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFReserveExpansion mocks base method.
func (m *MockCmdable) CFReserveExpansion(ctx context.Context, key string, capacity, expansion int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFReserveExpansion", ctx, key, capacity, expansion)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CFReserveExpansion indicates an expected call of CFReserveExpansion.
func (mr *MockCmdableMockRecorder) CFReserveExpansion(ctx, key, capacity, expansion any) *MockCmdableCFReserveExpansionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFReserveExpansion", reflect.TypeOf((*MockCmdable)(nil).CFReserveExpansion), ctx, key, capacity, expansion)
	return &MockCmdableCFReserveExpansionCall{Call: call}
}

// MockCmdableCFReserveExpansionCall wrap *gomock.Call
type MockCmdableCFReserveExpansionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFReserveExpansionCall) Return(arg0 *redis.StatusCmd) *MockCmdableCFReserveExpansionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFReserveExpansionCall) Do(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCFReserveExpansionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFReserveExpansionCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCFReserveExpansionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFReserveMaxIterations mocks base method.
func (m *MockCmdable) CFReserveMaxIterations(ctx context.Context, key string, capacity, maxiterations int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFReserveMaxIterations", ctx, key, capacity, maxiterations)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CFReserveMaxIterations indicates an expected call of CFReserveMaxIterations.
func (mr *MockCmdableMockRecorder) CFReserveMaxIterations(ctx, key, capacity, maxiterations any) *MockCmdableCFReserveMaxIterationsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFReserveMaxIterations", reflect.TypeOf((*MockCmdable)(nil).CFReserveMaxIterations), ctx, key, capacity, maxiterations)
	return &MockCmdableCFReserveMaxIterationsCall{Call: call}
}

// MockCmdableCFReserveMaxIterationsCall wrap *gomock.Call
type MockCmdableCFReserveMaxIterationsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFReserveMaxIterationsCall) Return(arg0 *redis.StatusCmd) *MockCmdableCFReserveMaxIterationsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFReserveMaxIterationsCall) Do(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCFReserveMaxIterationsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFReserveMaxIterationsCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCFReserveMaxIterationsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFReserveWithArgs mocks base method.
func (m *MockCmdable) CFReserveWithArgs(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFReserveWithArgs", ctx, key, options)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CFReserveWithArgs indicates an expected call of CFReserveWithArgs.
func (mr *MockCmdableMockRecorder) CFReserveWithArgs(ctx, key, options any) *MockCmdableCFReserveWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFReserveWithArgs", reflect.TypeOf((*MockCmdable)(nil).CFReserveWithArgs), ctx, key, options)
	return &MockCmdableCFReserveWithArgsCall{Call: call}
}

// MockCmdableCFReserveWithArgsCall wrap *gomock.Call
type MockCmdableCFReserveWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFReserveWithArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableCFReserveWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFReserveWithArgsCall) Do(f func(context.Context, string, *redis.CFReserveOptions) *redis.StatusCmd) *MockCmdableCFReserveWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFReserveWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.CFReserveOptions) *redis.StatusCmd) *MockCmdableCFReserveWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CFScanDump mocks base method.
func (m *MockCmdable) CFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CFScanDump", ctx, key, iterator)
	ret0, _ := ret[0].(*redis.ScanDumpCmd)
	return ret0
}

// CFScanDump indicates an expected call of CFScanDump.
func (mr *MockCmdableMockRecorder) CFScanDump(ctx, key, iterator any) *MockCmdableCFScanDumpCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CFScanDump", reflect.TypeOf((*MockCmdable)(nil).CFScanDump), ctx, key, iterator)
	return &MockCmdableCFScanDumpCall{Call: call}
}

// MockCmdableCFScanDumpCall wrap *gomock.Call
type MockCmdableCFScanDumpCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCFScanDumpCall) Return(arg0 *redis.ScanDumpCmd) *MockCmdableCFScanDumpCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCFScanDumpCall) Do(f func(context.Context, string, int64) *redis.ScanDumpCmd) *MockCmdableCFScanDumpCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCFScanDumpCall) DoAndReturn(f func(context.Context, string, int64) *redis.ScanDumpCmd) *MockCmdableCFScanDumpCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CMSIncrBy mocks base method.
func (m *MockCmdable) CMSIncrBy(ctx context.Context, key string, elements ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CMSIncrBy", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// CMSIncrBy indicates an expected call of CMSIncrBy.
func (mr *MockCmdableMockRecorder) CMSIncrBy(ctx, key any, elements ...any) *MockCmdableCMSIncrByCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CMSIncrBy", reflect.TypeOf((*MockCmdable)(nil).CMSIncrBy), varargs...)
	return &MockCmdableCMSIncrByCall{Call: call}
}

// MockCmdableCMSIncrByCall wrap *gomock.Call
type MockCmdableCMSIncrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCMSIncrByCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableCMSIncrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCMSIncrByCall) Do(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableCMSIncrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCMSIncrByCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableCMSIncrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CMSInfo mocks base method.
func (m *MockCmdable) CMSInfo(ctx context.Context, key string) *redis.CMSInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CMSInfo", ctx, key)
	ret0, _ := ret[0].(*redis.CMSInfoCmd)
	return ret0
}

// CMSInfo indicates an expected call of CMSInfo.
func (mr *MockCmdableMockRecorder) CMSInfo(ctx, key any) *MockCmdableCMSInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CMSInfo", reflect.TypeOf((*MockCmdable)(nil).CMSInfo), ctx, key)
	return &MockCmdableCMSInfoCall{Call: call}
}

// MockCmdableCMSInfoCall wrap *gomock.Call
type MockCmdableCMSInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCMSInfoCall) Return(arg0 *redis.CMSInfoCmd) *MockCmdableCMSInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCMSInfoCall) Do(f func(context.Context, string) *redis.CMSInfoCmd) *MockCmdableCMSInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCMSInfoCall) DoAndReturn(f func(context.Context, string) *redis.CMSInfoCmd) *MockCmdableCMSInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CMSInitByDim mocks base method.
func (m *MockCmdable) CMSInitByDim(ctx context.Context, key string, width, height int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CMSInitByDim", ctx, key, width, height)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CMSInitByDim indicates an expected call of CMSInitByDim.
func (mr *MockCmdableMockRecorder) CMSInitByDim(ctx, key, width, height any) *MockCmdableCMSInitByDimCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CMSInitByDim", reflect.TypeOf((*MockCmdable)(nil).CMSInitByDim), ctx, key, width, height)
	return &MockCmdableCMSInitByDimCall{Call: call}
}

// MockCmdableCMSInitByDimCall wrap *gomock.Call
type MockCmdableCMSInitByDimCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCMSInitByDimCall) Return(arg0 *redis.StatusCmd) *MockCmdableCMSInitByDimCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCMSInitByDimCall) Do(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCMSInitByDimCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCMSInitByDimCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableCMSInitByDimCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CMSInitByProb mocks base method.
func (m *MockCmdable) CMSInitByProb(ctx context.Context, key string, errorRate, probability float64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CMSInitByProb", ctx, key, errorRate, probability)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CMSInitByProb indicates an expected call of CMSInitByProb.
func (mr *MockCmdableMockRecorder) CMSInitByProb(ctx, key, errorRate, probability any) *MockCmdableCMSInitByProbCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CMSInitByProb", reflect.TypeOf((*MockCmdable)(nil).CMSInitByProb), ctx, key, errorRate, probability)
	return &MockCmdableCMSInitByProbCall{Call: call}
}

// MockCmdableCMSInitByProbCall wrap *gomock.Call
type MockCmdableCMSInitByProbCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCMSInitByProbCall) Return(arg0 *redis.StatusCmd) *MockCmdableCMSInitByProbCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCMSInitByProbCall) Do(f func(context.Context, string, float64, float64) *redis.StatusCmd) *MockCmdableCMSInitByProbCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCMSInitByProbCall) DoAndReturn(f func(context.Context, string, float64, float64) *redis.StatusCmd) *MockCmdableCMSInitByProbCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CMSMerge mocks base method.
func (m *MockCmdable) CMSMerge(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destKey}
	for _, a := range sourceKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CMSMerge", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CMSMerge indicates an expected call of CMSMerge.
func (mr *MockCmdableMockRecorder) CMSMerge(ctx, destKey any, sourceKeys ...any) *MockCmdableCMSMergeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destKey}, sourceKeys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CMSMerge", reflect.TypeOf((*MockCmdable)(nil).CMSMerge), varargs...)
	return &MockCmdableCMSMergeCall{Call: call}
}

// MockCmdableCMSMergeCall wrap *gomock.Call
type MockCmdableCMSMergeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCMSMergeCall) Return(arg0 *redis.StatusCmd) *MockCmdableCMSMergeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCMSMergeCall) Do(f func(context.Context, string, ...string) *redis.StatusCmd) *MockCmdableCMSMergeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCMSMergeCall) DoAndReturn(f func(context.Context, string, ...string) *redis.StatusCmd) *MockCmdableCMSMergeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CMSMergeWithWeight mocks base method.
func (m *MockCmdable) CMSMergeWithWeight(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CMSMergeWithWeight", ctx, destKey, sourceKeys)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// CMSMergeWithWeight indicates an expected call of CMSMergeWithWeight.
func (mr *MockCmdableMockRecorder) CMSMergeWithWeight(ctx, destKey, sourceKeys any) *MockCmdableCMSMergeWithWeightCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CMSMergeWithWeight", reflect.TypeOf((*MockCmdable)(nil).CMSMergeWithWeight), ctx, destKey, sourceKeys)
	return &MockCmdableCMSMergeWithWeightCall{Call: call}
}

// MockCmdableCMSMergeWithWeightCall wrap *gomock.Call
type MockCmdableCMSMergeWithWeightCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCMSMergeWithWeightCall) Return(arg0 *redis.StatusCmd) *MockCmdableCMSMergeWithWeightCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCMSMergeWithWeightCall) Do(f func(context.Context, string, map[string]int64) *redis.StatusCmd) *MockCmdableCMSMergeWithWeightCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCMSMergeWithWeightCall) DoAndReturn(f func(context.Context, string, map[string]int64) *redis.StatusCmd) *MockCmdableCMSMergeWithWeightCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CMSQuery mocks base method.
func (m *MockCmdable) CMSQuery(ctx context.Context, key string, elements ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CMSQuery", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// CMSQuery indicates an expected call of CMSQuery.
func (mr *MockCmdableMockRecorder) CMSQuery(ctx, key any, elements ...any) *MockCmdableCMSQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CMSQuery", reflect.TypeOf((*MockCmdable)(nil).CMSQuery), varargs...)
	return &MockCmdableCMSQueryCall{Call: call}
}

// MockCmdableCMSQueryCall wrap *gomock.Call
type MockCmdableCMSQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCMSQueryCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableCMSQueryCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCMSQueryCall) Do(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableCMSQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCMSQueryCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableCMSQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientGetName mocks base method.
func (m *MockCmdable) ClientGetName(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientGetName", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ClientGetName indicates an expected call of ClientGetName.
func (mr *MockCmdableMockRecorder) ClientGetName(ctx any) *MockCmdableClientGetNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientGetName", reflect.TypeOf((*MockCmdable)(nil).ClientGetName), ctx)
	return &MockCmdableClientGetNameCall{Call: call}
}

// MockCmdableClientGetNameCall wrap *gomock.Call
type MockCmdableClientGetNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientGetNameCall) Return(arg0 *redis.StringCmd) *MockCmdableClientGetNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientGetNameCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableClientGetNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientGetNameCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableClientGetNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientID mocks base method.
func (m *MockCmdable) ClientID(ctx context.Context) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientID", ctx)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ClientID indicates an expected call of ClientID.
func (mr *MockCmdableMockRecorder) ClientID(ctx any) *MockCmdableClientIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientID", reflect.TypeOf((*MockCmdable)(nil).ClientID), ctx)
	return &MockCmdableClientIDCall{Call: call}
}

// MockCmdableClientIDCall wrap *gomock.Call
type MockCmdableClientIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientIDCall) Return(arg0 *redis.IntCmd) *MockCmdableClientIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientIDCall) Do(f func(context.Context) *redis.IntCmd) *MockCmdableClientIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientIDCall) DoAndReturn(f func(context.Context) *redis.IntCmd) *MockCmdableClientIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientInfo mocks base method.
func (m *MockCmdable) ClientInfo(ctx context.Context) *redis.ClientInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientInfo", ctx)
	ret0, _ := ret[0].(*redis.ClientInfoCmd)
	return ret0
}

// ClientInfo indicates an expected call of ClientInfo.
func (mr *MockCmdableMockRecorder) ClientInfo(ctx any) *MockCmdableClientInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientInfo", reflect.TypeOf((*MockCmdable)(nil).ClientInfo), ctx)
	return &MockCmdableClientInfoCall{Call: call}
}

// MockCmdableClientInfoCall wrap *gomock.Call
type MockCmdableClientInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientInfoCall) Return(arg0 *redis.ClientInfoCmd) *MockCmdableClientInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientInfoCall) Do(f func(context.Context) *redis.ClientInfoCmd) *MockCmdableClientInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientInfoCall) DoAndReturn(f func(context.Context) *redis.ClientInfoCmd) *MockCmdableClientInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientKill mocks base method.
func (m *MockCmdable) ClientKill(ctx context.Context, ipPort string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientKill", ctx, ipPort)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClientKill indicates an expected call of ClientKill.
func (mr *MockCmdableMockRecorder) ClientKill(ctx, ipPort any) *MockCmdableClientKillCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientKill", reflect.TypeOf((*MockCmdable)(nil).ClientKill), ctx, ipPort)
	return &MockCmdableClientKillCall{Call: call}
}

// MockCmdableClientKillCall wrap *gomock.Call
type MockCmdableClientKillCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientKillCall) Return(arg0 *redis.StatusCmd) *MockCmdableClientKillCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientKillCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableClientKillCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientKillCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableClientKillCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientKillByFilter mocks base method.
func (m *MockCmdable) ClientKillByFilter(ctx context.Context, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ClientKillByFilter", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ClientKillByFilter indicates an expected call of ClientKillByFilter.
func (mr *MockCmdableMockRecorder) ClientKillByFilter(ctx any, keys ...any) *MockCmdableClientKillByFilterCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientKillByFilter", reflect.TypeOf((*MockCmdable)(nil).ClientKillByFilter), varargs...)
	return &MockCmdableClientKillByFilterCall{Call: call}
}

// MockCmdableClientKillByFilterCall wrap *gomock.Call
type MockCmdableClientKillByFilterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientKillByFilterCall) Return(arg0 *redis.IntCmd) *MockCmdableClientKillByFilterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientKillByFilterCall) Do(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableClientKillByFilterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientKillByFilterCall) DoAndReturn(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableClientKillByFilterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientList mocks base method.
func (m *MockCmdable) ClientList(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientList", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ClientList indicates an expected call of ClientList.
func (mr *MockCmdableMockRecorder) ClientList(ctx any) *MockCmdableClientListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientList", reflect.TypeOf((*MockCmdable)(nil).ClientList), ctx)
	return &MockCmdableClientListCall{Call: call}
}

// MockCmdableClientListCall wrap *gomock.Call
type MockCmdableClientListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientListCall) Return(arg0 *redis.StringCmd) *MockCmdableClientListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientListCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableClientListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientListCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableClientListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientPause mocks base method.
func (m *MockCmdable) ClientPause(ctx context.Context, dur time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientPause", ctx, dur)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// ClientPause indicates an expected call of ClientPause.
func (mr *MockCmdableMockRecorder) ClientPause(ctx, dur any) *MockCmdableClientPauseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientPause", reflect.TypeOf((*MockCmdable)(nil).ClientPause), ctx, dur)
	return &MockCmdableClientPauseCall{Call: call}
}

// MockCmdableClientPauseCall wrap *gomock.Call
type MockCmdableClientPauseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientPauseCall) Return(arg0 *redis.BoolCmd) *MockCmdableClientPauseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientPauseCall) Do(f func(context.Context, time.Duration) *redis.BoolCmd) *MockCmdableClientPauseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientPauseCall) DoAndReturn(f func(context.Context, time.Duration) *redis.BoolCmd) *MockCmdableClientPauseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientUnblock mocks base method.
func (m *MockCmdable) ClientUnblock(ctx context.Context, id int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientUnblock", ctx, id)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ClientUnblock indicates an expected call of ClientUnblock.
func (mr *MockCmdableMockRecorder) ClientUnblock(ctx, id any) *MockCmdableClientUnblockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientUnblock", reflect.TypeOf((*MockCmdable)(nil).ClientUnblock), ctx, id)
	return &MockCmdableClientUnblockCall{Call: call}
}

// MockCmdableClientUnblockCall wrap *gomock.Call
type MockCmdableClientUnblockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientUnblockCall) Return(arg0 *redis.IntCmd) *MockCmdableClientUnblockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientUnblockCall) Do(f func(context.Context, int64) *redis.IntCmd) *MockCmdableClientUnblockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientUnblockCall) DoAndReturn(f func(context.Context, int64) *redis.IntCmd) *MockCmdableClientUnblockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientUnblockWithError mocks base method.
func (m *MockCmdable) ClientUnblockWithError(ctx context.Context, id int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientUnblockWithError", ctx, id)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ClientUnblockWithError indicates an expected call of ClientUnblockWithError.
func (mr *MockCmdableMockRecorder) ClientUnblockWithError(ctx, id any) *MockCmdableClientUnblockWithErrorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientUnblockWithError", reflect.TypeOf((*MockCmdable)(nil).ClientUnblockWithError), ctx, id)
	return &MockCmdableClientUnblockWithErrorCall{Call: call}
}

// MockCmdableClientUnblockWithErrorCall wrap *gomock.Call
type MockCmdableClientUnblockWithErrorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientUnblockWithErrorCall) Return(arg0 *redis.IntCmd) *MockCmdableClientUnblockWithErrorCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientUnblockWithErrorCall) Do(f func(context.Context, int64) *redis.IntCmd) *MockCmdableClientUnblockWithErrorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientUnblockWithErrorCall) DoAndReturn(f func(context.Context, int64) *redis.IntCmd) *MockCmdableClientUnblockWithErrorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClientUnpause mocks base method.
func (m *MockCmdable) ClientUnpause(ctx context.Context) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClientUnpause", ctx)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// ClientUnpause indicates an expected call of ClientUnpause.
func (mr *MockCmdableMockRecorder) ClientUnpause(ctx any) *MockCmdableClientUnpauseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClientUnpause", reflect.TypeOf((*MockCmdable)(nil).ClientUnpause), ctx)
	return &MockCmdableClientUnpauseCall{Call: call}
}

// MockCmdableClientUnpauseCall wrap *gomock.Call
type MockCmdableClientUnpauseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClientUnpauseCall) Return(arg0 *redis.BoolCmd) *MockCmdableClientUnpauseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClientUnpauseCall) Do(f func(context.Context) *redis.BoolCmd) *MockCmdableClientUnpauseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClientUnpauseCall) DoAndReturn(f func(context.Context) *redis.BoolCmd) *MockCmdableClientUnpauseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterAddSlots mocks base method.
func (m *MockCmdable) ClusterAddSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range slots {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ClusterAddSlots", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterAddSlots indicates an expected call of ClusterAddSlots.
func (mr *MockCmdableMockRecorder) ClusterAddSlots(ctx any, slots ...any) *MockCmdableClusterAddSlotsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, slots...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterAddSlots", reflect.TypeOf((*MockCmdable)(nil).ClusterAddSlots), varargs...)
	return &MockCmdableClusterAddSlotsCall{Call: call}
}

// MockCmdableClusterAddSlotsCall wrap *gomock.Call
type MockCmdableClusterAddSlotsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterAddSlotsCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterAddSlotsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterAddSlotsCall) Do(f func(context.Context, ...int) *redis.StatusCmd) *MockCmdableClusterAddSlotsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterAddSlotsCall) DoAndReturn(f func(context.Context, ...int) *redis.StatusCmd) *MockCmdableClusterAddSlotsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterAddSlotsRange mocks base method.
func (m *MockCmdable) ClusterAddSlotsRange(ctx context.Context, min, max int) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterAddSlotsRange", ctx, min, max)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterAddSlotsRange indicates an expected call of ClusterAddSlotsRange.
func (mr *MockCmdableMockRecorder) ClusterAddSlotsRange(ctx, min, max any) *MockCmdableClusterAddSlotsRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterAddSlotsRange", reflect.TypeOf((*MockCmdable)(nil).ClusterAddSlotsRange), ctx, min, max)
	return &MockCmdableClusterAddSlotsRangeCall{Call: call}
}

// MockCmdableClusterAddSlotsRangeCall wrap *gomock.Call
type MockCmdableClusterAddSlotsRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterAddSlotsRangeCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterAddSlotsRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterAddSlotsRangeCall) Do(f func(context.Context, int, int) *redis.StatusCmd) *MockCmdableClusterAddSlotsRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterAddSlotsRangeCall) DoAndReturn(f func(context.Context, int, int) *redis.StatusCmd) *MockCmdableClusterAddSlotsRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterCountFailureReports mocks base method.
func (m *MockCmdable) ClusterCountFailureReports(ctx context.Context, nodeID string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterCountFailureReports", ctx, nodeID)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ClusterCountFailureReports indicates an expected call of ClusterCountFailureReports.
func (mr *MockCmdableMockRecorder) ClusterCountFailureReports(ctx, nodeID any) *MockCmdableClusterCountFailureReportsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterCountFailureReports", reflect.TypeOf((*MockCmdable)(nil).ClusterCountFailureReports), ctx, nodeID)
	return &MockCmdableClusterCountFailureReportsCall{Call: call}
}

// MockCmdableClusterCountFailureReportsCall wrap *gomock.Call
type MockCmdableClusterCountFailureReportsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterCountFailureReportsCall) Return(arg0 *redis.IntCmd) *MockCmdableClusterCountFailureReportsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterCountFailureReportsCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableClusterCountFailureReportsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterCountFailureReportsCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableClusterCountFailureReportsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterCountKeysInSlot mocks base method.
func (m *MockCmdable) ClusterCountKeysInSlot(ctx context.Context, slot int) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterCountKeysInSlot", ctx, slot)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ClusterCountKeysInSlot indicates an expected call of ClusterCountKeysInSlot.
func (mr *MockCmdableMockRecorder) ClusterCountKeysInSlot(ctx, slot any) *MockCmdableClusterCountKeysInSlotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterCountKeysInSlot", reflect.TypeOf((*MockCmdable)(nil).ClusterCountKeysInSlot), ctx, slot)
	return &MockCmdableClusterCountKeysInSlotCall{Call: call}
}

// MockCmdableClusterCountKeysInSlotCall wrap *gomock.Call
type MockCmdableClusterCountKeysInSlotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterCountKeysInSlotCall) Return(arg0 *redis.IntCmd) *MockCmdableClusterCountKeysInSlotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterCountKeysInSlotCall) Do(f func(context.Context, int) *redis.IntCmd) *MockCmdableClusterCountKeysInSlotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterCountKeysInSlotCall) DoAndReturn(f func(context.Context, int) *redis.IntCmd) *MockCmdableClusterCountKeysInSlotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterDelSlots mocks base method.
func (m *MockCmdable) ClusterDelSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range slots {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ClusterDelSlots", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterDelSlots indicates an expected call of ClusterDelSlots.
func (mr *MockCmdableMockRecorder) ClusterDelSlots(ctx any, slots ...any) *MockCmdableClusterDelSlotsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, slots...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterDelSlots", reflect.TypeOf((*MockCmdable)(nil).ClusterDelSlots), varargs...)
	return &MockCmdableClusterDelSlotsCall{Call: call}
}

// MockCmdableClusterDelSlotsCall wrap *gomock.Call
type MockCmdableClusterDelSlotsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterDelSlotsCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterDelSlotsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterDelSlotsCall) Do(f func(context.Context, ...int) *redis.StatusCmd) *MockCmdableClusterDelSlotsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterDelSlotsCall) DoAndReturn(f func(context.Context, ...int) *redis.StatusCmd) *MockCmdableClusterDelSlotsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterDelSlotsRange mocks base method.
func (m *MockCmdable) ClusterDelSlotsRange(ctx context.Context, min, max int) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterDelSlotsRange", ctx, min, max)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterDelSlotsRange indicates an expected call of ClusterDelSlotsRange.
func (mr *MockCmdableMockRecorder) ClusterDelSlotsRange(ctx, min, max any) *MockCmdableClusterDelSlotsRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterDelSlotsRange", reflect.TypeOf((*MockCmdable)(nil).ClusterDelSlotsRange), ctx, min, max)
	return &MockCmdableClusterDelSlotsRangeCall{Call: call}
}

// MockCmdableClusterDelSlotsRangeCall wrap *gomock.Call
type MockCmdableClusterDelSlotsRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterDelSlotsRangeCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterDelSlotsRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterDelSlotsRangeCall) Do(f func(context.Context, int, int) *redis.StatusCmd) *MockCmdableClusterDelSlotsRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterDelSlotsRangeCall) DoAndReturn(f func(context.Context, int, int) *redis.StatusCmd) *MockCmdableClusterDelSlotsRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterFailover mocks base method.
func (m *MockCmdable) ClusterFailover(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterFailover", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterFailover indicates an expected call of ClusterFailover.
func (mr *MockCmdableMockRecorder) ClusterFailover(ctx any) *MockCmdableClusterFailoverCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterFailover", reflect.TypeOf((*MockCmdable)(nil).ClusterFailover), ctx)
	return &MockCmdableClusterFailoverCall{Call: call}
}

// MockCmdableClusterFailoverCall wrap *gomock.Call
type MockCmdableClusterFailoverCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterFailoverCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterFailoverCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterFailoverCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterFailoverCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterFailoverCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterFailoverCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterForget mocks base method.
func (m *MockCmdable) ClusterForget(ctx context.Context, nodeID string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterForget", ctx, nodeID)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterForget indicates an expected call of ClusterForget.
func (mr *MockCmdableMockRecorder) ClusterForget(ctx, nodeID any) *MockCmdableClusterForgetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterForget", reflect.TypeOf((*MockCmdable)(nil).ClusterForget), ctx, nodeID)
	return &MockCmdableClusterForgetCall{Call: call}
}

// MockCmdableClusterForgetCall wrap *gomock.Call
type MockCmdableClusterForgetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterForgetCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterForgetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterForgetCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableClusterForgetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterForgetCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableClusterForgetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterGetKeysInSlot mocks base method.
func (m *MockCmdable) ClusterGetKeysInSlot(ctx context.Context, slot, count int) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterGetKeysInSlot", ctx, slot, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ClusterGetKeysInSlot indicates an expected call of ClusterGetKeysInSlot.
func (mr *MockCmdableMockRecorder) ClusterGetKeysInSlot(ctx, slot, count any) *MockCmdableClusterGetKeysInSlotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterGetKeysInSlot", reflect.TypeOf((*MockCmdable)(nil).ClusterGetKeysInSlot), ctx, slot, count)
	return &MockCmdableClusterGetKeysInSlotCall{Call: call}
}

// MockCmdableClusterGetKeysInSlotCall wrap *gomock.Call
type MockCmdableClusterGetKeysInSlotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterGetKeysInSlotCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableClusterGetKeysInSlotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterGetKeysInSlotCall) Do(f func(context.Context, int, int) *redis.StringSliceCmd) *MockCmdableClusterGetKeysInSlotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterGetKeysInSlotCall) DoAndReturn(f func(context.Context, int, int) *redis.StringSliceCmd) *MockCmdableClusterGetKeysInSlotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterInfo mocks base method.
func (m *MockCmdable) ClusterInfo(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterInfo", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ClusterInfo indicates an expected call of ClusterInfo.
func (mr *MockCmdableMockRecorder) ClusterInfo(ctx any) *MockCmdableClusterInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterInfo", reflect.TypeOf((*MockCmdable)(nil).ClusterInfo), ctx)
	return &MockCmdableClusterInfoCall{Call: call}
}

// MockCmdableClusterInfoCall wrap *gomock.Call
type MockCmdableClusterInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterInfoCall) Return(arg0 *redis.StringCmd) *MockCmdableClusterInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterInfoCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableClusterInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterInfoCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableClusterInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterKeySlot mocks base method.
func (m *MockCmdable) ClusterKeySlot(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterKeySlot", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ClusterKeySlot indicates an expected call of ClusterKeySlot.
func (mr *MockCmdableMockRecorder) ClusterKeySlot(ctx, key any) *MockCmdableClusterKeySlotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterKeySlot", reflect.TypeOf((*MockCmdable)(nil).ClusterKeySlot), ctx, key)
	return &MockCmdableClusterKeySlotCall{Call: call}
}

// MockCmdableClusterKeySlotCall wrap *gomock.Call
type MockCmdableClusterKeySlotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterKeySlotCall) Return(arg0 *redis.IntCmd) *MockCmdableClusterKeySlotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterKeySlotCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableClusterKeySlotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterKeySlotCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableClusterKeySlotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterLinks mocks base method.
func (m *MockCmdable) ClusterLinks(ctx context.Context) *redis.ClusterLinksCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterLinks", ctx)
	ret0, _ := ret[0].(*redis.ClusterLinksCmd)
	return ret0
}

// ClusterLinks indicates an expected call of ClusterLinks.
func (mr *MockCmdableMockRecorder) ClusterLinks(ctx any) *MockCmdableClusterLinksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterLinks", reflect.TypeOf((*MockCmdable)(nil).ClusterLinks), ctx)
	return &MockCmdableClusterLinksCall{Call: call}
}

// MockCmdableClusterLinksCall wrap *gomock.Call
type MockCmdableClusterLinksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterLinksCall) Return(arg0 *redis.ClusterLinksCmd) *MockCmdableClusterLinksCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterLinksCall) Do(f func(context.Context) *redis.ClusterLinksCmd) *MockCmdableClusterLinksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterLinksCall) DoAndReturn(f func(context.Context) *redis.ClusterLinksCmd) *MockCmdableClusterLinksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterMeet mocks base method.
func (m *MockCmdable) ClusterMeet(ctx context.Context, host, port string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterMeet", ctx, host, port)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterMeet indicates an expected call of ClusterMeet.
func (mr *MockCmdableMockRecorder) ClusterMeet(ctx, host, port any) *MockCmdableClusterMeetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterMeet", reflect.TypeOf((*MockCmdable)(nil).ClusterMeet), ctx, host, port)
	return &MockCmdableClusterMeetCall{Call: call}
}

// MockCmdableClusterMeetCall wrap *gomock.Call
type MockCmdableClusterMeetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterMeetCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterMeetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterMeetCall) Do(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableClusterMeetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterMeetCall) DoAndReturn(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableClusterMeetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterMyID mocks base method.
func (m *MockCmdable) ClusterMyID(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterMyID", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ClusterMyID indicates an expected call of ClusterMyID.
func (mr *MockCmdableMockRecorder) ClusterMyID(ctx any) *MockCmdableClusterMyIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterMyID", reflect.TypeOf((*MockCmdable)(nil).ClusterMyID), ctx)
	return &MockCmdableClusterMyIDCall{Call: call}
}

// MockCmdableClusterMyIDCall wrap *gomock.Call
type MockCmdableClusterMyIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterMyIDCall) Return(arg0 *redis.StringCmd) *MockCmdableClusterMyIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterMyIDCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableClusterMyIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterMyIDCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableClusterMyIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterMyShardID mocks base method.
func (m *MockCmdable) ClusterMyShardID(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterMyShardID", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ClusterMyShardID indicates an expected call of ClusterMyShardID.
func (mr *MockCmdableMockRecorder) ClusterMyShardID(ctx any) *MockCmdableClusterMyShardIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterMyShardID", reflect.TypeOf((*MockCmdable)(nil).ClusterMyShardID), ctx)
	return &MockCmdableClusterMyShardIDCall{Call: call}
}

// MockCmdableClusterMyShardIDCall wrap *gomock.Call
type MockCmdableClusterMyShardIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterMyShardIDCall) Return(arg0 *redis.StringCmd) *MockCmdableClusterMyShardIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterMyShardIDCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableClusterMyShardIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterMyShardIDCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableClusterMyShardIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterNodes mocks base method.
func (m *MockCmdable) ClusterNodes(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterNodes", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ClusterNodes indicates an expected call of ClusterNodes.
func (mr *MockCmdableMockRecorder) ClusterNodes(ctx any) *MockCmdableClusterNodesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterNodes", reflect.TypeOf((*MockCmdable)(nil).ClusterNodes), ctx)
	return &MockCmdableClusterNodesCall{Call: call}
}

// MockCmdableClusterNodesCall wrap *gomock.Call
type MockCmdableClusterNodesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterNodesCall) Return(arg0 *redis.StringCmd) *MockCmdableClusterNodesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterNodesCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableClusterNodesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterNodesCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableClusterNodesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterReplicate mocks base method.
func (m *MockCmdable) ClusterReplicate(ctx context.Context, nodeID string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterReplicate", ctx, nodeID)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterReplicate indicates an expected call of ClusterReplicate.
func (mr *MockCmdableMockRecorder) ClusterReplicate(ctx, nodeID any) *MockCmdableClusterReplicateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterReplicate", reflect.TypeOf((*MockCmdable)(nil).ClusterReplicate), ctx, nodeID)
	return &MockCmdableClusterReplicateCall{Call: call}
}

// MockCmdableClusterReplicateCall wrap *gomock.Call
type MockCmdableClusterReplicateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterReplicateCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterReplicateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterReplicateCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableClusterReplicateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterReplicateCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableClusterReplicateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterResetHard mocks base method.
func (m *MockCmdable) ClusterResetHard(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterResetHard", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterResetHard indicates an expected call of ClusterResetHard.
func (mr *MockCmdableMockRecorder) ClusterResetHard(ctx any) *MockCmdableClusterResetHardCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterResetHard", reflect.TypeOf((*MockCmdable)(nil).ClusterResetHard), ctx)
	return &MockCmdableClusterResetHardCall{Call: call}
}

// MockCmdableClusterResetHardCall wrap *gomock.Call
type MockCmdableClusterResetHardCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterResetHardCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterResetHardCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterResetHardCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterResetHardCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterResetHardCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterResetHardCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterResetSoft mocks base method.
func (m *MockCmdable) ClusterResetSoft(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterResetSoft", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterResetSoft indicates an expected call of ClusterResetSoft.
func (mr *MockCmdableMockRecorder) ClusterResetSoft(ctx any) *MockCmdableClusterResetSoftCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterResetSoft", reflect.TypeOf((*MockCmdable)(nil).ClusterResetSoft), ctx)
	return &MockCmdableClusterResetSoftCall{Call: call}
}

// MockCmdableClusterResetSoftCall wrap *gomock.Call
type MockCmdableClusterResetSoftCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterResetSoftCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterResetSoftCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterResetSoftCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterResetSoftCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterResetSoftCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterResetSoftCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterSaveConfig mocks base method.
func (m *MockCmdable) ClusterSaveConfig(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterSaveConfig", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ClusterSaveConfig indicates an expected call of ClusterSaveConfig.
func (mr *MockCmdableMockRecorder) ClusterSaveConfig(ctx any) *MockCmdableClusterSaveConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterSaveConfig", reflect.TypeOf((*MockCmdable)(nil).ClusterSaveConfig), ctx)
	return &MockCmdableClusterSaveConfigCall{Call: call}
}

// MockCmdableClusterSaveConfigCall wrap *gomock.Call
type MockCmdableClusterSaveConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterSaveConfigCall) Return(arg0 *redis.StatusCmd) *MockCmdableClusterSaveConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterSaveConfigCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterSaveConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterSaveConfigCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableClusterSaveConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterShards mocks base method.
func (m *MockCmdable) ClusterShards(ctx context.Context) *redis.ClusterShardsCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterShards", ctx)
	ret0, _ := ret[0].(*redis.ClusterShardsCmd)
	return ret0
}

// ClusterShards indicates an expected call of ClusterShards.
func (mr *MockCmdableMockRecorder) ClusterShards(ctx any) *MockCmdableClusterShardsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterShards", reflect.TypeOf((*MockCmdable)(nil).ClusterShards), ctx)
	return &MockCmdableClusterShardsCall{Call: call}
}

// MockCmdableClusterShardsCall wrap *gomock.Call
type MockCmdableClusterShardsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterShardsCall) Return(arg0 *redis.ClusterShardsCmd) *MockCmdableClusterShardsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterShardsCall) Do(f func(context.Context) *redis.ClusterShardsCmd) *MockCmdableClusterShardsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterShardsCall) DoAndReturn(f func(context.Context) *redis.ClusterShardsCmd) *MockCmdableClusterShardsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterSlaves mocks base method.
func (m *MockCmdable) ClusterSlaves(ctx context.Context, nodeID string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterSlaves", ctx, nodeID)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ClusterSlaves indicates an expected call of ClusterSlaves.
func (mr *MockCmdableMockRecorder) ClusterSlaves(ctx, nodeID any) *MockCmdableClusterSlavesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterSlaves", reflect.TypeOf((*MockCmdable)(nil).ClusterSlaves), ctx, nodeID)
	return &MockCmdableClusterSlavesCall{Call: call}
}

// MockCmdableClusterSlavesCall wrap *gomock.Call
type MockCmdableClusterSlavesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterSlavesCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableClusterSlavesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterSlavesCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableClusterSlavesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterSlavesCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableClusterSlavesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClusterSlots mocks base method.
func (m *MockCmdable) ClusterSlots(ctx context.Context) *redis.ClusterSlotsCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClusterSlots", ctx)
	ret0, _ := ret[0].(*redis.ClusterSlotsCmd)
	return ret0
}

// ClusterSlots indicates an expected call of ClusterSlots.
func (mr *MockCmdableMockRecorder) ClusterSlots(ctx any) *MockCmdableClusterSlotsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClusterSlots", reflect.TypeOf((*MockCmdable)(nil).ClusterSlots), ctx)
	return &MockCmdableClusterSlotsCall{Call: call}
}

// MockCmdableClusterSlotsCall wrap *gomock.Call
type MockCmdableClusterSlotsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableClusterSlotsCall) Return(arg0 *redis.ClusterSlotsCmd) *MockCmdableClusterSlotsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableClusterSlotsCall) Do(f func(context.Context) *redis.ClusterSlotsCmd) *MockCmdableClusterSlotsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableClusterSlotsCall) DoAndReturn(f func(context.Context) *redis.ClusterSlotsCmd) *MockCmdableClusterSlotsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Command mocks base method.
func (m *MockCmdable) Command(ctx context.Context) *redis.CommandsInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Command", ctx)
	ret0, _ := ret[0].(*redis.CommandsInfoCmd)
	return ret0
}

// Command indicates an expected call of Command.
func (mr *MockCmdableMockRecorder) Command(ctx any) *MockCmdableCommandCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Command", reflect.TypeOf((*MockCmdable)(nil).Command), ctx)
	return &MockCmdableCommandCall{Call: call}
}

// MockCmdableCommandCall wrap *gomock.Call
type MockCmdableCommandCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCommandCall) Return(arg0 *redis.CommandsInfoCmd) *MockCmdableCommandCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCommandCall) Do(f func(context.Context) *redis.CommandsInfoCmd) *MockCmdableCommandCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCommandCall) DoAndReturn(f func(context.Context) *redis.CommandsInfoCmd) *MockCmdableCommandCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommandGetKeys mocks base method.
func (m *MockCmdable) CommandGetKeys(ctx context.Context, commands ...any) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range commands {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CommandGetKeys", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// CommandGetKeys indicates an expected call of CommandGetKeys.
func (mr *MockCmdableMockRecorder) CommandGetKeys(ctx any, commands ...any) *MockCmdableCommandGetKeysCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, commands...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommandGetKeys", reflect.TypeOf((*MockCmdable)(nil).CommandGetKeys), varargs...)
	return &MockCmdableCommandGetKeysCall{Call: call}
}

// MockCmdableCommandGetKeysCall wrap *gomock.Call
type MockCmdableCommandGetKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCommandGetKeysCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableCommandGetKeysCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCommandGetKeysCall) Do(f func(context.Context, ...any) *redis.StringSliceCmd) *MockCmdableCommandGetKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCommandGetKeysCall) DoAndReturn(f func(context.Context, ...any) *redis.StringSliceCmd) *MockCmdableCommandGetKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommandGetKeysAndFlags mocks base method.
func (m *MockCmdable) CommandGetKeysAndFlags(ctx context.Context, commands ...any) *redis.KeyFlagsCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range commands {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CommandGetKeysAndFlags", varargs...)
	ret0, _ := ret[0].(*redis.KeyFlagsCmd)
	return ret0
}

// CommandGetKeysAndFlags indicates an expected call of CommandGetKeysAndFlags.
func (mr *MockCmdableMockRecorder) CommandGetKeysAndFlags(ctx any, commands ...any) *MockCmdableCommandGetKeysAndFlagsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, commands...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommandGetKeysAndFlags", reflect.TypeOf((*MockCmdable)(nil).CommandGetKeysAndFlags), varargs...)
	return &MockCmdableCommandGetKeysAndFlagsCall{Call: call}
}

// MockCmdableCommandGetKeysAndFlagsCall wrap *gomock.Call
type MockCmdableCommandGetKeysAndFlagsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCommandGetKeysAndFlagsCall) Return(arg0 *redis.KeyFlagsCmd) *MockCmdableCommandGetKeysAndFlagsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCommandGetKeysAndFlagsCall) Do(f func(context.Context, ...any) *redis.KeyFlagsCmd) *MockCmdableCommandGetKeysAndFlagsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCommandGetKeysAndFlagsCall) DoAndReturn(f func(context.Context, ...any) *redis.KeyFlagsCmd) *MockCmdableCommandGetKeysAndFlagsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommandList mocks base method.
func (m *MockCmdable) CommandList(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommandList", ctx, filter)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// CommandList indicates an expected call of CommandList.
func (mr *MockCmdableMockRecorder) CommandList(ctx, filter any) *MockCmdableCommandListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommandList", reflect.TypeOf((*MockCmdable)(nil).CommandList), ctx, filter)
	return &MockCmdableCommandListCall{Call: call}
}

// MockCmdableCommandListCall wrap *gomock.Call
type MockCmdableCommandListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCommandListCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableCommandListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCommandListCall) Do(f func(context.Context, *redis.FilterBy) *redis.StringSliceCmd) *MockCmdableCommandListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCommandListCall) DoAndReturn(f func(context.Context, *redis.FilterBy) *redis.StringSliceCmd) *MockCmdableCommandListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConfigGet mocks base method.
func (m *MockCmdable) ConfigGet(ctx context.Context, parameter string) *redis.MapStringStringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConfigGet", ctx, parameter)
	ret0, _ := ret[0].(*redis.MapStringStringCmd)
	return ret0
}

// ConfigGet indicates an expected call of ConfigGet.
func (mr *MockCmdableMockRecorder) ConfigGet(ctx, parameter any) *MockCmdableConfigGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigGet", reflect.TypeOf((*MockCmdable)(nil).ConfigGet), ctx, parameter)
	return &MockCmdableConfigGetCall{Call: call}
}

// MockCmdableConfigGetCall wrap *gomock.Call
type MockCmdableConfigGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableConfigGetCall) Return(arg0 *redis.MapStringStringCmd) *MockCmdableConfigGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableConfigGetCall) Do(f func(context.Context, string) *redis.MapStringStringCmd) *MockCmdableConfigGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableConfigGetCall) DoAndReturn(f func(context.Context, string) *redis.MapStringStringCmd) *MockCmdableConfigGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConfigResetStat mocks base method.
func (m *MockCmdable) ConfigResetStat(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConfigResetStat", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ConfigResetStat indicates an expected call of ConfigResetStat.
func (mr *MockCmdableMockRecorder) ConfigResetStat(ctx any) *MockCmdableConfigResetStatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigResetStat", reflect.TypeOf((*MockCmdable)(nil).ConfigResetStat), ctx)
	return &MockCmdableConfigResetStatCall{Call: call}
}

// MockCmdableConfigResetStatCall wrap *gomock.Call
type MockCmdableConfigResetStatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableConfigResetStatCall) Return(arg0 *redis.StatusCmd) *MockCmdableConfigResetStatCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableConfigResetStatCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableConfigResetStatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableConfigResetStatCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableConfigResetStatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConfigRewrite mocks base method.
func (m *MockCmdable) ConfigRewrite(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConfigRewrite", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ConfigRewrite indicates an expected call of ConfigRewrite.
func (mr *MockCmdableMockRecorder) ConfigRewrite(ctx any) *MockCmdableConfigRewriteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigRewrite", reflect.TypeOf((*MockCmdable)(nil).ConfigRewrite), ctx)
	return &MockCmdableConfigRewriteCall{Call: call}
}

// MockCmdableConfigRewriteCall wrap *gomock.Call
type MockCmdableConfigRewriteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableConfigRewriteCall) Return(arg0 *redis.StatusCmd) *MockCmdableConfigRewriteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableConfigRewriteCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableConfigRewriteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableConfigRewriteCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableConfigRewriteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConfigSet mocks base method.
func (m *MockCmdable) ConfigSet(ctx context.Context, parameter, value string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConfigSet", ctx, parameter, value)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ConfigSet indicates an expected call of ConfigSet.
func (mr *MockCmdableMockRecorder) ConfigSet(ctx, parameter, value any) *MockCmdableConfigSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigSet", reflect.TypeOf((*MockCmdable)(nil).ConfigSet), ctx, parameter, value)
	return &MockCmdableConfigSetCall{Call: call}
}

// MockCmdableConfigSetCall wrap *gomock.Call
type MockCmdableConfigSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableConfigSetCall) Return(arg0 *redis.StatusCmd) *MockCmdableConfigSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableConfigSetCall) Do(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableConfigSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableConfigSetCall) DoAndReturn(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableConfigSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Copy mocks base method.
func (m *MockCmdable) Copy(ctx context.Context, sourceKey, destKey string, db int, replace bool) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", ctx, sourceKey, destKey, db, replace)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockCmdableMockRecorder) Copy(ctx, sourceKey, destKey, db, replace any) *MockCmdableCopyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockCmdable)(nil).Copy), ctx, sourceKey, destKey, db, replace)
	return &MockCmdableCopyCall{Call: call}
}

// MockCmdableCopyCall wrap *gomock.Call
type MockCmdableCopyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableCopyCall) Return(arg0 *redis.IntCmd) *MockCmdableCopyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableCopyCall) Do(f func(context.Context, string, string, int, bool) *redis.IntCmd) *MockCmdableCopyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableCopyCall) DoAndReturn(f func(context.Context, string, string, int, bool) *redis.IntCmd) *MockCmdableCopyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DBSize mocks base method.
func (m *MockCmdable) DBSize(ctx context.Context) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DBSize", ctx)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// DBSize indicates an expected call of DBSize.
func (mr *MockCmdableMockRecorder) DBSize(ctx any) *MockCmdableDBSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DBSize", reflect.TypeOf((*MockCmdable)(nil).DBSize), ctx)
	return &MockCmdableDBSizeCall{Call: call}
}

// MockCmdableDBSizeCall wrap *gomock.Call
type MockCmdableDBSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableDBSizeCall) Return(arg0 *redis.IntCmd) *MockCmdableDBSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableDBSizeCall) Do(f func(context.Context) *redis.IntCmd) *MockCmdableDBSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableDBSizeCall) DoAndReturn(f func(context.Context) *redis.IntCmd) *MockCmdableDBSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DebugObject mocks base method.
func (m *MockCmdable) DebugObject(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DebugObject", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// DebugObject indicates an expected call of DebugObject.
func (mr *MockCmdableMockRecorder) DebugObject(ctx, key any) *MockCmdableDebugObjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DebugObject", reflect.TypeOf((*MockCmdable)(nil).DebugObject), ctx, key)
	return &MockCmdableDebugObjectCall{Call: call}
}

// MockCmdableDebugObjectCall wrap *gomock.Call
type MockCmdableDebugObjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableDebugObjectCall) Return(arg0 *redis.StringCmd) *MockCmdableDebugObjectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableDebugObjectCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableDebugObjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableDebugObjectCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableDebugObjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Decr mocks base method.
func (m *MockCmdable) Decr(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Decr", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Decr indicates an expected call of Decr.
func (mr *MockCmdableMockRecorder) Decr(ctx, key any) *MockCmdableDecrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decr", reflect.TypeOf((*MockCmdable)(nil).Decr), ctx, key)
	return &MockCmdableDecrCall{Call: call}
}

// MockCmdableDecrCall wrap *gomock.Call
type MockCmdableDecrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableDecrCall) Return(arg0 *redis.IntCmd) *MockCmdableDecrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableDecrCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableDecrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableDecrCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableDecrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DecrBy mocks base method.
func (m *MockCmdable) DecrBy(ctx context.Context, key string, decrement int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DecrBy", ctx, key, decrement)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// DecrBy indicates an expected call of DecrBy.
func (mr *MockCmdableMockRecorder) DecrBy(ctx, key, decrement any) *MockCmdableDecrByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DecrBy", reflect.TypeOf((*MockCmdable)(nil).DecrBy), ctx, key, decrement)
	return &MockCmdableDecrByCall{Call: call}
}

// MockCmdableDecrByCall wrap *gomock.Call
type MockCmdableDecrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableDecrByCall) Return(arg0 *redis.IntCmd) *MockCmdableDecrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableDecrByCall) Do(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableDecrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableDecrByCall) DoAndReturn(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableDecrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Del mocks base method.
func (m *MockCmdable) Del(ctx context.Context, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Del", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Del indicates an expected call of Del.
func (mr *MockCmdableMockRecorder) Del(ctx any, keys ...any) *MockCmdableDelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockCmdable)(nil).Del), varargs...)
	return &MockCmdableDelCall{Call: call}
}

// MockCmdableDelCall wrap *gomock.Call
type MockCmdableDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableDelCall) Return(arg0 *redis.IntCmd) *MockCmdableDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableDelCall) Do(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableDelCall) DoAndReturn(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Dump mocks base method.
func (m *MockCmdable) Dump(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dump", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// Dump indicates an expected call of Dump.
func (mr *MockCmdableMockRecorder) Dump(ctx, key any) *MockCmdableDumpCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dump", reflect.TypeOf((*MockCmdable)(nil).Dump), ctx, key)
	return &MockCmdableDumpCall{Call: call}
}

// MockCmdableDumpCall wrap *gomock.Call
type MockCmdableDumpCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableDumpCall) Return(arg0 *redis.StringCmd) *MockCmdableDumpCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableDumpCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableDumpCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableDumpCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableDumpCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Echo mocks base method.
func (m *MockCmdable) Echo(ctx context.Context, message any) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Echo", ctx, message)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// Echo indicates an expected call of Echo.
func (mr *MockCmdableMockRecorder) Echo(ctx, message any) *MockCmdableEchoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Echo", reflect.TypeOf((*MockCmdable)(nil).Echo), ctx, message)
	return &MockCmdableEchoCall{Call: call}
}

// MockCmdableEchoCall wrap *gomock.Call
type MockCmdableEchoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableEchoCall) Return(arg0 *redis.StringCmd) *MockCmdableEchoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableEchoCall) Do(f func(context.Context, any) *redis.StringCmd) *MockCmdableEchoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableEchoCall) DoAndReturn(f func(context.Context, any) *redis.StringCmd) *MockCmdableEchoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Eval mocks base method.
func (m *MockCmdable) Eval(ctx context.Context, script string, keys []string, args ...any) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, script, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Eval", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// Eval indicates an expected call of Eval.
func (mr *MockCmdableMockRecorder) Eval(ctx, script, keys any, args ...any) *MockCmdableEvalCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, script, keys}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eval", reflect.TypeOf((*MockCmdable)(nil).Eval), varargs...)
	return &MockCmdableEvalCall{Call: call}
}

// MockCmdableEvalCall wrap *gomock.Call
type MockCmdableEvalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableEvalCall) Return(arg0 *redis.Cmd) *MockCmdableEvalCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableEvalCall) Do(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableEvalCall) DoAndReturn(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EvalRO mocks base method.
func (m *MockCmdable) EvalRO(ctx context.Context, script string, keys []string, args ...any) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, script, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EvalRO", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// EvalRO indicates an expected call of EvalRO.
func (mr *MockCmdableMockRecorder) EvalRO(ctx, script, keys any, args ...any) *MockCmdableEvalROCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, script, keys}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EvalRO", reflect.TypeOf((*MockCmdable)(nil).EvalRO), varargs...)
	return &MockCmdableEvalROCall{Call: call}
}

// MockCmdableEvalROCall wrap *gomock.Call
type MockCmdableEvalROCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableEvalROCall) Return(arg0 *redis.Cmd) *MockCmdableEvalROCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableEvalROCall) Do(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalROCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableEvalROCall) DoAndReturn(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalROCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EvalSha mocks base method.
func (m *MockCmdable) EvalSha(ctx context.Context, sha1 string, keys []string, args ...any) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sha1, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EvalSha", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// EvalSha indicates an expected call of EvalSha.
func (mr *MockCmdableMockRecorder) EvalSha(ctx, sha1, keys any, args ...any) *MockCmdableEvalShaCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sha1, keys}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EvalSha", reflect.TypeOf((*MockCmdable)(nil).EvalSha), varargs...)
	return &MockCmdableEvalShaCall{Call: call}
}

// MockCmdableEvalShaCall wrap *gomock.Call
type MockCmdableEvalShaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableEvalShaCall) Return(arg0 *redis.Cmd) *MockCmdableEvalShaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableEvalShaCall) Do(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalShaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableEvalShaCall) DoAndReturn(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalShaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EvalShaRO mocks base method.
func (m *MockCmdable) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...any) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sha1, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EvalShaRO", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// EvalShaRO indicates an expected call of EvalShaRO.
func (mr *MockCmdableMockRecorder) EvalShaRO(ctx, sha1, keys any, args ...any) *MockCmdableEvalShaROCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sha1, keys}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EvalShaRO", reflect.TypeOf((*MockCmdable)(nil).EvalShaRO), varargs...)
	return &MockCmdableEvalShaROCall{Call: call}
}

// MockCmdableEvalShaROCall wrap *gomock.Call
type MockCmdableEvalShaROCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableEvalShaROCall) Return(arg0 *redis.Cmd) *MockCmdableEvalShaROCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableEvalShaROCall) Do(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalShaROCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableEvalShaROCall) DoAndReturn(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableEvalShaROCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exists mocks base method.
func (m *MockCmdable) Exists(ctx context.Context, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exists", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockCmdableMockRecorder) Exists(ctx any, keys ...any) *MockCmdableExistsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockCmdable)(nil).Exists), varargs...)
	return &MockCmdableExistsCall{Call: call}
}

// MockCmdableExistsCall wrap *gomock.Call
type MockCmdableExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExistsCall) Return(arg0 *redis.IntCmd) *MockCmdableExistsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExistsCall) Do(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExistsCall) DoAndReturn(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Expire mocks base method.
func (m *MockCmdable) Expire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Expire", ctx, key, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// Expire indicates an expected call of Expire.
func (mr *MockCmdableMockRecorder) Expire(ctx, key, expiration any) *MockCmdableExpireCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Expire", reflect.TypeOf((*MockCmdable)(nil).Expire), ctx, key, expiration)
	return &MockCmdableExpireCall{Call: call}
}

// MockCmdableExpireCall wrap *gomock.Call
type MockCmdableExpireCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExpireCall) Return(arg0 *redis.BoolCmd) *MockCmdableExpireCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExpireCall) Do(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExpireCall) DoAndReturn(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExpireAt mocks base method.
func (m *MockCmdable) ExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpireAt", ctx, key, tm)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// ExpireAt indicates an expected call of ExpireAt.
func (mr *MockCmdableMockRecorder) ExpireAt(ctx, key, tm any) *MockCmdableExpireAtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpireAt", reflect.TypeOf((*MockCmdable)(nil).ExpireAt), ctx, key, tm)
	return &MockCmdableExpireAtCall{Call: call}
}

// MockCmdableExpireAtCall wrap *gomock.Call
type MockCmdableExpireAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExpireAtCall) Return(arg0 *redis.BoolCmd) *MockCmdableExpireAtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExpireAtCall) Do(f func(context.Context, string, time.Time) *redis.BoolCmd) *MockCmdableExpireAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExpireAtCall) DoAndReturn(f func(context.Context, string, time.Time) *redis.BoolCmd) *MockCmdableExpireAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExpireGT mocks base method.
func (m *MockCmdable) ExpireGT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpireGT", ctx, key, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// ExpireGT indicates an expected call of ExpireGT.
func (mr *MockCmdableMockRecorder) ExpireGT(ctx, key, expiration any) *MockCmdableExpireGTCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpireGT", reflect.TypeOf((*MockCmdable)(nil).ExpireGT), ctx, key, expiration)
	return &MockCmdableExpireGTCall{Call: call}
}

// MockCmdableExpireGTCall wrap *gomock.Call
type MockCmdableExpireGTCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExpireGTCall) Return(arg0 *redis.BoolCmd) *MockCmdableExpireGTCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExpireGTCall) Do(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireGTCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExpireGTCall) DoAndReturn(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireGTCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExpireLT mocks base method.
func (m *MockCmdable) ExpireLT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpireLT", ctx, key, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// ExpireLT indicates an expected call of ExpireLT.
func (mr *MockCmdableMockRecorder) ExpireLT(ctx, key, expiration any) *MockCmdableExpireLTCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpireLT", reflect.TypeOf((*MockCmdable)(nil).ExpireLT), ctx, key, expiration)
	return &MockCmdableExpireLTCall{Call: call}
}

// MockCmdableExpireLTCall wrap *gomock.Call
type MockCmdableExpireLTCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExpireLTCall) Return(arg0 *redis.BoolCmd) *MockCmdableExpireLTCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExpireLTCall) Do(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireLTCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExpireLTCall) DoAndReturn(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireLTCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExpireNX mocks base method.
func (m *MockCmdable) ExpireNX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpireNX", ctx, key, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// ExpireNX indicates an expected call of ExpireNX.
func (mr *MockCmdableMockRecorder) ExpireNX(ctx, key, expiration any) *MockCmdableExpireNXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpireNX", reflect.TypeOf((*MockCmdable)(nil).ExpireNX), ctx, key, expiration)
	return &MockCmdableExpireNXCall{Call: call}
}

// MockCmdableExpireNXCall wrap *gomock.Call
type MockCmdableExpireNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExpireNXCall) Return(arg0 *redis.BoolCmd) *MockCmdableExpireNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExpireNXCall) Do(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExpireNXCall) DoAndReturn(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExpireTime mocks base method.
func (m *MockCmdable) ExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpireTime", ctx, key)
	ret0, _ := ret[0].(*redis.DurationCmd)
	return ret0
}

// ExpireTime indicates an expected call of ExpireTime.
func (mr *MockCmdableMockRecorder) ExpireTime(ctx, key any) *MockCmdableExpireTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpireTime", reflect.TypeOf((*MockCmdable)(nil).ExpireTime), ctx, key)
	return &MockCmdableExpireTimeCall{Call: call}
}

// MockCmdableExpireTimeCall wrap *gomock.Call
type MockCmdableExpireTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExpireTimeCall) Return(arg0 *redis.DurationCmd) *MockCmdableExpireTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExpireTimeCall) Do(f func(context.Context, string) *redis.DurationCmd) *MockCmdableExpireTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExpireTimeCall) DoAndReturn(f func(context.Context, string) *redis.DurationCmd) *MockCmdableExpireTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExpireXX mocks base method.
func (m *MockCmdable) ExpireXX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExpireXX", ctx, key, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// ExpireXX indicates an expected call of ExpireXX.
func (mr *MockCmdableMockRecorder) ExpireXX(ctx, key, expiration any) *MockCmdableExpireXXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpireXX", reflect.TypeOf((*MockCmdable)(nil).ExpireXX), ctx, key, expiration)
	return &MockCmdableExpireXXCall{Call: call}
}

// MockCmdableExpireXXCall wrap *gomock.Call
type MockCmdableExpireXXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableExpireXXCall) Return(arg0 *redis.BoolCmd) *MockCmdableExpireXXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableExpireXXCall) Do(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireXXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableExpireXXCall) DoAndReturn(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdableExpireXXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FCall mocks base method.
func (m *MockCmdable) FCall(ctx context.Context, function string, keys []string, args ...any) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, function, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FCall", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// FCall indicates an expected call of FCall.
func (mr *MockCmdableMockRecorder) FCall(ctx, function, keys any, args ...any) *MockCmdableFCallCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, function, keys}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FCall", reflect.TypeOf((*MockCmdable)(nil).FCall), varargs...)
	return &MockCmdableFCallCall{Call: call}
}

// MockCmdableFCallCall wrap *gomock.Call
type MockCmdableFCallCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFCallCall) Return(arg0 *redis.Cmd) *MockCmdableFCallCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFCallCall) Do(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableFCallCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFCallCall) DoAndReturn(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableFCallCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FCallRO mocks base method.
func (m *MockCmdable) FCallRO(ctx context.Context, function string, keys []string, args ...any) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, function, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FCallRO", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// FCallRO indicates an expected call of FCallRO.
func (mr *MockCmdableMockRecorder) FCallRO(ctx, function, keys any, args ...any) *MockCmdableFCallROCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, function, keys}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FCallRO", reflect.TypeOf((*MockCmdable)(nil).FCallRO), varargs...)
	return &MockCmdableFCallROCall{Call: call}
}

// MockCmdableFCallROCall wrap *gomock.Call
type MockCmdableFCallROCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFCallROCall) Return(arg0 *redis.Cmd) *MockCmdableFCallROCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFCallROCall) Do(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableFCallROCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFCallROCall) DoAndReturn(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableFCallROCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FCallRo mocks base method.
func (m *MockCmdable) FCallRo(ctx context.Context, function string, keys []string, args ...any) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, function, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FCallRo", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// FCallRo indicates an expected call of FCallRo.
func (mr *MockCmdableMockRecorder) FCallRo(ctx, function, keys any, args ...any) *MockCmdableFCallRoCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, function, keys}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FCallRo", reflect.TypeOf((*MockCmdable)(nil).FCallRo), varargs...)
	return &MockCmdableFCallRoCall{Call: call}
}

// MockCmdableFCallRoCall wrap *gomock.Call
type MockCmdableFCallRoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFCallRoCall) Return(arg0 *redis.Cmd) *MockCmdableFCallRoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFCallRoCall) Do(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableFCallRoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFCallRoCall) DoAndReturn(f func(context.Context, string, []string, ...any) *redis.Cmd) *MockCmdableFCallRoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTAggregate mocks base method.
func (m *MockCmdable) FTAggregate(ctx context.Context, index, query string) *redis.MapStringInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTAggregate", ctx, index, query)
	ret0, _ := ret[0].(*redis.MapStringInterfaceCmd)
	return ret0
}

// FTAggregate indicates an expected call of FTAggregate.
func (mr *MockCmdableMockRecorder) FTAggregate(ctx, index, query any) *MockCmdableFTAggregateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTAggregate", reflect.TypeOf((*MockCmdable)(nil).FTAggregate), ctx, index, query)
	return &MockCmdableFTAggregateCall{Call: call}
}

// MockCmdableFTAggregateCall wrap *gomock.Call
type MockCmdableFTAggregateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTAggregateCall) Return(arg0 *redis.MapStringInterfaceCmd) *MockCmdableFTAggregateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTAggregateCall) Do(f func(context.Context, string, string) *redis.MapStringInterfaceCmd) *MockCmdableFTAggregateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTAggregateCall) DoAndReturn(f func(context.Context, string, string) *redis.MapStringInterfaceCmd) *MockCmdableFTAggregateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTAggregateWithArgs mocks base method.
func (m *MockCmdable) FTAggregateWithArgs(ctx context.Context, index, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTAggregateWithArgs", ctx, index, query, options)
	ret0, _ := ret[0].(*redis.AggregateCmd)
	return ret0
}

// FTAggregateWithArgs indicates an expected call of FTAggregateWithArgs.
func (mr *MockCmdableMockRecorder) FTAggregateWithArgs(ctx, index, query, options any) *MockCmdableFTAggregateWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTAggregateWithArgs", reflect.TypeOf((*MockCmdable)(nil).FTAggregateWithArgs), ctx, index, query, options)
	return &MockCmdableFTAggregateWithArgsCall{Call: call}
}

// MockCmdableFTAggregateWithArgsCall wrap *gomock.Call
type MockCmdableFTAggregateWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTAggregateWithArgsCall) Return(arg0 *redis.AggregateCmd) *MockCmdableFTAggregateWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTAggregateWithArgsCall) Do(f func(context.Context, string, string, *redis.FTAggregateOptions) *redis.AggregateCmd) *MockCmdableFTAggregateWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTAggregateWithArgsCall) DoAndReturn(f func(context.Context, string, string, *redis.FTAggregateOptions) *redis.AggregateCmd) *MockCmdableFTAggregateWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTAliasAdd mocks base method.
func (m *MockCmdable) FTAliasAdd(ctx context.Context, index, alias string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTAliasAdd", ctx, index, alias)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTAliasAdd indicates an expected call of FTAliasAdd.
func (mr *MockCmdableMockRecorder) FTAliasAdd(ctx, index, alias any) *MockCmdableFTAliasAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTAliasAdd", reflect.TypeOf((*MockCmdable)(nil).FTAliasAdd), ctx, index, alias)
	return &MockCmdableFTAliasAddCall{Call: call}
}

// MockCmdableFTAliasAddCall wrap *gomock.Call
type MockCmdableFTAliasAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTAliasAddCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTAliasAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTAliasAddCall) Do(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableFTAliasAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTAliasAddCall) DoAndReturn(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableFTAliasAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTAliasDel mocks base method.
func (m *MockCmdable) FTAliasDel(ctx context.Context, alias string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTAliasDel", ctx, alias)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTAliasDel indicates an expected call of FTAliasDel.
func (mr *MockCmdableMockRecorder) FTAliasDel(ctx, alias any) *MockCmdableFTAliasDelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTAliasDel", reflect.TypeOf((*MockCmdable)(nil).FTAliasDel), ctx, alias)
	return &MockCmdableFTAliasDelCall{Call: call}
}

// MockCmdableFTAliasDelCall wrap *gomock.Call
type MockCmdableFTAliasDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTAliasDelCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTAliasDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTAliasDelCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableFTAliasDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTAliasDelCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableFTAliasDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTAliasUpdate mocks base method.
func (m *MockCmdable) FTAliasUpdate(ctx context.Context, index, alias string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTAliasUpdate", ctx, index, alias)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTAliasUpdate indicates an expected call of FTAliasUpdate.
func (mr *MockCmdableMockRecorder) FTAliasUpdate(ctx, index, alias any) *MockCmdableFTAliasUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTAliasUpdate", reflect.TypeOf((*MockCmdable)(nil).FTAliasUpdate), ctx, index, alias)
	return &MockCmdableFTAliasUpdateCall{Call: call}
}

// MockCmdableFTAliasUpdateCall wrap *gomock.Call
type MockCmdableFTAliasUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTAliasUpdateCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTAliasUpdateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTAliasUpdateCall) Do(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableFTAliasUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTAliasUpdateCall) DoAndReturn(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableFTAliasUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTAlter mocks base method.
func (m *MockCmdable) FTAlter(ctx context.Context, index string, skipInitialScan bool, definition []any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTAlter", ctx, index, skipInitialScan, definition)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTAlter indicates an expected call of FTAlter.
func (mr *MockCmdableMockRecorder) FTAlter(ctx, index, skipInitialScan, definition any) *MockCmdableFTAlterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTAlter", reflect.TypeOf((*MockCmdable)(nil).FTAlter), ctx, index, skipInitialScan, definition)
	return &MockCmdableFTAlterCall{Call: call}
}

// MockCmdableFTAlterCall wrap *gomock.Call
type MockCmdableFTAlterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTAlterCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTAlterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTAlterCall) Do(f func(context.Context, string, bool, []any) *redis.StatusCmd) *MockCmdableFTAlterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTAlterCall) DoAndReturn(f func(context.Context, string, bool, []any) *redis.StatusCmd) *MockCmdableFTAlterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTConfigGet mocks base method.
func (m *MockCmdable) FTConfigGet(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTConfigGet", ctx, option)
	ret0, _ := ret[0].(*redis.MapMapStringInterfaceCmd)
	return ret0
}

// FTConfigGet indicates an expected call of FTConfigGet.
func (mr *MockCmdableMockRecorder) FTConfigGet(ctx, option any) *MockCmdableFTConfigGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTConfigGet", reflect.TypeOf((*MockCmdable)(nil).FTConfigGet), ctx, option)
	return &MockCmdableFTConfigGetCall{Call: call}
}

// MockCmdableFTConfigGetCall wrap *gomock.Call
type MockCmdableFTConfigGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTConfigGetCall) Return(arg0 *redis.MapMapStringInterfaceCmd) *MockCmdableFTConfigGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTConfigGetCall) Do(f func(context.Context, string) *redis.MapMapStringInterfaceCmd) *MockCmdableFTConfigGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTConfigGetCall) DoAndReturn(f func(context.Context, string) *redis.MapMapStringInterfaceCmd) *MockCmdableFTConfigGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTConfigSet mocks base method.
func (m *MockCmdable) FTConfigSet(ctx context.Context, option string, value any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTConfigSet", ctx, option, value)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTConfigSet indicates an expected call of FTConfigSet.
func (mr *MockCmdableMockRecorder) FTConfigSet(ctx, option, value any) *MockCmdableFTConfigSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTConfigSet", reflect.TypeOf((*MockCmdable)(nil).FTConfigSet), ctx, option, value)
	return &MockCmdableFTConfigSetCall{Call: call}
}

// MockCmdableFTConfigSetCall wrap *gomock.Call
type MockCmdableFTConfigSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTConfigSetCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTConfigSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTConfigSetCall) Do(f func(context.Context, string, any) *redis.StatusCmd) *MockCmdableFTConfigSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTConfigSetCall) DoAndReturn(f func(context.Context, string, any) *redis.StatusCmd) *MockCmdableFTConfigSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTCreate mocks base method.
func (m *MockCmdable) FTCreate(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, index, options}
	for _, a := range schema {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FTCreate", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTCreate indicates an expected call of FTCreate.
func (mr *MockCmdableMockRecorder) FTCreate(ctx, index, options any, schema ...any) *MockCmdableFTCreateCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, index, options}, schema...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTCreate", reflect.TypeOf((*MockCmdable)(nil).FTCreate), varargs...)
	return &MockCmdableFTCreateCall{Call: call}
}

// MockCmdableFTCreateCall wrap *gomock.Call
type MockCmdableFTCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTCreateCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTCreateCall) Do(f func(context.Context, string, *redis.FTCreateOptions, ...*redis.FieldSchema) *redis.StatusCmd) *MockCmdableFTCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTCreateCall) DoAndReturn(f func(context.Context, string, *redis.FTCreateOptions, ...*redis.FieldSchema) *redis.StatusCmd) *MockCmdableFTCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTCursorDel mocks base method.
func (m *MockCmdable) FTCursorDel(ctx context.Context, index string, cursorId int) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTCursorDel", ctx, index, cursorId)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTCursorDel indicates an expected call of FTCursorDel.
func (mr *MockCmdableMockRecorder) FTCursorDel(ctx, index, cursorId any) *MockCmdableFTCursorDelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTCursorDel", reflect.TypeOf((*MockCmdable)(nil).FTCursorDel), ctx, index, cursorId)
	return &MockCmdableFTCursorDelCall{Call: call}
}

// MockCmdableFTCursorDelCall wrap *gomock.Call
type MockCmdableFTCursorDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTCursorDelCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTCursorDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTCursorDelCall) Do(f func(context.Context, string, int) *redis.StatusCmd) *MockCmdableFTCursorDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTCursorDelCall) DoAndReturn(f func(context.Context, string, int) *redis.StatusCmd) *MockCmdableFTCursorDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTCursorRead mocks base method.
func (m *MockCmdable) FTCursorRead(ctx context.Context, index string, cursorId, count int) *redis.MapStringInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTCursorRead", ctx, index, cursorId, count)
	ret0, _ := ret[0].(*redis.MapStringInterfaceCmd)
	return ret0
}

// FTCursorRead indicates an expected call of FTCursorRead.
func (mr *MockCmdableMockRecorder) FTCursorRead(ctx, index, cursorId, count any) *MockCmdableFTCursorReadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTCursorRead", reflect.TypeOf((*MockCmdable)(nil).FTCursorRead), ctx, index, cursorId, count)
	return &MockCmdableFTCursorReadCall{Call: call}
}

// MockCmdableFTCursorReadCall wrap *gomock.Call
type MockCmdableFTCursorReadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTCursorReadCall) Return(arg0 *redis.MapStringInterfaceCmd) *MockCmdableFTCursorReadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTCursorReadCall) Do(f func(context.Context, string, int, int) *redis.MapStringInterfaceCmd) *MockCmdableFTCursorReadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTCursorReadCall) DoAndReturn(f func(context.Context, string, int, int) *redis.MapStringInterfaceCmd) *MockCmdableFTCursorReadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTDictAdd mocks base method.
func (m *MockCmdable) FTDictAdd(ctx context.Context, dict string, term ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dict}
	for _, a := range term {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FTDictAdd", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// FTDictAdd indicates an expected call of FTDictAdd.
func (mr *MockCmdableMockRecorder) FTDictAdd(ctx, dict any, term ...any) *MockCmdableFTDictAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dict}, term...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTDictAdd", reflect.TypeOf((*MockCmdable)(nil).FTDictAdd), varargs...)
	return &MockCmdableFTDictAddCall{Call: call}
}

// MockCmdableFTDictAddCall wrap *gomock.Call
type MockCmdableFTDictAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTDictAddCall) Return(arg0 *redis.IntCmd) *MockCmdableFTDictAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTDictAddCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableFTDictAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTDictAddCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableFTDictAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTDictDel mocks base method.
func (m *MockCmdable) FTDictDel(ctx context.Context, dict string, term ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dict}
	for _, a := range term {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FTDictDel", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// FTDictDel indicates an expected call of FTDictDel.
func (mr *MockCmdableMockRecorder) FTDictDel(ctx, dict any, term ...any) *MockCmdableFTDictDelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dict}, term...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTDictDel", reflect.TypeOf((*MockCmdable)(nil).FTDictDel), varargs...)
	return &MockCmdableFTDictDelCall{Call: call}
}

// MockCmdableFTDictDelCall wrap *gomock.Call
type MockCmdableFTDictDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTDictDelCall) Return(arg0 *redis.IntCmd) *MockCmdableFTDictDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTDictDelCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableFTDictDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTDictDelCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableFTDictDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTDictDump mocks base method.
func (m *MockCmdable) FTDictDump(ctx context.Context, dict string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTDictDump", ctx, dict)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// FTDictDump indicates an expected call of FTDictDump.
func (mr *MockCmdableMockRecorder) FTDictDump(ctx, dict any) *MockCmdableFTDictDumpCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTDictDump", reflect.TypeOf((*MockCmdable)(nil).FTDictDump), ctx, dict)
	return &MockCmdableFTDictDumpCall{Call: call}
}

// MockCmdableFTDictDumpCall wrap *gomock.Call
type MockCmdableFTDictDumpCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTDictDumpCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableFTDictDumpCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTDictDumpCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableFTDictDumpCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTDictDumpCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableFTDictDumpCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTDropIndex mocks base method.
func (m *MockCmdable) FTDropIndex(ctx context.Context, index string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTDropIndex", ctx, index)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTDropIndex indicates an expected call of FTDropIndex.
func (mr *MockCmdableMockRecorder) FTDropIndex(ctx, index any) *MockCmdableFTDropIndexCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTDropIndex", reflect.TypeOf((*MockCmdable)(nil).FTDropIndex), ctx, index)
	return &MockCmdableFTDropIndexCall{Call: call}
}

// MockCmdableFTDropIndexCall wrap *gomock.Call
type MockCmdableFTDropIndexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTDropIndexCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTDropIndexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTDropIndexCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableFTDropIndexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTDropIndexCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableFTDropIndexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTDropIndexWithArgs mocks base method.
func (m *MockCmdable) FTDropIndexWithArgs(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTDropIndexWithArgs", ctx, index, options)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTDropIndexWithArgs indicates an expected call of FTDropIndexWithArgs.
func (mr *MockCmdableMockRecorder) FTDropIndexWithArgs(ctx, index, options any) *MockCmdableFTDropIndexWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTDropIndexWithArgs", reflect.TypeOf((*MockCmdable)(nil).FTDropIndexWithArgs), ctx, index, options)
	return &MockCmdableFTDropIndexWithArgsCall{Call: call}
}

// MockCmdableFTDropIndexWithArgsCall wrap *gomock.Call
type MockCmdableFTDropIndexWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTDropIndexWithArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTDropIndexWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTDropIndexWithArgsCall) Do(f func(context.Context, string, *redis.FTDropIndexOptions) *redis.StatusCmd) *MockCmdableFTDropIndexWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTDropIndexWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.FTDropIndexOptions) *redis.StatusCmd) *MockCmdableFTDropIndexWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTExplain mocks base method.
func (m *MockCmdable) FTExplain(ctx context.Context, index, query string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTExplain", ctx, index, query)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FTExplain indicates an expected call of FTExplain.
func (mr *MockCmdableMockRecorder) FTExplain(ctx, index, query any) *MockCmdableFTExplainCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTExplain", reflect.TypeOf((*MockCmdable)(nil).FTExplain), ctx, index, query)
	return &MockCmdableFTExplainCall{Call: call}
}

// MockCmdableFTExplainCall wrap *gomock.Call
type MockCmdableFTExplainCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTExplainCall) Return(arg0 *redis.StringCmd) *MockCmdableFTExplainCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTExplainCall) Do(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableFTExplainCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTExplainCall) DoAndReturn(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableFTExplainCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTExplainWithArgs mocks base method.
func (m *MockCmdable) FTExplainWithArgs(ctx context.Context, index, query string, options *redis.FTExplainOptions) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTExplainWithArgs", ctx, index, query, options)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FTExplainWithArgs indicates an expected call of FTExplainWithArgs.
func (mr *MockCmdableMockRecorder) FTExplainWithArgs(ctx, index, query, options any) *MockCmdableFTExplainWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTExplainWithArgs", reflect.TypeOf((*MockCmdable)(nil).FTExplainWithArgs), ctx, index, query, options)
	return &MockCmdableFTExplainWithArgsCall{Call: call}
}

// MockCmdableFTExplainWithArgsCall wrap *gomock.Call
type MockCmdableFTExplainWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTExplainWithArgsCall) Return(arg0 *redis.StringCmd) *MockCmdableFTExplainWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTExplainWithArgsCall) Do(f func(context.Context, string, string, *redis.FTExplainOptions) *redis.StringCmd) *MockCmdableFTExplainWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTExplainWithArgsCall) DoAndReturn(f func(context.Context, string, string, *redis.FTExplainOptions) *redis.StringCmd) *MockCmdableFTExplainWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTInfo mocks base method.
func (m *MockCmdable) FTInfo(ctx context.Context, index string) *redis.FTInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTInfo", ctx, index)
	ret0, _ := ret[0].(*redis.FTInfoCmd)
	return ret0
}

// FTInfo indicates an expected call of FTInfo.
func (mr *MockCmdableMockRecorder) FTInfo(ctx, index any) *MockCmdableFTInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTInfo", reflect.TypeOf((*MockCmdable)(nil).FTInfo), ctx, index)
	return &MockCmdableFTInfoCall{Call: call}
}

// MockCmdableFTInfoCall wrap *gomock.Call
type MockCmdableFTInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTInfoCall) Return(arg0 *redis.FTInfoCmd) *MockCmdableFTInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTInfoCall) Do(f func(context.Context, string) *redis.FTInfoCmd) *MockCmdableFTInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTInfoCall) DoAndReturn(f func(context.Context, string) *redis.FTInfoCmd) *MockCmdableFTInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTSearch mocks base method.
func (m *MockCmdable) FTSearch(ctx context.Context, index, query string) *redis.FTSearchCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTSearch", ctx, index, query)
	ret0, _ := ret[0].(*redis.FTSearchCmd)
	return ret0
}

// FTSearch indicates an expected call of FTSearch.
func (mr *MockCmdableMockRecorder) FTSearch(ctx, index, query any) *MockCmdableFTSearchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTSearch", reflect.TypeOf((*MockCmdable)(nil).FTSearch), ctx, index, query)
	return &MockCmdableFTSearchCall{Call: call}
}

// MockCmdableFTSearchCall wrap *gomock.Call
type MockCmdableFTSearchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTSearchCall) Return(arg0 *redis.FTSearchCmd) *MockCmdableFTSearchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTSearchCall) Do(f func(context.Context, string, string) *redis.FTSearchCmd) *MockCmdableFTSearchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTSearchCall) DoAndReturn(f func(context.Context, string, string) *redis.FTSearchCmd) *MockCmdableFTSearchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTSearchWithArgs mocks base method.
func (m *MockCmdable) FTSearchWithArgs(ctx context.Context, index, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTSearchWithArgs", ctx, index, query, options)
	ret0, _ := ret[0].(*redis.FTSearchCmd)
	return ret0
}

// FTSearchWithArgs indicates an expected call of FTSearchWithArgs.
func (mr *MockCmdableMockRecorder) FTSearchWithArgs(ctx, index, query, options any) *MockCmdableFTSearchWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTSearchWithArgs", reflect.TypeOf((*MockCmdable)(nil).FTSearchWithArgs), ctx, index, query, options)
	return &MockCmdableFTSearchWithArgsCall{Call: call}
}

// MockCmdableFTSearchWithArgsCall wrap *gomock.Call
type MockCmdableFTSearchWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTSearchWithArgsCall) Return(arg0 *redis.FTSearchCmd) *MockCmdableFTSearchWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTSearchWithArgsCall) Do(f func(context.Context, string, string, *redis.FTSearchOptions) *redis.FTSearchCmd) *MockCmdableFTSearchWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTSearchWithArgsCall) DoAndReturn(f func(context.Context, string, string, *redis.FTSearchOptions) *redis.FTSearchCmd) *MockCmdableFTSearchWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTSpellCheck mocks base method.
func (m *MockCmdable) FTSpellCheck(ctx context.Context, index, query string) *redis.FTSpellCheckCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTSpellCheck", ctx, index, query)
	ret0, _ := ret[0].(*redis.FTSpellCheckCmd)
	return ret0
}

// FTSpellCheck indicates an expected call of FTSpellCheck.
func (mr *MockCmdableMockRecorder) FTSpellCheck(ctx, index, query any) *MockCmdableFTSpellCheckCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTSpellCheck", reflect.TypeOf((*MockCmdable)(nil).FTSpellCheck), ctx, index, query)
	return &MockCmdableFTSpellCheckCall{Call: call}
}

// MockCmdableFTSpellCheckCall wrap *gomock.Call
type MockCmdableFTSpellCheckCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTSpellCheckCall) Return(arg0 *redis.FTSpellCheckCmd) *MockCmdableFTSpellCheckCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTSpellCheckCall) Do(f func(context.Context, string, string) *redis.FTSpellCheckCmd) *MockCmdableFTSpellCheckCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTSpellCheckCall) DoAndReturn(f func(context.Context, string, string) *redis.FTSpellCheckCmd) *MockCmdableFTSpellCheckCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTSpellCheckWithArgs mocks base method.
func (m *MockCmdable) FTSpellCheckWithArgs(ctx context.Context, index, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTSpellCheckWithArgs", ctx, index, query, options)
	ret0, _ := ret[0].(*redis.FTSpellCheckCmd)
	return ret0
}

// FTSpellCheckWithArgs indicates an expected call of FTSpellCheckWithArgs.
func (mr *MockCmdableMockRecorder) FTSpellCheckWithArgs(ctx, index, query, options any) *MockCmdableFTSpellCheckWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTSpellCheckWithArgs", reflect.TypeOf((*MockCmdable)(nil).FTSpellCheckWithArgs), ctx, index, query, options)
	return &MockCmdableFTSpellCheckWithArgsCall{Call: call}
}

// MockCmdableFTSpellCheckWithArgsCall wrap *gomock.Call
type MockCmdableFTSpellCheckWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTSpellCheckWithArgsCall) Return(arg0 *redis.FTSpellCheckCmd) *MockCmdableFTSpellCheckWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTSpellCheckWithArgsCall) Do(f func(context.Context, string, string, *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd) *MockCmdableFTSpellCheckWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTSpellCheckWithArgsCall) DoAndReturn(f func(context.Context, string, string, *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd) *MockCmdableFTSpellCheckWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTSynDump mocks base method.
func (m *MockCmdable) FTSynDump(ctx context.Context, index string) *redis.FTSynDumpCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTSynDump", ctx, index)
	ret0, _ := ret[0].(*redis.FTSynDumpCmd)
	return ret0
}

// FTSynDump indicates an expected call of FTSynDump.
func (mr *MockCmdableMockRecorder) FTSynDump(ctx, index any) *MockCmdableFTSynDumpCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTSynDump", reflect.TypeOf((*MockCmdable)(nil).FTSynDump), ctx, index)
	return &MockCmdableFTSynDumpCall{Call: call}
}

// MockCmdableFTSynDumpCall wrap *gomock.Call
type MockCmdableFTSynDumpCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTSynDumpCall) Return(arg0 *redis.FTSynDumpCmd) *MockCmdableFTSynDumpCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTSynDumpCall) Do(f func(context.Context, string) *redis.FTSynDumpCmd) *MockCmdableFTSynDumpCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTSynDumpCall) DoAndReturn(f func(context.Context, string) *redis.FTSynDumpCmd) *MockCmdableFTSynDumpCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTSynUpdate mocks base method.
func (m *MockCmdable) FTSynUpdate(ctx context.Context, index string, synGroupId any, terms []any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTSynUpdate", ctx, index, synGroupId, terms)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTSynUpdate indicates an expected call of FTSynUpdate.
func (mr *MockCmdableMockRecorder) FTSynUpdate(ctx, index, synGroupId, terms any) *MockCmdableFTSynUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTSynUpdate", reflect.TypeOf((*MockCmdable)(nil).FTSynUpdate), ctx, index, synGroupId, terms)
	return &MockCmdableFTSynUpdateCall{Call: call}
}

// MockCmdableFTSynUpdateCall wrap *gomock.Call
type MockCmdableFTSynUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTSynUpdateCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTSynUpdateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTSynUpdateCall) Do(f func(context.Context, string, any, []any) *redis.StatusCmd) *MockCmdableFTSynUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTSynUpdateCall) DoAndReturn(f func(context.Context, string, any, []any) *redis.StatusCmd) *MockCmdableFTSynUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTSynUpdateWithArgs mocks base method.
func (m *MockCmdable) FTSynUpdateWithArgs(ctx context.Context, index string, synGroupId any, options *redis.FTSynUpdateOptions, terms []any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTSynUpdateWithArgs", ctx, index, synGroupId, options, terms)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FTSynUpdateWithArgs indicates an expected call of FTSynUpdateWithArgs.
func (mr *MockCmdableMockRecorder) FTSynUpdateWithArgs(ctx, index, synGroupId, options, terms any) *MockCmdableFTSynUpdateWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTSynUpdateWithArgs", reflect.TypeOf((*MockCmdable)(nil).FTSynUpdateWithArgs), ctx, index, synGroupId, options, terms)
	return &MockCmdableFTSynUpdateWithArgsCall{Call: call}
}

// MockCmdableFTSynUpdateWithArgsCall wrap *gomock.Call
type MockCmdableFTSynUpdateWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTSynUpdateWithArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableFTSynUpdateWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTSynUpdateWithArgsCall) Do(f func(context.Context, string, any, *redis.FTSynUpdateOptions, []any) *redis.StatusCmd) *MockCmdableFTSynUpdateWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTSynUpdateWithArgsCall) DoAndReturn(f func(context.Context, string, any, *redis.FTSynUpdateOptions, []any) *redis.StatusCmd) *MockCmdableFTSynUpdateWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FTTagVals mocks base method.
func (m *MockCmdable) FTTagVals(ctx context.Context, index, field string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FTTagVals", ctx, index, field)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// FTTagVals indicates an expected call of FTTagVals.
func (mr *MockCmdableMockRecorder) FTTagVals(ctx, index, field any) *MockCmdableFTTagValsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FTTagVals", reflect.TypeOf((*MockCmdable)(nil).FTTagVals), ctx, index, field)
	return &MockCmdableFTTagValsCall{Call: call}
}

// MockCmdableFTTagValsCall wrap *gomock.Call
type MockCmdableFTTagValsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFTTagValsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableFTTagValsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFTTagValsCall) Do(f func(context.Context, string, string) *redis.StringSliceCmd) *MockCmdableFTTagValsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFTTagValsCall) DoAndReturn(f func(context.Context, string, string) *redis.StringSliceCmd) *MockCmdableFTTagValsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FT_List mocks base method.
func (m *MockCmdable) FT_List(ctx context.Context) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FT_List", ctx)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// FT_List indicates an expected call of FT_List.
func (mr *MockCmdableMockRecorder) FT_List(ctx any) *MockCmdableFT_ListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FT_List", reflect.TypeOf((*MockCmdable)(nil).FT_List), ctx)
	return &MockCmdableFT_ListCall{Call: call}
}

// MockCmdableFT_ListCall wrap *gomock.Call
type MockCmdableFT_ListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFT_ListCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableFT_ListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFT_ListCall) Do(f func(context.Context) *redis.StringSliceCmd) *MockCmdableFT_ListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFT_ListCall) DoAndReturn(f func(context.Context) *redis.StringSliceCmd) *MockCmdableFT_ListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FlushAll mocks base method.
func (m *MockCmdable) FlushAll(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushAll", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FlushAll indicates an expected call of FlushAll.
func (mr *MockCmdableMockRecorder) FlushAll(ctx any) *MockCmdableFlushAllCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushAll", reflect.TypeOf((*MockCmdable)(nil).FlushAll), ctx)
	return &MockCmdableFlushAllCall{Call: call}
}

// MockCmdableFlushAllCall wrap *gomock.Call
type MockCmdableFlushAllCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFlushAllCall) Return(arg0 *redis.StatusCmd) *MockCmdableFlushAllCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFlushAllCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushAllCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFlushAllCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushAllCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FlushAllAsync mocks base method.
func (m *MockCmdable) FlushAllAsync(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushAllAsync", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FlushAllAsync indicates an expected call of FlushAllAsync.
func (mr *MockCmdableMockRecorder) FlushAllAsync(ctx any) *MockCmdableFlushAllAsyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushAllAsync", reflect.TypeOf((*MockCmdable)(nil).FlushAllAsync), ctx)
	return &MockCmdableFlushAllAsyncCall{Call: call}
}

// MockCmdableFlushAllAsyncCall wrap *gomock.Call
type MockCmdableFlushAllAsyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFlushAllAsyncCall) Return(arg0 *redis.StatusCmd) *MockCmdableFlushAllAsyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFlushAllAsyncCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushAllAsyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFlushAllAsyncCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushAllAsyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FlushDB mocks base method.
func (m *MockCmdable) FlushDB(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushDB", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FlushDB indicates an expected call of FlushDB.
func (mr *MockCmdableMockRecorder) FlushDB(ctx any) *MockCmdableFlushDBCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushDB", reflect.TypeOf((*MockCmdable)(nil).FlushDB), ctx)
	return &MockCmdableFlushDBCall{Call: call}
}

// MockCmdableFlushDBCall wrap *gomock.Call
type MockCmdableFlushDBCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFlushDBCall) Return(arg0 *redis.StatusCmd) *MockCmdableFlushDBCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFlushDBCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushDBCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFlushDBCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushDBCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FlushDBAsync mocks base method.
func (m *MockCmdable) FlushDBAsync(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushDBAsync", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// FlushDBAsync indicates an expected call of FlushDBAsync.
func (mr *MockCmdableMockRecorder) FlushDBAsync(ctx any) *MockCmdableFlushDBAsyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushDBAsync", reflect.TypeOf((*MockCmdable)(nil).FlushDBAsync), ctx)
	return &MockCmdableFlushDBAsyncCall{Call: call}
}

// MockCmdableFlushDBAsyncCall wrap *gomock.Call
type MockCmdableFlushDBAsyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFlushDBAsyncCall) Return(arg0 *redis.StatusCmd) *MockCmdableFlushDBAsyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFlushDBAsyncCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushDBAsyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFlushDBAsyncCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableFlushDBAsyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionDelete mocks base method.
func (m *MockCmdable) FunctionDelete(ctx context.Context, libName string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionDelete", ctx, libName)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionDelete indicates an expected call of FunctionDelete.
func (mr *MockCmdableMockRecorder) FunctionDelete(ctx, libName any) *MockCmdableFunctionDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionDelete", reflect.TypeOf((*MockCmdable)(nil).FunctionDelete), ctx, libName)
	return &MockCmdableFunctionDeleteCall{Call: call}
}

// MockCmdableFunctionDeleteCall wrap *gomock.Call
type MockCmdableFunctionDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionDeleteCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionDeleteCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionDeleteCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionDump mocks base method.
func (m *MockCmdable) FunctionDump(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionDump", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionDump indicates an expected call of FunctionDump.
func (mr *MockCmdableMockRecorder) FunctionDump(ctx any) *MockCmdableFunctionDumpCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionDump", reflect.TypeOf((*MockCmdable)(nil).FunctionDump), ctx)
	return &MockCmdableFunctionDumpCall{Call: call}
}

// MockCmdableFunctionDumpCall wrap *gomock.Call
type MockCmdableFunctionDumpCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionDumpCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionDumpCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionDumpCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionDumpCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionDumpCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionDumpCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionFlush mocks base method.
func (m *MockCmdable) FunctionFlush(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionFlush", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionFlush indicates an expected call of FunctionFlush.
func (mr *MockCmdableMockRecorder) FunctionFlush(ctx any) *MockCmdableFunctionFlushCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionFlush", reflect.TypeOf((*MockCmdable)(nil).FunctionFlush), ctx)
	return &MockCmdableFunctionFlushCall{Call: call}
}

// MockCmdableFunctionFlushCall wrap *gomock.Call
type MockCmdableFunctionFlushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionFlushCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionFlushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionFlushCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionFlushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionFlushCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionFlushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionFlushAsync mocks base method.
func (m *MockCmdable) FunctionFlushAsync(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionFlushAsync", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionFlushAsync indicates an expected call of FunctionFlushAsync.
func (mr *MockCmdableMockRecorder) FunctionFlushAsync(ctx any) *MockCmdableFunctionFlushAsyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionFlushAsync", reflect.TypeOf((*MockCmdable)(nil).FunctionFlushAsync), ctx)
	return &MockCmdableFunctionFlushAsyncCall{Call: call}
}

// MockCmdableFunctionFlushAsyncCall wrap *gomock.Call
type MockCmdableFunctionFlushAsyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionFlushAsyncCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionFlushAsyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionFlushAsyncCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionFlushAsyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionFlushAsyncCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionFlushAsyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionKill mocks base method.
func (m *MockCmdable) FunctionKill(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionKill", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionKill indicates an expected call of FunctionKill.
func (mr *MockCmdableMockRecorder) FunctionKill(ctx any) *MockCmdableFunctionKillCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionKill", reflect.TypeOf((*MockCmdable)(nil).FunctionKill), ctx)
	return &MockCmdableFunctionKillCall{Call: call}
}

// MockCmdableFunctionKillCall wrap *gomock.Call
type MockCmdableFunctionKillCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionKillCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionKillCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionKillCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionKillCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionKillCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableFunctionKillCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionList mocks base method.
func (m *MockCmdable) FunctionList(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionList", ctx, q)
	ret0, _ := ret[0].(*redis.FunctionListCmd)
	return ret0
}

// FunctionList indicates an expected call of FunctionList.
func (mr *MockCmdableMockRecorder) FunctionList(ctx, q any) *MockCmdableFunctionListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionList", reflect.TypeOf((*MockCmdable)(nil).FunctionList), ctx, q)
	return &MockCmdableFunctionListCall{Call: call}
}

// MockCmdableFunctionListCall wrap *gomock.Call
type MockCmdableFunctionListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionListCall) Return(arg0 *redis.FunctionListCmd) *MockCmdableFunctionListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionListCall) Do(f func(context.Context, redis.FunctionListQuery) *redis.FunctionListCmd) *MockCmdableFunctionListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionListCall) DoAndReturn(f func(context.Context, redis.FunctionListQuery) *redis.FunctionListCmd) *MockCmdableFunctionListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionLoad mocks base method.
func (m *MockCmdable) FunctionLoad(ctx context.Context, code string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionLoad", ctx, code)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionLoad indicates an expected call of FunctionLoad.
func (mr *MockCmdableMockRecorder) FunctionLoad(ctx, code any) *MockCmdableFunctionLoadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionLoad", reflect.TypeOf((*MockCmdable)(nil).FunctionLoad), ctx, code)
	return &MockCmdableFunctionLoadCall{Call: call}
}

// MockCmdableFunctionLoadCall wrap *gomock.Call
type MockCmdableFunctionLoadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionLoadCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionLoadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionLoadCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionLoadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionLoadCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionLoadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionLoadReplace mocks base method.
func (m *MockCmdable) FunctionLoadReplace(ctx context.Context, code string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionLoadReplace", ctx, code)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionLoadReplace indicates an expected call of FunctionLoadReplace.
func (mr *MockCmdableMockRecorder) FunctionLoadReplace(ctx, code any) *MockCmdableFunctionLoadReplaceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionLoadReplace", reflect.TypeOf((*MockCmdable)(nil).FunctionLoadReplace), ctx, code)
	return &MockCmdableFunctionLoadReplaceCall{Call: call}
}

// MockCmdableFunctionLoadReplaceCall wrap *gomock.Call
type MockCmdableFunctionLoadReplaceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionLoadReplaceCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionLoadReplaceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionLoadReplaceCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionLoadReplaceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionLoadReplaceCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionLoadReplaceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionRestore mocks base method.
func (m *MockCmdable) FunctionRestore(ctx context.Context, libDump string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionRestore", ctx, libDump)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// FunctionRestore indicates an expected call of FunctionRestore.
func (mr *MockCmdableMockRecorder) FunctionRestore(ctx, libDump any) *MockCmdableFunctionRestoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionRestore", reflect.TypeOf((*MockCmdable)(nil).FunctionRestore), ctx, libDump)
	return &MockCmdableFunctionRestoreCall{Call: call}
}

// MockCmdableFunctionRestoreCall wrap *gomock.Call
type MockCmdableFunctionRestoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionRestoreCall) Return(arg0 *redis.StringCmd) *MockCmdableFunctionRestoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionRestoreCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionRestoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionRestoreCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableFunctionRestoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FunctionStats mocks base method.
func (m *MockCmdable) FunctionStats(ctx context.Context) *redis.FunctionStatsCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FunctionStats", ctx)
	ret0, _ := ret[0].(*redis.FunctionStatsCmd)
	return ret0
}

// FunctionStats indicates an expected call of FunctionStats.
func (mr *MockCmdableMockRecorder) FunctionStats(ctx any) *MockCmdableFunctionStatsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FunctionStats", reflect.TypeOf((*MockCmdable)(nil).FunctionStats), ctx)
	return &MockCmdableFunctionStatsCall{Call: call}
}

// MockCmdableFunctionStatsCall wrap *gomock.Call
type MockCmdableFunctionStatsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableFunctionStatsCall) Return(arg0 *redis.FunctionStatsCmd) *MockCmdableFunctionStatsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableFunctionStatsCall) Do(f func(context.Context) *redis.FunctionStatsCmd) *MockCmdableFunctionStatsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableFunctionStatsCall) DoAndReturn(f func(context.Context) *redis.FunctionStatsCmd) *MockCmdableFunctionStatsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoAdd mocks base method.
func (m *MockCmdable) GeoAdd(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range geoLocation {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GeoAdd", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// GeoAdd indicates an expected call of GeoAdd.
func (mr *MockCmdableMockRecorder) GeoAdd(ctx, key any, geoLocation ...any) *MockCmdableGeoAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, geoLocation...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoAdd", reflect.TypeOf((*MockCmdable)(nil).GeoAdd), varargs...)
	return &MockCmdableGeoAddCall{Call: call}
}

// MockCmdableGeoAddCall wrap *gomock.Call
type MockCmdableGeoAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoAddCall) Return(arg0 *redis.IntCmd) *MockCmdableGeoAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoAddCall) Do(f func(context.Context, string, ...*redis.GeoLocation) *redis.IntCmd) *MockCmdableGeoAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoAddCall) DoAndReturn(f func(context.Context, string, ...*redis.GeoLocation) *redis.IntCmd) *MockCmdableGeoAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoDist mocks base method.
func (m *MockCmdable) GeoDist(ctx context.Context, key, member1, member2, unit string) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoDist", ctx, key, member1, member2, unit)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// GeoDist indicates an expected call of GeoDist.
func (mr *MockCmdableMockRecorder) GeoDist(ctx, key, member1, member2, unit any) *MockCmdableGeoDistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoDist", reflect.TypeOf((*MockCmdable)(nil).GeoDist), ctx, key, member1, member2, unit)
	return &MockCmdableGeoDistCall{Call: call}
}

// MockCmdableGeoDistCall wrap *gomock.Call
type MockCmdableGeoDistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoDistCall) Return(arg0 *redis.FloatCmd) *MockCmdableGeoDistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoDistCall) Do(f func(context.Context, string, string, string, string) *redis.FloatCmd) *MockCmdableGeoDistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoDistCall) DoAndReturn(f func(context.Context, string, string, string, string) *redis.FloatCmd) *MockCmdableGeoDistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoHash mocks base method.
func (m *MockCmdable) GeoHash(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GeoHash", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// GeoHash indicates an expected call of GeoHash.
func (mr *MockCmdableMockRecorder) GeoHash(ctx, key any, members ...any) *MockCmdableGeoHashCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoHash", reflect.TypeOf((*MockCmdable)(nil).GeoHash), varargs...)
	return &MockCmdableGeoHashCall{Call: call}
}

// MockCmdableGeoHashCall wrap *gomock.Call
type MockCmdableGeoHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoHashCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableGeoHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoHashCall) Do(f func(context.Context, string, ...string) *redis.StringSliceCmd) *MockCmdableGeoHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoHashCall) DoAndReturn(f func(context.Context, string, ...string) *redis.StringSliceCmd) *MockCmdableGeoHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoPos mocks base method.
func (m *MockCmdable) GeoPos(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GeoPos", varargs...)
	ret0, _ := ret[0].(*redis.GeoPosCmd)
	return ret0
}

// GeoPos indicates an expected call of GeoPos.
func (mr *MockCmdableMockRecorder) GeoPos(ctx, key any, members ...any) *MockCmdableGeoPosCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoPos", reflect.TypeOf((*MockCmdable)(nil).GeoPos), varargs...)
	return &MockCmdableGeoPosCall{Call: call}
}

// MockCmdableGeoPosCall wrap *gomock.Call
type MockCmdableGeoPosCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoPosCall) Return(arg0 *redis.GeoPosCmd) *MockCmdableGeoPosCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoPosCall) Do(f func(context.Context, string, ...string) *redis.GeoPosCmd) *MockCmdableGeoPosCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoPosCall) DoAndReturn(f func(context.Context, string, ...string) *redis.GeoPosCmd) *MockCmdableGeoPosCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoRadius mocks base method.
func (m *MockCmdable) GeoRadius(ctx context.Context, key string, longitude, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoRadius", ctx, key, longitude, latitude, query)
	ret0, _ := ret[0].(*redis.GeoLocationCmd)
	return ret0
}

// GeoRadius indicates an expected call of GeoRadius.
func (mr *MockCmdableMockRecorder) GeoRadius(ctx, key, longitude, latitude, query any) *MockCmdableGeoRadiusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoRadius", reflect.TypeOf((*MockCmdable)(nil).GeoRadius), ctx, key, longitude, latitude, query)
	return &MockCmdableGeoRadiusCall{Call: call}
}

// MockCmdableGeoRadiusCall wrap *gomock.Call
type MockCmdableGeoRadiusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoRadiusCall) Return(arg0 *redis.GeoLocationCmd) *MockCmdableGeoRadiusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoRadiusCall) Do(f func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd) *MockCmdableGeoRadiusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoRadiusCall) DoAndReturn(f func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd) *MockCmdableGeoRadiusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoRadiusByMember mocks base method.
func (m *MockCmdable) GeoRadiusByMember(ctx context.Context, key, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoRadiusByMember", ctx, key, member, query)
	ret0, _ := ret[0].(*redis.GeoLocationCmd)
	return ret0
}

// GeoRadiusByMember indicates an expected call of GeoRadiusByMember.
func (mr *MockCmdableMockRecorder) GeoRadiusByMember(ctx, key, member, query any) *MockCmdableGeoRadiusByMemberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoRadiusByMember", reflect.TypeOf((*MockCmdable)(nil).GeoRadiusByMember), ctx, key, member, query)
	return &MockCmdableGeoRadiusByMemberCall{Call: call}
}

// MockCmdableGeoRadiusByMemberCall wrap *gomock.Call
type MockCmdableGeoRadiusByMemberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoRadiusByMemberCall) Return(arg0 *redis.GeoLocationCmd) *MockCmdableGeoRadiusByMemberCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoRadiusByMemberCall) Do(f func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd) *MockCmdableGeoRadiusByMemberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoRadiusByMemberCall) DoAndReturn(f func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd) *MockCmdableGeoRadiusByMemberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoRadiusByMemberStore mocks base method.
func (m *MockCmdable) GeoRadiusByMemberStore(ctx context.Context, key, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoRadiusByMemberStore", ctx, key, member, query)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// GeoRadiusByMemberStore indicates an expected call of GeoRadiusByMemberStore.
func (mr *MockCmdableMockRecorder) GeoRadiusByMemberStore(ctx, key, member, query any) *MockCmdableGeoRadiusByMemberStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoRadiusByMemberStore", reflect.TypeOf((*MockCmdable)(nil).GeoRadiusByMemberStore), ctx, key, member, query)
	return &MockCmdableGeoRadiusByMemberStoreCall{Call: call}
}

// MockCmdableGeoRadiusByMemberStoreCall wrap *gomock.Call
type MockCmdableGeoRadiusByMemberStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoRadiusByMemberStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableGeoRadiusByMemberStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoRadiusByMemberStoreCall) Do(f func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.IntCmd) *MockCmdableGeoRadiusByMemberStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoRadiusByMemberStoreCall) DoAndReturn(f func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.IntCmd) *MockCmdableGeoRadiusByMemberStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoRadiusStore mocks base method.
func (m *MockCmdable) GeoRadiusStore(ctx context.Context, key string, longitude, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoRadiusStore", ctx, key, longitude, latitude, query)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// GeoRadiusStore indicates an expected call of GeoRadiusStore.
func (mr *MockCmdableMockRecorder) GeoRadiusStore(ctx, key, longitude, latitude, query any) *MockCmdableGeoRadiusStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoRadiusStore", reflect.TypeOf((*MockCmdable)(nil).GeoRadiusStore), ctx, key, longitude, latitude, query)
	return &MockCmdableGeoRadiusStoreCall{Call: call}
}

// MockCmdableGeoRadiusStoreCall wrap *gomock.Call
type MockCmdableGeoRadiusStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoRadiusStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableGeoRadiusStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoRadiusStoreCall) Do(f func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.IntCmd) *MockCmdableGeoRadiusStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoRadiusStoreCall) DoAndReturn(f func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.IntCmd) *MockCmdableGeoRadiusStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoSearch mocks base method.
func (m *MockCmdable) GeoSearch(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoSearch", ctx, key, q)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// GeoSearch indicates an expected call of GeoSearch.
func (mr *MockCmdableMockRecorder) GeoSearch(ctx, key, q any) *MockCmdableGeoSearchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoSearch", reflect.TypeOf((*MockCmdable)(nil).GeoSearch), ctx, key, q)
	return &MockCmdableGeoSearchCall{Call: call}
}

// MockCmdableGeoSearchCall wrap *gomock.Call
type MockCmdableGeoSearchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoSearchCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableGeoSearchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoSearchCall) Do(f func(context.Context, string, *redis.GeoSearchQuery) *redis.StringSliceCmd) *MockCmdableGeoSearchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoSearchCall) DoAndReturn(f func(context.Context, string, *redis.GeoSearchQuery) *redis.StringSliceCmd) *MockCmdableGeoSearchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoSearchLocation mocks base method.
func (m *MockCmdable) GeoSearchLocation(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoSearchLocation", ctx, key, q)
	ret0, _ := ret[0].(*redis.GeoSearchLocationCmd)
	return ret0
}

// GeoSearchLocation indicates an expected call of GeoSearchLocation.
func (mr *MockCmdableMockRecorder) GeoSearchLocation(ctx, key, q any) *MockCmdableGeoSearchLocationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoSearchLocation", reflect.TypeOf((*MockCmdable)(nil).GeoSearchLocation), ctx, key, q)
	return &MockCmdableGeoSearchLocationCall{Call: call}
}

// MockCmdableGeoSearchLocationCall wrap *gomock.Call
type MockCmdableGeoSearchLocationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoSearchLocationCall) Return(arg0 *redis.GeoSearchLocationCmd) *MockCmdableGeoSearchLocationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoSearchLocationCall) Do(f func(context.Context, string, *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd) *MockCmdableGeoSearchLocationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoSearchLocationCall) DoAndReturn(f func(context.Context, string, *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd) *MockCmdableGeoSearchLocationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GeoSearchStore mocks base method.
func (m *MockCmdable) GeoSearchStore(ctx context.Context, key, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeoSearchStore", ctx, key, store, q)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// GeoSearchStore indicates an expected call of GeoSearchStore.
func (mr *MockCmdableMockRecorder) GeoSearchStore(ctx, key, store, q any) *MockCmdableGeoSearchStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeoSearchStore", reflect.TypeOf((*MockCmdable)(nil).GeoSearchStore), ctx, key, store, q)
	return &MockCmdableGeoSearchStoreCall{Call: call}
}

// MockCmdableGeoSearchStoreCall wrap *gomock.Call
type MockCmdableGeoSearchStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGeoSearchStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableGeoSearchStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGeoSearchStoreCall) Do(f func(context.Context, string, string, *redis.GeoSearchStoreQuery) *redis.IntCmd) *MockCmdableGeoSearchStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGeoSearchStoreCall) DoAndReturn(f func(context.Context, string, string, *redis.GeoSearchStoreQuery) *redis.IntCmd) *MockCmdableGeoSearchStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockCmdable) Get(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockCmdableMockRecorder) Get(ctx, key any) *MockCmdableGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCmdable)(nil).Get), ctx, key)
	return &MockCmdableGetCall{Call: call}
}

// MockCmdableGetCall wrap *gomock.Call
type MockCmdableGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGetCall) Return(arg0 *redis.StringCmd) *MockCmdableGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGetCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGetCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBit mocks base method.
func (m *MockCmdable) GetBit(ctx context.Context, key string, offset int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBit", ctx, key, offset)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// GetBit indicates an expected call of GetBit.
func (mr *MockCmdableMockRecorder) GetBit(ctx, key, offset any) *MockCmdableGetBitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBit", reflect.TypeOf((*MockCmdable)(nil).GetBit), ctx, key, offset)
	return &MockCmdableGetBitCall{Call: call}
}

// MockCmdableGetBitCall wrap *gomock.Call
type MockCmdableGetBitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGetBitCall) Return(arg0 *redis.IntCmd) *MockCmdableGetBitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGetBitCall) Do(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableGetBitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGetBitCall) DoAndReturn(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableGetBitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetDel mocks base method.
func (m *MockCmdable) GetDel(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDel", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// GetDel indicates an expected call of GetDel.
func (mr *MockCmdableMockRecorder) GetDel(ctx, key any) *MockCmdableGetDelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDel", reflect.TypeOf((*MockCmdable)(nil).GetDel), ctx, key)
	return &MockCmdableGetDelCall{Call: call}
}

// MockCmdableGetDelCall wrap *gomock.Call
type MockCmdableGetDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGetDelCall) Return(arg0 *redis.StringCmd) *MockCmdableGetDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGetDelCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableGetDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGetDelCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableGetDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEx mocks base method.
func (m *MockCmdable) GetEx(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEx", ctx, key, expiration)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// GetEx indicates an expected call of GetEx.
func (mr *MockCmdableMockRecorder) GetEx(ctx, key, expiration any) *MockCmdableGetExCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEx", reflect.TypeOf((*MockCmdable)(nil).GetEx), ctx, key, expiration)
	return &MockCmdableGetExCall{Call: call}
}

// MockCmdableGetExCall wrap *gomock.Call
type MockCmdableGetExCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGetExCall) Return(arg0 *redis.StringCmd) *MockCmdableGetExCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGetExCall) Do(f func(context.Context, string, time.Duration) *redis.StringCmd) *MockCmdableGetExCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGetExCall) DoAndReturn(f func(context.Context, string, time.Duration) *redis.StringCmd) *MockCmdableGetExCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRange mocks base method.
func (m *MockCmdable) GetRange(ctx context.Context, key string, start, end int64) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRange", ctx, key, start, end)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// GetRange indicates an expected call of GetRange.
func (mr *MockCmdableMockRecorder) GetRange(ctx, key, start, end any) *MockCmdableGetRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRange", reflect.TypeOf((*MockCmdable)(nil).GetRange), ctx, key, start, end)
	return &MockCmdableGetRangeCall{Call: call}
}

// MockCmdableGetRangeCall wrap *gomock.Call
type MockCmdableGetRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGetRangeCall) Return(arg0 *redis.StringCmd) *MockCmdableGetRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGetRangeCall) Do(f func(context.Context, string, int64, int64) *redis.StringCmd) *MockCmdableGetRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGetRangeCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StringCmd) *MockCmdableGetRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSet mocks base method.
func (m *MockCmdable) GetSet(ctx context.Context, key string, value any) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSet", ctx, key, value)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// GetSet indicates an expected call of GetSet.
func (mr *MockCmdableMockRecorder) GetSet(ctx, key, value any) *MockCmdableGetSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSet", reflect.TypeOf((*MockCmdable)(nil).GetSet), ctx, key, value)
	return &MockCmdableGetSetCall{Call: call}
}

// MockCmdableGetSetCall wrap *gomock.Call
type MockCmdableGetSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableGetSetCall) Return(arg0 *redis.StringCmd) *MockCmdableGetSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableGetSetCall) Do(f func(context.Context, string, any) *redis.StringCmd) *MockCmdableGetSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableGetSetCall) DoAndReturn(f func(context.Context, string, any) *redis.StringCmd) *MockCmdableGetSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HDel mocks base method.
func (m *MockCmdable) HDel(ctx context.Context, key string, fields ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HDel", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// HDel indicates an expected call of HDel.
func (mr *MockCmdableMockRecorder) HDel(ctx, key any, fields ...any) *MockCmdableHDelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HDel", reflect.TypeOf((*MockCmdable)(nil).HDel), varargs...)
	return &MockCmdableHDelCall{Call: call}
}

// MockCmdableHDelCall wrap *gomock.Call
type MockCmdableHDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHDelCall) Return(arg0 *redis.IntCmd) *MockCmdableHDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHDelCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableHDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHDelCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableHDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HExists mocks base method.
func (m *MockCmdable) HExists(ctx context.Context, key, field string) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HExists", ctx, key, field)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// HExists indicates an expected call of HExists.
func (mr *MockCmdableMockRecorder) HExists(ctx, key, field any) *MockCmdableHExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HExists", reflect.TypeOf((*MockCmdable)(nil).HExists), ctx, key, field)
	return &MockCmdableHExistsCall{Call: call}
}

// MockCmdableHExistsCall wrap *gomock.Call
type MockCmdableHExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHExistsCall) Return(arg0 *redis.BoolCmd) *MockCmdableHExistsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHExistsCall) Do(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableHExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHExistsCall) DoAndReturn(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableHExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HExpire mocks base method.
func (m *MockCmdable) HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, expiration}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HExpire", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HExpire indicates an expected call of HExpire.
func (mr *MockCmdableMockRecorder) HExpire(ctx, key, expiration any, fields ...any) *MockCmdableHExpireCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, expiration}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HExpire", reflect.TypeOf((*MockCmdable)(nil).HExpire), varargs...)
	return &MockCmdableHExpireCall{Call: call}
}

// MockCmdableHExpireCall wrap *gomock.Call
type MockCmdableHExpireCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHExpireCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHExpireCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHExpireCall) Do(f func(context.Context, string, time.Duration, ...string) *redis.IntSliceCmd) *MockCmdableHExpireCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHExpireCall) DoAndReturn(f func(context.Context, string, time.Duration, ...string) *redis.IntSliceCmd) *MockCmdableHExpireCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HExpireAt mocks base method.
func (m *MockCmdable) HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, tm}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HExpireAt", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HExpireAt indicates an expected call of HExpireAt.
func (mr *MockCmdableMockRecorder) HExpireAt(ctx, key, tm any, fields ...any) *MockCmdableHExpireAtCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, tm}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HExpireAt", reflect.TypeOf((*MockCmdable)(nil).HExpireAt), varargs...)
	return &MockCmdableHExpireAtCall{Call: call}
}

// MockCmdableHExpireAtCall wrap *gomock.Call
type MockCmdableHExpireAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHExpireAtCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHExpireAtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHExpireAtCall) Do(f func(context.Context, string, time.Time, ...string) *redis.IntSliceCmd) *MockCmdableHExpireAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHExpireAtCall) DoAndReturn(f func(context.Context, string, time.Time, ...string) *redis.IntSliceCmd) *MockCmdableHExpireAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HExpireAtWithArgs mocks base method.
func (m *MockCmdable) HExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, tm, expirationArgs}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HExpireAtWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HExpireAtWithArgs indicates an expected call of HExpireAtWithArgs.
func (mr *MockCmdableMockRecorder) HExpireAtWithArgs(ctx, key, tm, expirationArgs any, fields ...any) *MockCmdableHExpireAtWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, tm, expirationArgs}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HExpireAtWithArgs", reflect.TypeOf((*MockCmdable)(nil).HExpireAtWithArgs), varargs...)
	return &MockCmdableHExpireAtWithArgsCall{Call: call}
}

// MockCmdableHExpireAtWithArgsCall wrap *gomock.Call
type MockCmdableHExpireAtWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHExpireAtWithArgsCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHExpireAtWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHExpireAtWithArgsCall) Do(f func(context.Context, string, time.Time, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHExpireAtWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHExpireAtWithArgsCall) DoAndReturn(f func(context.Context, string, time.Time, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHExpireAtWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HExpireTime mocks base method.
func (m *MockCmdable) HExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HExpireTime", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HExpireTime indicates an expected call of HExpireTime.
func (mr *MockCmdableMockRecorder) HExpireTime(ctx, key any, fields ...any) *MockCmdableHExpireTimeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HExpireTime", reflect.TypeOf((*MockCmdable)(nil).HExpireTime), varargs...)
	return &MockCmdableHExpireTimeCall{Call: call}
}

// MockCmdableHExpireTimeCall wrap *gomock.Call
type MockCmdableHExpireTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHExpireTimeCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHExpireTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHExpireTimeCall) Do(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHExpireTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHExpireTimeCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHExpireTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HExpireWithArgs mocks base method.
func (m *MockCmdable) HExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, expiration, expirationArgs}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HExpireWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HExpireWithArgs indicates an expected call of HExpireWithArgs.
func (mr *MockCmdableMockRecorder) HExpireWithArgs(ctx, key, expiration, expirationArgs any, fields ...any) *MockCmdableHExpireWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, expiration, expirationArgs}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HExpireWithArgs", reflect.TypeOf((*MockCmdable)(nil).HExpireWithArgs), varargs...)
	return &MockCmdableHExpireWithArgsCall{Call: call}
}

// MockCmdableHExpireWithArgsCall wrap *gomock.Call
type MockCmdableHExpireWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHExpireWithArgsCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHExpireWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHExpireWithArgsCall) Do(f func(context.Context, string, time.Duration, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHExpireWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHExpireWithArgsCall) DoAndReturn(f func(context.Context, string, time.Duration, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHExpireWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HGet mocks base method.
func (m *MockCmdable) HGet(ctx context.Context, key, field string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HGet", ctx, key, field)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// HGet indicates an expected call of HGet.
func (mr *MockCmdableMockRecorder) HGet(ctx, key, field any) *MockCmdableHGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HGet", reflect.TypeOf((*MockCmdable)(nil).HGet), ctx, key, field)
	return &MockCmdableHGetCall{Call: call}
}

// MockCmdableHGetCall wrap *gomock.Call
type MockCmdableHGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHGetCall) Return(arg0 *redis.StringCmd) *MockCmdableHGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHGetCall) Do(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableHGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHGetCall) DoAndReturn(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableHGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HGetAll mocks base method.
func (m *MockCmdable) HGetAll(ctx context.Context, key string) *redis.MapStringStringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HGetAll", ctx, key)
	ret0, _ := ret[0].(*redis.MapStringStringCmd)
	return ret0
}

// HGetAll indicates an expected call of HGetAll.
func (mr *MockCmdableMockRecorder) HGetAll(ctx, key any) *MockCmdableHGetAllCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HGetAll", reflect.TypeOf((*MockCmdable)(nil).HGetAll), ctx, key)
	return &MockCmdableHGetAllCall{Call: call}
}

// MockCmdableHGetAllCall wrap *gomock.Call
type MockCmdableHGetAllCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHGetAllCall) Return(arg0 *redis.MapStringStringCmd) *MockCmdableHGetAllCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHGetAllCall) Do(f func(context.Context, string) *redis.MapStringStringCmd) *MockCmdableHGetAllCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHGetAllCall) DoAndReturn(f func(context.Context, string) *redis.MapStringStringCmd) *MockCmdableHGetAllCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HGetDel mocks base method.
func (m *MockCmdable) HGetDel(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HGetDel", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// HGetDel indicates an expected call of HGetDel.
func (mr *MockCmdableMockRecorder) HGetDel(ctx, key any, fields ...any) *MockCmdableHGetDelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HGetDel", reflect.TypeOf((*MockCmdable)(nil).HGetDel), varargs...)
	return &MockCmdableHGetDelCall{Call: call}
}

// MockCmdableHGetDelCall wrap *gomock.Call
type MockCmdableHGetDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHGetDelCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableHGetDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHGetDelCall) Do(f func(context.Context, string, ...string) *redis.StringSliceCmd) *MockCmdableHGetDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHGetDelCall) DoAndReturn(f func(context.Context, string, ...string) *redis.StringSliceCmd) *MockCmdableHGetDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HGetEX mocks base method.
func (m *MockCmdable) HGetEX(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HGetEX", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// HGetEX indicates an expected call of HGetEX.
func (mr *MockCmdableMockRecorder) HGetEX(ctx, key any, fields ...any) *MockCmdableHGetEXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HGetEX", reflect.TypeOf((*MockCmdable)(nil).HGetEX), varargs...)
	return &MockCmdableHGetEXCall{Call: call}
}

// MockCmdableHGetEXCall wrap *gomock.Call
type MockCmdableHGetEXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHGetEXCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableHGetEXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHGetEXCall) Do(f func(context.Context, string, ...string) *redis.StringSliceCmd) *MockCmdableHGetEXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHGetEXCall) DoAndReturn(f func(context.Context, string, ...string) *redis.StringSliceCmd) *MockCmdableHGetEXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HGetEXWithArgs mocks base method.
func (m *MockCmdable) HGetEXWithArgs(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, options}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HGetEXWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// HGetEXWithArgs indicates an expected call of HGetEXWithArgs.
func (mr *MockCmdableMockRecorder) HGetEXWithArgs(ctx, key, options any, fields ...any) *MockCmdableHGetEXWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, options}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HGetEXWithArgs", reflect.TypeOf((*MockCmdable)(nil).HGetEXWithArgs), varargs...)
	return &MockCmdableHGetEXWithArgsCall{Call: call}
}

// MockCmdableHGetEXWithArgsCall wrap *gomock.Call
type MockCmdableHGetEXWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHGetEXWithArgsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableHGetEXWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHGetEXWithArgsCall) Do(f func(context.Context, string, *redis.HGetEXOptions, ...string) *redis.StringSliceCmd) *MockCmdableHGetEXWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHGetEXWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.HGetEXOptions, ...string) *redis.StringSliceCmd) *MockCmdableHGetEXWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HIncrBy mocks base method.
func (m *MockCmdable) HIncrBy(ctx context.Context, key, field string, incr int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HIncrBy", ctx, key, field, incr)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// HIncrBy indicates an expected call of HIncrBy.
func (mr *MockCmdableMockRecorder) HIncrBy(ctx, key, field, incr any) *MockCmdableHIncrByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HIncrBy", reflect.TypeOf((*MockCmdable)(nil).HIncrBy), ctx, key, field, incr)
	return &MockCmdableHIncrByCall{Call: call}
}

// MockCmdableHIncrByCall wrap *gomock.Call
type MockCmdableHIncrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHIncrByCall) Return(arg0 *redis.IntCmd) *MockCmdableHIncrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHIncrByCall) Do(f func(context.Context, string, string, int64) *redis.IntCmd) *MockCmdableHIncrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHIncrByCall) DoAndReturn(f func(context.Context, string, string, int64) *redis.IntCmd) *MockCmdableHIncrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HIncrByFloat mocks base method.
func (m *MockCmdable) HIncrByFloat(ctx context.Context, key, field string, incr float64) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HIncrByFloat", ctx, key, field, incr)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// HIncrByFloat indicates an expected call of HIncrByFloat.
func (mr *MockCmdableMockRecorder) HIncrByFloat(ctx, key, field, incr any) *MockCmdableHIncrByFloatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HIncrByFloat", reflect.TypeOf((*MockCmdable)(nil).HIncrByFloat), ctx, key, field, incr)
	return &MockCmdableHIncrByFloatCall{Call: call}
}

// MockCmdableHIncrByFloatCall wrap *gomock.Call
type MockCmdableHIncrByFloatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHIncrByFloatCall) Return(arg0 *redis.FloatCmd) *MockCmdableHIncrByFloatCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHIncrByFloatCall) Do(f func(context.Context, string, string, float64) *redis.FloatCmd) *MockCmdableHIncrByFloatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHIncrByFloatCall) DoAndReturn(f func(context.Context, string, string, float64) *redis.FloatCmd) *MockCmdableHIncrByFloatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HKeys mocks base method.
func (m *MockCmdable) HKeys(ctx context.Context, key string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HKeys", ctx, key)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// HKeys indicates an expected call of HKeys.
func (mr *MockCmdableMockRecorder) HKeys(ctx, key any) *MockCmdableHKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HKeys", reflect.TypeOf((*MockCmdable)(nil).HKeys), ctx, key)
	return &MockCmdableHKeysCall{Call: call}
}

// MockCmdableHKeysCall wrap *gomock.Call
type MockCmdableHKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHKeysCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableHKeysCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHKeysCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableHKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHKeysCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableHKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HLen mocks base method.
func (m *MockCmdable) HLen(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HLen", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// HLen indicates an expected call of HLen.
func (mr *MockCmdableMockRecorder) HLen(ctx, key any) *MockCmdableHLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HLen", reflect.TypeOf((*MockCmdable)(nil).HLen), ctx, key)
	return &MockCmdableHLenCall{Call: call}
}

// MockCmdableHLenCall wrap *gomock.Call
type MockCmdableHLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHLenCall) Return(arg0 *redis.IntCmd) *MockCmdableHLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHLenCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableHLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHLenCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableHLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HMGet mocks base method.
func (m *MockCmdable) HMGet(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HMGet", varargs...)
	ret0, _ := ret[0].(*redis.SliceCmd)
	return ret0
}

// HMGet indicates an expected call of HMGet.
func (mr *MockCmdableMockRecorder) HMGet(ctx, key any, fields ...any) *MockCmdableHMGetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HMGet", reflect.TypeOf((*MockCmdable)(nil).HMGet), varargs...)
	return &MockCmdableHMGetCall{Call: call}
}

// MockCmdableHMGetCall wrap *gomock.Call
type MockCmdableHMGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHMGetCall) Return(arg0 *redis.SliceCmd) *MockCmdableHMGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHMGetCall) Do(f func(context.Context, string, ...string) *redis.SliceCmd) *MockCmdableHMGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHMGetCall) DoAndReturn(f func(context.Context, string, ...string) *redis.SliceCmd) *MockCmdableHMGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HMSet mocks base method.
func (m *MockCmdable) HMSet(ctx context.Context, key string, values ...any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HMSet", varargs...)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// HMSet indicates an expected call of HMSet.
func (mr *MockCmdableMockRecorder) HMSet(ctx, key any, values ...any) *MockCmdableHMSetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HMSet", reflect.TypeOf((*MockCmdable)(nil).HMSet), varargs...)
	return &MockCmdableHMSetCall{Call: call}
}

// MockCmdableHMSetCall wrap *gomock.Call
type MockCmdableHMSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHMSetCall) Return(arg0 *redis.BoolCmd) *MockCmdableHMSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHMSetCall) Do(f func(context.Context, string, ...any) *redis.BoolCmd) *MockCmdableHMSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHMSetCall) DoAndReturn(f func(context.Context, string, ...any) *redis.BoolCmd) *MockCmdableHMSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HPExpire mocks base method.
func (m *MockCmdable) HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, expiration}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HPExpire", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HPExpire indicates an expected call of HPExpire.
func (mr *MockCmdableMockRecorder) HPExpire(ctx, key, expiration any, fields ...any) *MockCmdableHPExpireCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, expiration}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HPExpire", reflect.TypeOf((*MockCmdable)(nil).HPExpire), varargs...)
	return &MockCmdableHPExpireCall{Call: call}
}

// MockCmdableHPExpireCall wrap *gomock.Call
type MockCmdableHPExpireCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHPExpireCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHPExpireCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHPExpireCall) Do(f func(context.Context, string, time.Duration, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHPExpireCall) DoAndReturn(f func(context.Context, string, time.Duration, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HPExpireAt mocks base method.
func (m *MockCmdable) HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, tm}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HPExpireAt", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HPExpireAt indicates an expected call of HPExpireAt.
func (mr *MockCmdableMockRecorder) HPExpireAt(ctx, key, tm any, fields ...any) *MockCmdableHPExpireAtCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, tm}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HPExpireAt", reflect.TypeOf((*MockCmdable)(nil).HPExpireAt), varargs...)
	return &MockCmdableHPExpireAtCall{Call: call}
}

// MockCmdableHPExpireAtCall wrap *gomock.Call
type MockCmdableHPExpireAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHPExpireAtCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHPExpireAtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHPExpireAtCall) Do(f func(context.Context, string, time.Time, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHPExpireAtCall) DoAndReturn(f func(context.Context, string, time.Time, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HPExpireAtWithArgs mocks base method.
func (m *MockCmdable) HPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, tm, expirationArgs}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HPExpireAtWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HPExpireAtWithArgs indicates an expected call of HPExpireAtWithArgs.
func (mr *MockCmdableMockRecorder) HPExpireAtWithArgs(ctx, key, tm, expirationArgs any, fields ...any) *MockCmdableHPExpireAtWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, tm, expirationArgs}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HPExpireAtWithArgs", reflect.TypeOf((*MockCmdable)(nil).HPExpireAtWithArgs), varargs...)
	return &MockCmdableHPExpireAtWithArgsCall{Call: call}
}

// MockCmdableHPExpireAtWithArgsCall wrap *gomock.Call
type MockCmdableHPExpireAtWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHPExpireAtWithArgsCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHPExpireAtWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHPExpireAtWithArgsCall) Do(f func(context.Context, string, time.Time, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireAtWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHPExpireAtWithArgsCall) DoAndReturn(f func(context.Context, string, time.Time, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireAtWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HPExpireTime mocks base method.
func (m *MockCmdable) HPExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HPExpireTime", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HPExpireTime indicates an expected call of HPExpireTime.
func (mr *MockCmdableMockRecorder) HPExpireTime(ctx, key any, fields ...any) *MockCmdableHPExpireTimeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HPExpireTime", reflect.TypeOf((*MockCmdable)(nil).HPExpireTime), varargs...)
	return &MockCmdableHPExpireTimeCall{Call: call}
}

// MockCmdableHPExpireTimeCall wrap *gomock.Call
type MockCmdableHPExpireTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHPExpireTimeCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHPExpireTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHPExpireTimeCall) Do(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHPExpireTimeCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HPExpireWithArgs mocks base method.
func (m *MockCmdable) HPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, expiration, expirationArgs}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HPExpireWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HPExpireWithArgs indicates an expected call of HPExpireWithArgs.
func (mr *MockCmdableMockRecorder) HPExpireWithArgs(ctx, key, expiration, expirationArgs any, fields ...any) *MockCmdableHPExpireWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, expiration, expirationArgs}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HPExpireWithArgs", reflect.TypeOf((*MockCmdable)(nil).HPExpireWithArgs), varargs...)
	return &MockCmdableHPExpireWithArgsCall{Call: call}
}

// MockCmdableHPExpireWithArgsCall wrap *gomock.Call
type MockCmdableHPExpireWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHPExpireWithArgsCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHPExpireWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHPExpireWithArgsCall) Do(f func(context.Context, string, time.Duration, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHPExpireWithArgsCall) DoAndReturn(f func(context.Context, string, time.Duration, redis.HExpireArgs, ...string) *redis.IntSliceCmd) *MockCmdableHPExpireWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HPTTL mocks base method.
func (m *MockCmdable) HPTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HPTTL", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HPTTL indicates an expected call of HPTTL.
func (mr *MockCmdableMockRecorder) HPTTL(ctx, key any, fields ...any) *MockCmdableHPTTLCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HPTTL", reflect.TypeOf((*MockCmdable)(nil).HPTTL), varargs...)
	return &MockCmdableHPTTLCall{Call: call}
}

// MockCmdableHPTTLCall wrap *gomock.Call
type MockCmdableHPTTLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHPTTLCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHPTTLCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHPTTLCall) Do(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHPTTLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHPTTLCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHPTTLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HPersist mocks base method.
func (m *MockCmdable) HPersist(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HPersist", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HPersist indicates an expected call of HPersist.
func (mr *MockCmdableMockRecorder) HPersist(ctx, key any, fields ...any) *MockCmdableHPersistCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HPersist", reflect.TypeOf((*MockCmdable)(nil).HPersist), varargs...)
	return &MockCmdableHPersistCall{Call: call}
}

// MockCmdableHPersistCall wrap *gomock.Call
type MockCmdableHPersistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHPersistCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHPersistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHPersistCall) Do(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHPersistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHPersistCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHPersistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HRandField mocks base method.
func (m *MockCmdable) HRandField(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HRandField", ctx, key, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// HRandField indicates an expected call of HRandField.
func (mr *MockCmdableMockRecorder) HRandField(ctx, key, count any) *MockCmdableHRandFieldCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HRandField", reflect.TypeOf((*MockCmdable)(nil).HRandField), ctx, key, count)
	return &MockCmdableHRandFieldCall{Call: call}
}

// MockCmdableHRandFieldCall wrap *gomock.Call
type MockCmdableHRandFieldCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHRandFieldCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableHRandFieldCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHRandFieldCall) Do(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableHRandFieldCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHRandFieldCall) DoAndReturn(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableHRandFieldCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HRandFieldWithValues mocks base method.
func (m *MockCmdable) HRandFieldWithValues(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HRandFieldWithValues", ctx, key, count)
	ret0, _ := ret[0].(*redis.KeyValueSliceCmd)
	return ret0
}

// HRandFieldWithValues indicates an expected call of HRandFieldWithValues.
func (mr *MockCmdableMockRecorder) HRandFieldWithValues(ctx, key, count any) *MockCmdableHRandFieldWithValuesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HRandFieldWithValues", reflect.TypeOf((*MockCmdable)(nil).HRandFieldWithValues), ctx, key, count)
	return &MockCmdableHRandFieldWithValuesCall{Call: call}
}

// MockCmdableHRandFieldWithValuesCall wrap *gomock.Call
type MockCmdableHRandFieldWithValuesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHRandFieldWithValuesCall) Return(arg0 *redis.KeyValueSliceCmd) *MockCmdableHRandFieldWithValuesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHRandFieldWithValuesCall) Do(f func(context.Context, string, int) *redis.KeyValueSliceCmd) *MockCmdableHRandFieldWithValuesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHRandFieldWithValuesCall) DoAndReturn(f func(context.Context, string, int) *redis.KeyValueSliceCmd) *MockCmdableHRandFieldWithValuesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HScan mocks base method.
func (m *MockCmdable) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HScan", ctx, key, cursor, match, count)
	ret0, _ := ret[0].(*redis.ScanCmd)
	return ret0
}

// HScan indicates an expected call of HScan.
func (mr *MockCmdableMockRecorder) HScan(ctx, key, cursor, match, count any) *MockCmdableHScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HScan", reflect.TypeOf((*MockCmdable)(nil).HScan), ctx, key, cursor, match, count)
	return &MockCmdableHScanCall{Call: call}
}

// MockCmdableHScanCall wrap *gomock.Call
type MockCmdableHScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHScanCall) Return(arg0 *redis.ScanCmd) *MockCmdableHScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHScanCall) Do(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableHScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHScanCall) DoAndReturn(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableHScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HScanNoValues mocks base method.
func (m *MockCmdable) HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HScanNoValues", ctx, key, cursor, match, count)
	ret0, _ := ret[0].(*redis.ScanCmd)
	return ret0
}

// HScanNoValues indicates an expected call of HScanNoValues.
func (mr *MockCmdableMockRecorder) HScanNoValues(ctx, key, cursor, match, count any) *MockCmdableHScanNoValuesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HScanNoValues", reflect.TypeOf((*MockCmdable)(nil).HScanNoValues), ctx, key, cursor, match, count)
	return &MockCmdableHScanNoValuesCall{Call: call}
}

// MockCmdableHScanNoValuesCall wrap *gomock.Call
type MockCmdableHScanNoValuesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHScanNoValuesCall) Return(arg0 *redis.ScanCmd) *MockCmdableHScanNoValuesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHScanNoValuesCall) Do(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableHScanNoValuesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHScanNoValuesCall) DoAndReturn(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableHScanNoValuesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HSet mocks base method.
func (m *MockCmdable) HSet(ctx context.Context, key string, values ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HSet", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// HSet indicates an expected call of HSet.
func (mr *MockCmdableMockRecorder) HSet(ctx, key any, values ...any) *MockCmdableHSetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HSet", reflect.TypeOf((*MockCmdable)(nil).HSet), varargs...)
	return &MockCmdableHSetCall{Call: call}
}

// MockCmdableHSetCall wrap *gomock.Call
type MockCmdableHSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHSetCall) Return(arg0 *redis.IntCmd) *MockCmdableHSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHSetCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableHSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHSetCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableHSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HSetEX mocks base method.
func (m *MockCmdable) HSetEX(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fieldsAndValues {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HSetEX", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// HSetEX indicates an expected call of HSetEX.
func (mr *MockCmdableMockRecorder) HSetEX(ctx, key any, fieldsAndValues ...any) *MockCmdableHSetEXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fieldsAndValues...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HSetEX", reflect.TypeOf((*MockCmdable)(nil).HSetEX), varargs...)
	return &MockCmdableHSetEXCall{Call: call}
}

// MockCmdableHSetEXCall wrap *gomock.Call
type MockCmdableHSetEXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHSetEXCall) Return(arg0 *redis.IntCmd) *MockCmdableHSetEXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHSetEXCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableHSetEXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHSetEXCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableHSetEXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HSetEXWithArgs mocks base method.
func (m *MockCmdable) HSetEXWithArgs(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, options}
	for _, a := range fieldsAndValues {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HSetEXWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// HSetEXWithArgs indicates an expected call of HSetEXWithArgs.
func (mr *MockCmdableMockRecorder) HSetEXWithArgs(ctx, key, options any, fieldsAndValues ...any) *MockCmdableHSetEXWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, options}, fieldsAndValues...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HSetEXWithArgs", reflect.TypeOf((*MockCmdable)(nil).HSetEXWithArgs), varargs...)
	return &MockCmdableHSetEXWithArgsCall{Call: call}
}

// MockCmdableHSetEXWithArgsCall wrap *gomock.Call
type MockCmdableHSetEXWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHSetEXWithArgsCall) Return(arg0 *redis.IntCmd) *MockCmdableHSetEXWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHSetEXWithArgsCall) Do(f func(context.Context, string, *redis.HSetEXOptions, ...string) *redis.IntCmd) *MockCmdableHSetEXWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHSetEXWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.HSetEXOptions, ...string) *redis.IntCmd) *MockCmdableHSetEXWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HSetNX mocks base method.
func (m *MockCmdable) HSetNX(ctx context.Context, key, field string, value any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HSetNX", ctx, key, field, value)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// HSetNX indicates an expected call of HSetNX.
func (mr *MockCmdableMockRecorder) HSetNX(ctx, key, field, value any) *MockCmdableHSetNXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HSetNX", reflect.TypeOf((*MockCmdable)(nil).HSetNX), ctx, key, field, value)
	return &MockCmdableHSetNXCall{Call: call}
}

// MockCmdableHSetNXCall wrap *gomock.Call
type MockCmdableHSetNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHSetNXCall) Return(arg0 *redis.BoolCmd) *MockCmdableHSetNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHSetNXCall) Do(f func(context.Context, string, string, any) *redis.BoolCmd) *MockCmdableHSetNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHSetNXCall) DoAndReturn(f func(context.Context, string, string, any) *redis.BoolCmd) *MockCmdableHSetNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HStrLen mocks base method.
func (m *MockCmdable) HStrLen(ctx context.Context, key, field string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HStrLen", ctx, key, field)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// HStrLen indicates an expected call of HStrLen.
func (mr *MockCmdableMockRecorder) HStrLen(ctx, key, field any) *MockCmdableHStrLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HStrLen", reflect.TypeOf((*MockCmdable)(nil).HStrLen), ctx, key, field)
	return &MockCmdableHStrLenCall{Call: call}
}

// MockCmdableHStrLenCall wrap *gomock.Call
type MockCmdableHStrLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHStrLenCall) Return(arg0 *redis.IntCmd) *MockCmdableHStrLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHStrLenCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableHStrLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHStrLenCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableHStrLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HTTL mocks base method.
func (m *MockCmdable) HTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range fields {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HTTL", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// HTTL indicates an expected call of HTTL.
func (mr *MockCmdableMockRecorder) HTTL(ctx, key any, fields ...any) *MockCmdableHTTLCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, fields...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HTTL", reflect.TypeOf((*MockCmdable)(nil).HTTL), varargs...)
	return &MockCmdableHTTLCall{Call: call}
}

// MockCmdableHTTLCall wrap *gomock.Call
type MockCmdableHTTLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHTTLCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableHTTLCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHTTLCall) Do(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHTTLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHTTLCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntSliceCmd) *MockCmdableHTTLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HVals mocks base method.
func (m *MockCmdable) HVals(ctx context.Context, key string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HVals", ctx, key)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// HVals indicates an expected call of HVals.
func (mr *MockCmdableMockRecorder) HVals(ctx, key any) *MockCmdableHValsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HVals", reflect.TypeOf((*MockCmdable)(nil).HVals), ctx, key)
	return &MockCmdableHValsCall{Call: call}
}

// MockCmdableHValsCall wrap *gomock.Call
type MockCmdableHValsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableHValsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableHValsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableHValsCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableHValsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableHValsCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableHValsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Incr mocks base method.
func (m *MockCmdable) Incr(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Incr", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Incr indicates an expected call of Incr.
func (mr *MockCmdableMockRecorder) Incr(ctx, key any) *MockCmdableIncrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockCmdable)(nil).Incr), ctx, key)
	return &MockCmdableIncrCall{Call: call}
}

// MockCmdableIncrCall wrap *gomock.Call
type MockCmdableIncrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableIncrCall) Return(arg0 *redis.IntCmd) *MockCmdableIncrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableIncrCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableIncrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableIncrCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableIncrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IncrBy mocks base method.
func (m *MockCmdable) IncrBy(ctx context.Context, key string, value int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrBy", ctx, key, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// IncrBy indicates an expected call of IncrBy.
func (mr *MockCmdableMockRecorder) IncrBy(ctx, key, value any) *MockCmdableIncrByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrBy", reflect.TypeOf((*MockCmdable)(nil).IncrBy), ctx, key, value)
	return &MockCmdableIncrByCall{Call: call}
}

// MockCmdableIncrByCall wrap *gomock.Call
type MockCmdableIncrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableIncrByCall) Return(arg0 *redis.IntCmd) *MockCmdableIncrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableIncrByCall) Do(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableIncrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableIncrByCall) DoAndReturn(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableIncrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IncrByFloat mocks base method.
func (m *MockCmdable) IncrByFloat(ctx context.Context, key string, value float64) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrByFloat", ctx, key, value)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// IncrByFloat indicates an expected call of IncrByFloat.
func (mr *MockCmdableMockRecorder) IncrByFloat(ctx, key, value any) *MockCmdableIncrByFloatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrByFloat", reflect.TypeOf((*MockCmdable)(nil).IncrByFloat), ctx, key, value)
	return &MockCmdableIncrByFloatCall{Call: call}
}

// MockCmdableIncrByFloatCall wrap *gomock.Call
type MockCmdableIncrByFloatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableIncrByFloatCall) Return(arg0 *redis.FloatCmd) *MockCmdableIncrByFloatCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableIncrByFloatCall) Do(f func(context.Context, string, float64) *redis.FloatCmd) *MockCmdableIncrByFloatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableIncrByFloatCall) DoAndReturn(f func(context.Context, string, float64) *redis.FloatCmd) *MockCmdableIncrByFloatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Info mocks base method.
func (m *MockCmdable) Info(ctx context.Context, section ...string) *redis.StringCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range section {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Info", varargs...)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// Info indicates an expected call of Info.
func (mr *MockCmdableMockRecorder) Info(ctx any, section ...any) *MockCmdableInfoCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, section...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockCmdable)(nil).Info), varargs...)
	return &MockCmdableInfoCall{Call: call}
}

// MockCmdableInfoCall wrap *gomock.Call
type MockCmdableInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableInfoCall) Return(arg0 *redis.StringCmd) *MockCmdableInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableInfoCall) Do(f func(context.Context, ...string) *redis.StringCmd) *MockCmdableInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableInfoCall) DoAndReturn(f func(context.Context, ...string) *redis.StringCmd) *MockCmdableInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrAppend mocks base method.
func (m *MockCmdable) JSONArrAppend(ctx context.Context, key, path string, values ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, path}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONArrAppend", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// JSONArrAppend indicates an expected call of JSONArrAppend.
func (mr *MockCmdableMockRecorder) JSONArrAppend(ctx, key, path any, values ...any) *MockCmdableJSONArrAppendCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, path}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrAppend", reflect.TypeOf((*MockCmdable)(nil).JSONArrAppend), varargs...)
	return &MockCmdableJSONArrAppendCall{Call: call}
}

// MockCmdableJSONArrAppendCall wrap *gomock.Call
type MockCmdableJSONArrAppendCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrAppendCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableJSONArrAppendCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrAppendCall) Do(f func(context.Context, string, string, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrAppendCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrAppendCall) DoAndReturn(f func(context.Context, string, string, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrAppendCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrIndex mocks base method.
func (m *MockCmdable) JSONArrIndex(ctx context.Context, key, path string, value ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, path}
	for _, a := range value {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONArrIndex", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// JSONArrIndex indicates an expected call of JSONArrIndex.
func (mr *MockCmdableMockRecorder) JSONArrIndex(ctx, key, path any, value ...any) *MockCmdableJSONArrIndexCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, path}, value...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrIndex", reflect.TypeOf((*MockCmdable)(nil).JSONArrIndex), varargs...)
	return &MockCmdableJSONArrIndexCall{Call: call}
}

// MockCmdableJSONArrIndexCall wrap *gomock.Call
type MockCmdableJSONArrIndexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrIndexCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableJSONArrIndexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrIndexCall) Do(f func(context.Context, string, string, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrIndexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrIndexCall) DoAndReturn(f func(context.Context, string, string, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrIndexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrIndexWithArgs mocks base method.
func (m *MockCmdable) JSONArrIndexWithArgs(ctx context.Context, key, path string, options *redis.JSONArrIndexArgs, value ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, path, options}
	for _, a := range value {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONArrIndexWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// JSONArrIndexWithArgs indicates an expected call of JSONArrIndexWithArgs.
func (mr *MockCmdableMockRecorder) JSONArrIndexWithArgs(ctx, key, path, options any, value ...any) *MockCmdableJSONArrIndexWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, path, options}, value...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrIndexWithArgs", reflect.TypeOf((*MockCmdable)(nil).JSONArrIndexWithArgs), varargs...)
	return &MockCmdableJSONArrIndexWithArgsCall{Call: call}
}

// MockCmdableJSONArrIndexWithArgsCall wrap *gomock.Call
type MockCmdableJSONArrIndexWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrIndexWithArgsCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableJSONArrIndexWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrIndexWithArgsCall) Do(f func(context.Context, string, string, *redis.JSONArrIndexArgs, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrIndexWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrIndexWithArgsCall) DoAndReturn(f func(context.Context, string, string, *redis.JSONArrIndexArgs, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrIndexWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrInsert mocks base method.
func (m *MockCmdable) JSONArrInsert(ctx context.Context, key, path string, index int64, values ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, path, index}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONArrInsert", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// JSONArrInsert indicates an expected call of JSONArrInsert.
func (mr *MockCmdableMockRecorder) JSONArrInsert(ctx, key, path, index any, values ...any) *MockCmdableJSONArrInsertCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, path, index}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrInsert", reflect.TypeOf((*MockCmdable)(nil).JSONArrInsert), varargs...)
	return &MockCmdableJSONArrInsertCall{Call: call}
}

// MockCmdableJSONArrInsertCall wrap *gomock.Call
type MockCmdableJSONArrInsertCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrInsertCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableJSONArrInsertCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrInsertCall) Do(f func(context.Context, string, string, int64, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrInsertCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrInsertCall) DoAndReturn(f func(context.Context, string, string, int64, ...any) *redis.IntSliceCmd) *MockCmdableJSONArrInsertCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrLen mocks base method.
func (m *MockCmdable) JSONArrLen(ctx context.Context, key, path string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONArrLen", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// JSONArrLen indicates an expected call of JSONArrLen.
func (mr *MockCmdableMockRecorder) JSONArrLen(ctx, key, path any) *MockCmdableJSONArrLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrLen", reflect.TypeOf((*MockCmdable)(nil).JSONArrLen), ctx, key, path)
	return &MockCmdableJSONArrLenCall{Call: call}
}

// MockCmdableJSONArrLenCall wrap *gomock.Call
type MockCmdableJSONArrLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrLenCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableJSONArrLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrLenCall) Do(f func(context.Context, string, string) *redis.IntSliceCmd) *MockCmdableJSONArrLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrLenCall) DoAndReturn(f func(context.Context, string, string) *redis.IntSliceCmd) *MockCmdableJSONArrLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrPop mocks base method.
func (m *MockCmdable) JSONArrPop(ctx context.Context, key, path string, index int) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONArrPop", ctx, key, path, index)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// JSONArrPop indicates an expected call of JSONArrPop.
func (mr *MockCmdableMockRecorder) JSONArrPop(ctx, key, path, index any) *MockCmdableJSONArrPopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrPop", reflect.TypeOf((*MockCmdable)(nil).JSONArrPop), ctx, key, path, index)
	return &MockCmdableJSONArrPopCall{Call: call}
}

// MockCmdableJSONArrPopCall wrap *gomock.Call
type MockCmdableJSONArrPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrPopCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableJSONArrPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrPopCall) Do(f func(context.Context, string, string, int) *redis.StringSliceCmd) *MockCmdableJSONArrPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrPopCall) DoAndReturn(f func(context.Context, string, string, int) *redis.StringSliceCmd) *MockCmdableJSONArrPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrTrim mocks base method.
func (m *MockCmdable) JSONArrTrim(ctx context.Context, key, path string) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONArrTrim", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// JSONArrTrim indicates an expected call of JSONArrTrim.
func (mr *MockCmdableMockRecorder) JSONArrTrim(ctx, key, path any) *MockCmdableJSONArrTrimCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrTrim", reflect.TypeOf((*MockCmdable)(nil).JSONArrTrim), ctx, key, path)
	return &MockCmdableJSONArrTrimCall{Call: call}
}

// MockCmdableJSONArrTrimCall wrap *gomock.Call
type MockCmdableJSONArrTrimCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrTrimCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableJSONArrTrimCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrTrimCall) Do(f func(context.Context, string, string) *redis.IntSliceCmd) *MockCmdableJSONArrTrimCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrTrimCall) DoAndReturn(f func(context.Context, string, string) *redis.IntSliceCmd) *MockCmdableJSONArrTrimCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONArrTrimWithArgs mocks base method.
func (m *MockCmdable) JSONArrTrimWithArgs(ctx context.Context, key, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONArrTrimWithArgs", ctx, key, path, options)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// JSONArrTrimWithArgs indicates an expected call of JSONArrTrimWithArgs.
func (mr *MockCmdableMockRecorder) JSONArrTrimWithArgs(ctx, key, path, options any) *MockCmdableJSONArrTrimWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONArrTrimWithArgs", reflect.TypeOf((*MockCmdable)(nil).JSONArrTrimWithArgs), ctx, key, path, options)
	return &MockCmdableJSONArrTrimWithArgsCall{Call: call}
}

// MockCmdableJSONArrTrimWithArgsCall wrap *gomock.Call
type MockCmdableJSONArrTrimWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONArrTrimWithArgsCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableJSONArrTrimWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONArrTrimWithArgsCall) Do(f func(context.Context, string, string, *redis.JSONArrTrimArgs) *redis.IntSliceCmd) *MockCmdableJSONArrTrimWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONArrTrimWithArgsCall) DoAndReturn(f func(context.Context, string, string, *redis.JSONArrTrimArgs) *redis.IntSliceCmd) *MockCmdableJSONArrTrimWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONClear mocks base method.
func (m *MockCmdable) JSONClear(ctx context.Context, key, path string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONClear", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// JSONClear indicates an expected call of JSONClear.
func (mr *MockCmdableMockRecorder) JSONClear(ctx, key, path any) *MockCmdableJSONClearCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONClear", reflect.TypeOf((*MockCmdable)(nil).JSONClear), ctx, key, path)
	return &MockCmdableJSONClearCall{Call: call}
}

// MockCmdableJSONClearCall wrap *gomock.Call
type MockCmdableJSONClearCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONClearCall) Return(arg0 *redis.IntCmd) *MockCmdableJSONClearCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONClearCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONClearCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONClearCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONClearCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONDebugMemory mocks base method.
func (m *MockCmdable) JSONDebugMemory(ctx context.Context, key, path string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONDebugMemory", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// JSONDebugMemory indicates an expected call of JSONDebugMemory.
func (mr *MockCmdableMockRecorder) JSONDebugMemory(ctx, key, path any) *MockCmdableJSONDebugMemoryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONDebugMemory", reflect.TypeOf((*MockCmdable)(nil).JSONDebugMemory), ctx, key, path)
	return &MockCmdableJSONDebugMemoryCall{Call: call}
}

// MockCmdableJSONDebugMemoryCall wrap *gomock.Call
type MockCmdableJSONDebugMemoryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONDebugMemoryCall) Return(arg0 *redis.IntCmd) *MockCmdableJSONDebugMemoryCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONDebugMemoryCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONDebugMemoryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONDebugMemoryCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONDebugMemoryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONDel mocks base method.
func (m *MockCmdable) JSONDel(ctx context.Context, key, path string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONDel", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// JSONDel indicates an expected call of JSONDel.
func (mr *MockCmdableMockRecorder) JSONDel(ctx, key, path any) *MockCmdableJSONDelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONDel", reflect.TypeOf((*MockCmdable)(nil).JSONDel), ctx, key, path)
	return &MockCmdableJSONDelCall{Call: call}
}

// MockCmdableJSONDelCall wrap *gomock.Call
type MockCmdableJSONDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONDelCall) Return(arg0 *redis.IntCmd) *MockCmdableJSONDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONDelCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONDelCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONForget mocks base method.
func (m *MockCmdable) JSONForget(ctx context.Context, key, path string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONForget", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// JSONForget indicates an expected call of JSONForget.
func (mr *MockCmdableMockRecorder) JSONForget(ctx, key, path any) *MockCmdableJSONForgetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONForget", reflect.TypeOf((*MockCmdable)(nil).JSONForget), ctx, key, path)
	return &MockCmdableJSONForgetCall{Call: call}
}

// MockCmdableJSONForgetCall wrap *gomock.Call
type MockCmdableJSONForgetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONForgetCall) Return(arg0 *redis.IntCmd) *MockCmdableJSONForgetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONForgetCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONForgetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONForgetCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableJSONForgetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONGet mocks base method.
func (m *MockCmdable) JSONGet(ctx context.Context, key string, paths ...string) *redis.JSONCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range paths {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONGet", varargs...)
	ret0, _ := ret[0].(*redis.JSONCmd)
	return ret0
}

// JSONGet indicates an expected call of JSONGet.
func (mr *MockCmdableMockRecorder) JSONGet(ctx, key any, paths ...any) *MockCmdableJSONGetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, paths...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONGet", reflect.TypeOf((*MockCmdable)(nil).JSONGet), varargs...)
	return &MockCmdableJSONGetCall{Call: call}
}

// MockCmdableJSONGetCall wrap *gomock.Call
type MockCmdableJSONGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONGetCall) Return(arg0 *redis.JSONCmd) *MockCmdableJSONGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONGetCall) Do(f func(context.Context, string, ...string) *redis.JSONCmd) *MockCmdableJSONGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONGetCall) DoAndReturn(f func(context.Context, string, ...string) *redis.JSONCmd) *MockCmdableJSONGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONGetWithArgs mocks base method.
func (m *MockCmdable) JSONGetWithArgs(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key, options}
	for _, a := range paths {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONGetWithArgs", varargs...)
	ret0, _ := ret[0].(*redis.JSONCmd)
	return ret0
}

// JSONGetWithArgs indicates an expected call of JSONGetWithArgs.
func (mr *MockCmdableMockRecorder) JSONGetWithArgs(ctx, key, options any, paths ...any) *MockCmdableJSONGetWithArgsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key, options}, paths...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONGetWithArgs", reflect.TypeOf((*MockCmdable)(nil).JSONGetWithArgs), varargs...)
	return &MockCmdableJSONGetWithArgsCall{Call: call}
}

// MockCmdableJSONGetWithArgsCall wrap *gomock.Call
type MockCmdableJSONGetWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONGetWithArgsCall) Return(arg0 *redis.JSONCmd) *MockCmdableJSONGetWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONGetWithArgsCall) Do(f func(context.Context, string, *redis.JSONGetArgs, ...string) *redis.JSONCmd) *MockCmdableJSONGetWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONGetWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.JSONGetArgs, ...string) *redis.JSONCmd) *MockCmdableJSONGetWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONMGet mocks base method.
func (m *MockCmdable) JSONMGet(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, path}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONMGet", varargs...)
	ret0, _ := ret[0].(*redis.JSONSliceCmd)
	return ret0
}

// JSONMGet indicates an expected call of JSONMGet.
func (mr *MockCmdableMockRecorder) JSONMGet(ctx, path any, keys ...any) *MockCmdableJSONMGetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, path}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONMGet", reflect.TypeOf((*MockCmdable)(nil).JSONMGet), varargs...)
	return &MockCmdableJSONMGetCall{Call: call}
}

// MockCmdableJSONMGetCall wrap *gomock.Call
type MockCmdableJSONMGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONMGetCall) Return(arg0 *redis.JSONSliceCmd) *MockCmdableJSONMGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONMGetCall) Do(f func(context.Context, string, ...string) *redis.JSONSliceCmd) *MockCmdableJSONMGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONMGetCall) DoAndReturn(f func(context.Context, string, ...string) *redis.JSONSliceCmd) *MockCmdableJSONMGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONMSet mocks base method.
func (m *MockCmdable) JSONMSet(ctx context.Context, params ...any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "JSONMSet", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// JSONMSet indicates an expected call of JSONMSet.
func (mr *MockCmdableMockRecorder) JSONMSet(ctx any, params ...any) *MockCmdableJSONMSetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, params...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONMSet", reflect.TypeOf((*MockCmdable)(nil).JSONMSet), varargs...)
	return &MockCmdableJSONMSetCall{Call: call}
}

// MockCmdableJSONMSetCall wrap *gomock.Call
type MockCmdableJSONMSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONMSetCall) Return(arg0 *redis.StatusCmd) *MockCmdableJSONMSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONMSetCall) Do(f func(context.Context, ...any) *redis.StatusCmd) *MockCmdableJSONMSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONMSetCall) DoAndReturn(f func(context.Context, ...any) *redis.StatusCmd) *MockCmdableJSONMSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONMSetArgs mocks base method.
func (m *MockCmdable) JSONMSetArgs(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONMSetArgs", ctx, docs)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// JSONMSetArgs indicates an expected call of JSONMSetArgs.
func (mr *MockCmdableMockRecorder) JSONMSetArgs(ctx, docs any) *MockCmdableJSONMSetArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONMSetArgs", reflect.TypeOf((*MockCmdable)(nil).JSONMSetArgs), ctx, docs)
	return &MockCmdableJSONMSetArgsCall{Call: call}
}

// MockCmdableJSONMSetArgsCall wrap *gomock.Call
type MockCmdableJSONMSetArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONMSetArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableJSONMSetArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONMSetArgsCall) Do(f func(context.Context, []redis.JSONSetArgs) *redis.StatusCmd) *MockCmdableJSONMSetArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONMSetArgsCall) DoAndReturn(f func(context.Context, []redis.JSONSetArgs) *redis.StatusCmd) *MockCmdableJSONMSetArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONMerge mocks base method.
func (m *MockCmdable) JSONMerge(ctx context.Context, key, path, value string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONMerge", ctx, key, path, value)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// JSONMerge indicates an expected call of JSONMerge.
func (mr *MockCmdableMockRecorder) JSONMerge(ctx, key, path, value any) *MockCmdableJSONMergeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONMerge", reflect.TypeOf((*MockCmdable)(nil).JSONMerge), ctx, key, path, value)
	return &MockCmdableJSONMergeCall{Call: call}
}

// MockCmdableJSONMergeCall wrap *gomock.Call
type MockCmdableJSONMergeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONMergeCall) Return(arg0 *redis.StatusCmd) *MockCmdableJSONMergeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONMergeCall) Do(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableJSONMergeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONMergeCall) DoAndReturn(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableJSONMergeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONNumIncrBy mocks base method.
func (m *MockCmdable) JSONNumIncrBy(ctx context.Context, key, path string, value float64) *redis.JSONCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONNumIncrBy", ctx, key, path, value)
	ret0, _ := ret[0].(*redis.JSONCmd)
	return ret0
}

// JSONNumIncrBy indicates an expected call of JSONNumIncrBy.
func (mr *MockCmdableMockRecorder) JSONNumIncrBy(ctx, key, path, value any) *MockCmdableJSONNumIncrByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONNumIncrBy", reflect.TypeOf((*MockCmdable)(nil).JSONNumIncrBy), ctx, key, path, value)
	return &MockCmdableJSONNumIncrByCall{Call: call}
}

// MockCmdableJSONNumIncrByCall wrap *gomock.Call
type MockCmdableJSONNumIncrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONNumIncrByCall) Return(arg0 *redis.JSONCmd) *MockCmdableJSONNumIncrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONNumIncrByCall) Do(f func(context.Context, string, string, float64) *redis.JSONCmd) *MockCmdableJSONNumIncrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONNumIncrByCall) DoAndReturn(f func(context.Context, string, string, float64) *redis.JSONCmd) *MockCmdableJSONNumIncrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONObjKeys mocks base method.
func (m *MockCmdable) JSONObjKeys(ctx context.Context, key, path string) *redis.SliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONObjKeys", ctx, key, path)
	ret0, _ := ret[0].(*redis.SliceCmd)
	return ret0
}

// JSONObjKeys indicates an expected call of JSONObjKeys.
func (mr *MockCmdableMockRecorder) JSONObjKeys(ctx, key, path any) *MockCmdableJSONObjKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONObjKeys", reflect.TypeOf((*MockCmdable)(nil).JSONObjKeys), ctx, key, path)
	return &MockCmdableJSONObjKeysCall{Call: call}
}

// MockCmdableJSONObjKeysCall wrap *gomock.Call
type MockCmdableJSONObjKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONObjKeysCall) Return(arg0 *redis.SliceCmd) *MockCmdableJSONObjKeysCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONObjKeysCall) Do(f func(context.Context, string, string) *redis.SliceCmd) *MockCmdableJSONObjKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONObjKeysCall) DoAndReturn(f func(context.Context, string, string) *redis.SliceCmd) *MockCmdableJSONObjKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONObjLen mocks base method.
func (m *MockCmdable) JSONObjLen(ctx context.Context, key, path string) *redis.IntPointerSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONObjLen", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntPointerSliceCmd)
	return ret0
}

// JSONObjLen indicates an expected call of JSONObjLen.
func (mr *MockCmdableMockRecorder) JSONObjLen(ctx, key, path any) *MockCmdableJSONObjLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONObjLen", reflect.TypeOf((*MockCmdable)(nil).JSONObjLen), ctx, key, path)
	return &MockCmdableJSONObjLenCall{Call: call}
}

// MockCmdableJSONObjLenCall wrap *gomock.Call
type MockCmdableJSONObjLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONObjLenCall) Return(arg0 *redis.IntPointerSliceCmd) *MockCmdableJSONObjLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONObjLenCall) Do(f func(context.Context, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONObjLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONObjLenCall) DoAndReturn(f func(context.Context, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONObjLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONSet mocks base method.
func (m *MockCmdable) JSONSet(ctx context.Context, key, path string, value any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONSet", ctx, key, path, value)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// JSONSet indicates an expected call of JSONSet.
func (mr *MockCmdableMockRecorder) JSONSet(ctx, key, path, value any) *MockCmdableJSONSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONSet", reflect.TypeOf((*MockCmdable)(nil).JSONSet), ctx, key, path, value)
	return &MockCmdableJSONSetCall{Call: call}
}

// MockCmdableJSONSetCall wrap *gomock.Call
type MockCmdableJSONSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONSetCall) Return(arg0 *redis.StatusCmd) *MockCmdableJSONSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONSetCall) Do(f func(context.Context, string, string, any) *redis.StatusCmd) *MockCmdableJSONSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONSetCall) DoAndReturn(f func(context.Context, string, string, any) *redis.StatusCmd) *MockCmdableJSONSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONSetMode mocks base method.
func (m *MockCmdable) JSONSetMode(ctx context.Context, key, path string, value any, mode string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONSetMode", ctx, key, path, value, mode)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// JSONSetMode indicates an expected call of JSONSetMode.
func (mr *MockCmdableMockRecorder) JSONSetMode(ctx, key, path, value, mode any) *MockCmdableJSONSetModeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONSetMode", reflect.TypeOf((*MockCmdable)(nil).JSONSetMode), ctx, key, path, value, mode)
	return &MockCmdableJSONSetModeCall{Call: call}
}

// MockCmdableJSONSetModeCall wrap *gomock.Call
type MockCmdableJSONSetModeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONSetModeCall) Return(arg0 *redis.StatusCmd) *MockCmdableJSONSetModeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONSetModeCall) Do(f func(context.Context, string, string, any, string) *redis.StatusCmd) *MockCmdableJSONSetModeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONSetModeCall) DoAndReturn(f func(context.Context, string, string, any, string) *redis.StatusCmd) *MockCmdableJSONSetModeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONStrAppend mocks base method.
func (m *MockCmdable) JSONStrAppend(ctx context.Context, key, path, value string) *redis.IntPointerSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONStrAppend", ctx, key, path, value)
	ret0, _ := ret[0].(*redis.IntPointerSliceCmd)
	return ret0
}

// JSONStrAppend indicates an expected call of JSONStrAppend.
func (mr *MockCmdableMockRecorder) JSONStrAppend(ctx, key, path, value any) *MockCmdableJSONStrAppendCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONStrAppend", reflect.TypeOf((*MockCmdable)(nil).JSONStrAppend), ctx, key, path, value)
	return &MockCmdableJSONStrAppendCall{Call: call}
}

// MockCmdableJSONStrAppendCall wrap *gomock.Call
type MockCmdableJSONStrAppendCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONStrAppendCall) Return(arg0 *redis.IntPointerSliceCmd) *MockCmdableJSONStrAppendCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONStrAppendCall) Do(f func(context.Context, string, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONStrAppendCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONStrAppendCall) DoAndReturn(f func(context.Context, string, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONStrAppendCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONStrLen mocks base method.
func (m *MockCmdable) JSONStrLen(ctx context.Context, key, path string) *redis.IntPointerSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONStrLen", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntPointerSliceCmd)
	return ret0
}

// JSONStrLen indicates an expected call of JSONStrLen.
func (mr *MockCmdableMockRecorder) JSONStrLen(ctx, key, path any) *MockCmdableJSONStrLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONStrLen", reflect.TypeOf((*MockCmdable)(nil).JSONStrLen), ctx, key, path)
	return &MockCmdableJSONStrLenCall{Call: call}
}

// MockCmdableJSONStrLenCall wrap *gomock.Call
type MockCmdableJSONStrLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONStrLenCall) Return(arg0 *redis.IntPointerSliceCmd) *MockCmdableJSONStrLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONStrLenCall) Do(f func(context.Context, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONStrLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONStrLenCall) DoAndReturn(f func(context.Context, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONStrLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONToggle mocks base method.
func (m *MockCmdable) JSONToggle(ctx context.Context, key, path string) *redis.IntPointerSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONToggle", ctx, key, path)
	ret0, _ := ret[0].(*redis.IntPointerSliceCmd)
	return ret0
}

// JSONToggle indicates an expected call of JSONToggle.
func (mr *MockCmdableMockRecorder) JSONToggle(ctx, key, path any) *MockCmdableJSONToggleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONToggle", reflect.TypeOf((*MockCmdable)(nil).JSONToggle), ctx, key, path)
	return &MockCmdableJSONToggleCall{Call: call}
}

// MockCmdableJSONToggleCall wrap *gomock.Call
type MockCmdableJSONToggleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONToggleCall) Return(arg0 *redis.IntPointerSliceCmd) *MockCmdableJSONToggleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONToggleCall) Do(f func(context.Context, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONToggleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONToggleCall) DoAndReturn(f func(context.Context, string, string) *redis.IntPointerSliceCmd) *MockCmdableJSONToggleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// JSONType mocks base method.
func (m *MockCmdable) JSONType(ctx context.Context, key, path string) *redis.JSONSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "JSONType", ctx, key, path)
	ret0, _ := ret[0].(*redis.JSONSliceCmd)
	return ret0
}

// JSONType indicates an expected call of JSONType.
func (mr *MockCmdableMockRecorder) JSONType(ctx, key, path any) *MockCmdableJSONTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "JSONType", reflect.TypeOf((*MockCmdable)(nil).JSONType), ctx, key, path)
	return &MockCmdableJSONTypeCall{Call: call}
}

// MockCmdableJSONTypeCall wrap *gomock.Call
type MockCmdableJSONTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableJSONTypeCall) Return(arg0 *redis.JSONSliceCmd) *MockCmdableJSONTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableJSONTypeCall) Do(f func(context.Context, string, string) *redis.JSONSliceCmd) *MockCmdableJSONTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableJSONTypeCall) DoAndReturn(f func(context.Context, string, string) *redis.JSONSliceCmd) *MockCmdableJSONTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Keys mocks base method.
func (m *MockCmdable) Keys(ctx context.Context, pattern string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Keys", ctx, pattern)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// Keys indicates an expected call of Keys.
func (mr *MockCmdableMockRecorder) Keys(ctx, pattern any) *MockCmdableKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Keys", reflect.TypeOf((*MockCmdable)(nil).Keys), ctx, pattern)
	return &MockCmdableKeysCall{Call: call}
}

// MockCmdableKeysCall wrap *gomock.Call
type MockCmdableKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableKeysCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableKeysCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableKeysCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableKeysCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LCS mocks base method.
func (m *MockCmdable) LCS(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LCS", ctx, q)
	ret0, _ := ret[0].(*redis.LCSCmd)
	return ret0
}

// LCS indicates an expected call of LCS.
func (mr *MockCmdableMockRecorder) LCS(ctx, q any) *MockCmdableLCSCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LCS", reflect.TypeOf((*MockCmdable)(nil).LCS), ctx, q)
	return &MockCmdableLCSCall{Call: call}
}

// MockCmdableLCSCall wrap *gomock.Call
type MockCmdableLCSCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLCSCall) Return(arg0 *redis.LCSCmd) *MockCmdableLCSCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLCSCall) Do(f func(context.Context, *redis.LCSQuery) *redis.LCSCmd) *MockCmdableLCSCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLCSCall) DoAndReturn(f func(context.Context, *redis.LCSQuery) *redis.LCSCmd) *MockCmdableLCSCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LIndex mocks base method.
func (m *MockCmdable) LIndex(ctx context.Context, key string, index int64) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LIndex", ctx, key, index)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// LIndex indicates an expected call of LIndex.
func (mr *MockCmdableMockRecorder) LIndex(ctx, key, index any) *MockCmdableLIndexCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LIndex", reflect.TypeOf((*MockCmdable)(nil).LIndex), ctx, key, index)
	return &MockCmdableLIndexCall{Call: call}
}

// MockCmdableLIndexCall wrap *gomock.Call
type MockCmdableLIndexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLIndexCall) Return(arg0 *redis.StringCmd) *MockCmdableLIndexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLIndexCall) Do(f func(context.Context, string, int64) *redis.StringCmd) *MockCmdableLIndexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLIndexCall) DoAndReturn(f func(context.Context, string, int64) *redis.StringCmd) *MockCmdableLIndexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LInsert mocks base method.
func (m *MockCmdable) LInsert(ctx context.Context, key, op string, pivot, value any) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LInsert", ctx, key, op, pivot, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LInsert indicates an expected call of LInsert.
func (mr *MockCmdableMockRecorder) LInsert(ctx, key, op, pivot, value any) *MockCmdableLInsertCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LInsert", reflect.TypeOf((*MockCmdable)(nil).LInsert), ctx, key, op, pivot, value)
	return &MockCmdableLInsertCall{Call: call}
}

// MockCmdableLInsertCall wrap *gomock.Call
type MockCmdableLInsertCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLInsertCall) Return(arg0 *redis.IntCmd) *MockCmdableLInsertCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLInsertCall) Do(f func(context.Context, string, string, any, any) *redis.IntCmd) *MockCmdableLInsertCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLInsertCall) DoAndReturn(f func(context.Context, string, string, any, any) *redis.IntCmd) *MockCmdableLInsertCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LInsertAfter mocks base method.
func (m *MockCmdable) LInsertAfter(ctx context.Context, key string, pivot, value any) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LInsertAfter", ctx, key, pivot, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LInsertAfter indicates an expected call of LInsertAfter.
func (mr *MockCmdableMockRecorder) LInsertAfter(ctx, key, pivot, value any) *MockCmdableLInsertAfterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LInsertAfter", reflect.TypeOf((*MockCmdable)(nil).LInsertAfter), ctx, key, pivot, value)
	return &MockCmdableLInsertAfterCall{Call: call}
}

// MockCmdableLInsertAfterCall wrap *gomock.Call
type MockCmdableLInsertAfterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLInsertAfterCall) Return(arg0 *redis.IntCmd) *MockCmdableLInsertAfterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLInsertAfterCall) Do(f func(context.Context, string, any, any) *redis.IntCmd) *MockCmdableLInsertAfterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLInsertAfterCall) DoAndReturn(f func(context.Context, string, any, any) *redis.IntCmd) *MockCmdableLInsertAfterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LInsertBefore mocks base method.
func (m *MockCmdable) LInsertBefore(ctx context.Context, key string, pivot, value any) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LInsertBefore", ctx, key, pivot, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LInsertBefore indicates an expected call of LInsertBefore.
func (mr *MockCmdableMockRecorder) LInsertBefore(ctx, key, pivot, value any) *MockCmdableLInsertBeforeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LInsertBefore", reflect.TypeOf((*MockCmdable)(nil).LInsertBefore), ctx, key, pivot, value)
	return &MockCmdableLInsertBeforeCall{Call: call}
}

// MockCmdableLInsertBeforeCall wrap *gomock.Call
type MockCmdableLInsertBeforeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLInsertBeforeCall) Return(arg0 *redis.IntCmd) *MockCmdableLInsertBeforeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLInsertBeforeCall) Do(f func(context.Context, string, any, any) *redis.IntCmd) *MockCmdableLInsertBeforeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLInsertBeforeCall) DoAndReturn(f func(context.Context, string, any, any) *redis.IntCmd) *MockCmdableLInsertBeforeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LLen mocks base method.
func (m *MockCmdable) LLen(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LLen", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LLen indicates an expected call of LLen.
func (mr *MockCmdableMockRecorder) LLen(ctx, key any) *MockCmdableLLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LLen", reflect.TypeOf((*MockCmdable)(nil).LLen), ctx, key)
	return &MockCmdableLLenCall{Call: call}
}

// MockCmdableLLenCall wrap *gomock.Call
type MockCmdableLLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLLenCall) Return(arg0 *redis.IntCmd) *MockCmdableLLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLLenCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableLLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLLenCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableLLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LMPop mocks base method.
func (m *MockCmdable) LMPop(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, direction, count}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LMPop", varargs...)
	ret0, _ := ret[0].(*redis.KeyValuesCmd)
	return ret0
}

// LMPop indicates an expected call of LMPop.
func (mr *MockCmdableMockRecorder) LMPop(ctx, direction, count any, keys ...any) *MockCmdableLMPopCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, direction, count}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LMPop", reflect.TypeOf((*MockCmdable)(nil).LMPop), varargs...)
	return &MockCmdableLMPopCall{Call: call}
}

// MockCmdableLMPopCall wrap *gomock.Call
type MockCmdableLMPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLMPopCall) Return(arg0 *redis.KeyValuesCmd) *MockCmdableLMPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLMPopCall) Do(f func(context.Context, string, int64, ...string) *redis.KeyValuesCmd) *MockCmdableLMPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLMPopCall) DoAndReturn(f func(context.Context, string, int64, ...string) *redis.KeyValuesCmd) *MockCmdableLMPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LMove mocks base method.
func (m *MockCmdable) LMove(ctx context.Context, source, destination, srcpos, destpos string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LMove", ctx, source, destination, srcpos, destpos)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// LMove indicates an expected call of LMove.
func (mr *MockCmdableMockRecorder) LMove(ctx, source, destination, srcpos, destpos any) *MockCmdableLMoveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LMove", reflect.TypeOf((*MockCmdable)(nil).LMove), ctx, source, destination, srcpos, destpos)
	return &MockCmdableLMoveCall{Call: call}
}

// MockCmdableLMoveCall wrap *gomock.Call
type MockCmdableLMoveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLMoveCall) Return(arg0 *redis.StringCmd) *MockCmdableLMoveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLMoveCall) Do(f func(context.Context, string, string, string, string) *redis.StringCmd) *MockCmdableLMoveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLMoveCall) DoAndReturn(f func(context.Context, string, string, string, string) *redis.StringCmd) *MockCmdableLMoveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LPop mocks base method.
func (m *MockCmdable) LPop(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LPop", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// LPop indicates an expected call of LPop.
func (mr *MockCmdableMockRecorder) LPop(ctx, key any) *MockCmdableLPopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPop", reflect.TypeOf((*MockCmdable)(nil).LPop), ctx, key)
	return &MockCmdableLPopCall{Call: call}
}

// MockCmdableLPopCall wrap *gomock.Call
type MockCmdableLPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLPopCall) Return(arg0 *redis.StringCmd) *MockCmdableLPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLPopCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableLPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLPopCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableLPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LPopCount mocks base method.
func (m *MockCmdable) LPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LPopCount", ctx, key, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// LPopCount indicates an expected call of LPopCount.
func (mr *MockCmdableMockRecorder) LPopCount(ctx, key, count any) *MockCmdableLPopCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPopCount", reflect.TypeOf((*MockCmdable)(nil).LPopCount), ctx, key, count)
	return &MockCmdableLPopCountCall{Call: call}
}

// MockCmdableLPopCountCall wrap *gomock.Call
type MockCmdableLPopCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLPopCountCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableLPopCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLPopCountCall) Do(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableLPopCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLPopCountCall) DoAndReturn(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableLPopCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LPos mocks base method.
func (m *MockCmdable) LPos(ctx context.Context, key, value string, args redis.LPosArgs) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LPos", ctx, key, value, args)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LPos indicates an expected call of LPos.
func (mr *MockCmdableMockRecorder) LPos(ctx, key, value, args any) *MockCmdableLPosCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPos", reflect.TypeOf((*MockCmdable)(nil).LPos), ctx, key, value, args)
	return &MockCmdableLPosCall{Call: call}
}

// MockCmdableLPosCall wrap *gomock.Call
type MockCmdableLPosCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLPosCall) Return(arg0 *redis.IntCmd) *MockCmdableLPosCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLPosCall) Do(f func(context.Context, string, string, redis.LPosArgs) *redis.IntCmd) *MockCmdableLPosCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLPosCall) DoAndReturn(f func(context.Context, string, string, redis.LPosArgs) *redis.IntCmd) *MockCmdableLPosCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LPosCount mocks base method.
func (m *MockCmdable) LPosCount(ctx context.Context, key, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LPosCount", ctx, key, value, count, args)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// LPosCount indicates an expected call of LPosCount.
func (mr *MockCmdableMockRecorder) LPosCount(ctx, key, value, count, args any) *MockCmdableLPosCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPosCount", reflect.TypeOf((*MockCmdable)(nil).LPosCount), ctx, key, value, count, args)
	return &MockCmdableLPosCountCall{Call: call}
}

// MockCmdableLPosCountCall wrap *gomock.Call
type MockCmdableLPosCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLPosCountCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableLPosCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLPosCountCall) Do(f func(context.Context, string, string, int64, redis.LPosArgs) *redis.IntSliceCmd) *MockCmdableLPosCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLPosCountCall) DoAndReturn(f func(context.Context, string, string, int64, redis.LPosArgs) *redis.IntSliceCmd) *MockCmdableLPosCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LPush mocks base method.
func (m *MockCmdable) LPush(ctx context.Context, key string, values ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LPush", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LPush indicates an expected call of LPush.
func (mr *MockCmdableMockRecorder) LPush(ctx, key any, values ...any) *MockCmdableLPushCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPush", reflect.TypeOf((*MockCmdable)(nil).LPush), varargs...)
	return &MockCmdableLPushCall{Call: call}
}

// MockCmdableLPushCall wrap *gomock.Call
type MockCmdableLPushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLPushCall) Return(arg0 *redis.IntCmd) *MockCmdableLPushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLPushCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableLPushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLPushCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableLPushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LPushX mocks base method.
func (m *MockCmdable) LPushX(ctx context.Context, key string, values ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LPushX", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LPushX indicates an expected call of LPushX.
func (mr *MockCmdableMockRecorder) LPushX(ctx, key any, values ...any) *MockCmdableLPushXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LPushX", reflect.TypeOf((*MockCmdable)(nil).LPushX), varargs...)
	return &MockCmdableLPushXCall{Call: call}
}

// MockCmdableLPushXCall wrap *gomock.Call
type MockCmdableLPushXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLPushXCall) Return(arg0 *redis.IntCmd) *MockCmdableLPushXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLPushXCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableLPushXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLPushXCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableLPushXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LRange mocks base method.
func (m *MockCmdable) LRange(ctx context.Context, key string, start, stop int64) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LRange", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// LRange indicates an expected call of LRange.
func (mr *MockCmdableMockRecorder) LRange(ctx, key, start, stop any) *MockCmdableLRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LRange", reflect.TypeOf((*MockCmdable)(nil).LRange), ctx, key, start, stop)
	return &MockCmdableLRangeCall{Call: call}
}

// MockCmdableLRangeCall wrap *gomock.Call
type MockCmdableLRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLRangeCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableLRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLRangeCall) Do(f func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockCmdableLRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLRangeCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockCmdableLRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LRem mocks base method.
func (m *MockCmdable) LRem(ctx context.Context, key string, count int64, value any) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LRem", ctx, key, count, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LRem indicates an expected call of LRem.
func (mr *MockCmdableMockRecorder) LRem(ctx, key, count, value any) *MockCmdableLRemCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LRem", reflect.TypeOf((*MockCmdable)(nil).LRem), ctx, key, count, value)
	return &MockCmdableLRemCall{Call: call}
}

// MockCmdableLRemCall wrap *gomock.Call
type MockCmdableLRemCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLRemCall) Return(arg0 *redis.IntCmd) *MockCmdableLRemCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLRemCall) Do(f func(context.Context, string, int64, any) *redis.IntCmd) *MockCmdableLRemCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLRemCall) DoAndReturn(f func(context.Context, string, int64, any) *redis.IntCmd) *MockCmdableLRemCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LSet mocks base method.
func (m *MockCmdable) LSet(ctx context.Context, key string, index int64, value any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LSet", ctx, key, index, value)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// LSet indicates an expected call of LSet.
func (mr *MockCmdableMockRecorder) LSet(ctx, key, index, value any) *MockCmdableLSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LSet", reflect.TypeOf((*MockCmdable)(nil).LSet), ctx, key, index, value)
	return &MockCmdableLSetCall{Call: call}
}

// MockCmdableLSetCall wrap *gomock.Call
type MockCmdableLSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLSetCall) Return(arg0 *redis.StatusCmd) *MockCmdableLSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLSetCall) Do(f func(context.Context, string, int64, any) *redis.StatusCmd) *MockCmdableLSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLSetCall) DoAndReturn(f func(context.Context, string, int64, any) *redis.StatusCmd) *MockCmdableLSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LTrim mocks base method.
func (m *MockCmdable) LTrim(ctx context.Context, key string, start, stop int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LTrim", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// LTrim indicates an expected call of LTrim.
func (mr *MockCmdableMockRecorder) LTrim(ctx, key, start, stop any) *MockCmdableLTrimCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LTrim", reflect.TypeOf((*MockCmdable)(nil).LTrim), ctx, key, start, stop)
	return &MockCmdableLTrimCall{Call: call}
}

// MockCmdableLTrimCall wrap *gomock.Call
type MockCmdableLTrimCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLTrimCall) Return(arg0 *redis.StatusCmd) *MockCmdableLTrimCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLTrimCall) Do(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableLTrimCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLTrimCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StatusCmd) *MockCmdableLTrimCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LastSave mocks base method.
func (m *MockCmdable) LastSave(ctx context.Context) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastSave", ctx)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// LastSave indicates an expected call of LastSave.
func (mr *MockCmdableMockRecorder) LastSave(ctx any) *MockCmdableLastSaveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastSave", reflect.TypeOf((*MockCmdable)(nil).LastSave), ctx)
	return &MockCmdableLastSaveCall{Call: call}
}

// MockCmdableLastSaveCall wrap *gomock.Call
type MockCmdableLastSaveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableLastSaveCall) Return(arg0 *redis.IntCmd) *MockCmdableLastSaveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableLastSaveCall) Do(f func(context.Context) *redis.IntCmd) *MockCmdableLastSaveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableLastSaveCall) DoAndReturn(f func(context.Context) *redis.IntCmd) *MockCmdableLastSaveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MGet mocks base method.
func (m *MockCmdable) MGet(ctx context.Context, keys ...string) *redis.SliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MGet", varargs...)
	ret0, _ := ret[0].(*redis.SliceCmd)
	return ret0
}

// MGet indicates an expected call of MGet.
func (mr *MockCmdableMockRecorder) MGet(ctx any, keys ...any) *MockCmdableMGetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGet", reflect.TypeOf((*MockCmdable)(nil).MGet), varargs...)
	return &MockCmdableMGetCall{Call: call}
}

// MockCmdableMGetCall wrap *gomock.Call
type MockCmdableMGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableMGetCall) Return(arg0 *redis.SliceCmd) *MockCmdableMGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableMGetCall) Do(f func(context.Context, ...string) *redis.SliceCmd) *MockCmdableMGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableMGetCall) DoAndReturn(f func(context.Context, ...string) *redis.SliceCmd) *MockCmdableMGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MSet mocks base method.
func (m *MockCmdable) MSet(ctx context.Context, values ...any) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MSet", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// MSet indicates an expected call of MSet.
func (mr *MockCmdableMockRecorder) MSet(ctx any, values ...any) *MockCmdableMSetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSet", reflect.TypeOf((*MockCmdable)(nil).MSet), varargs...)
	return &MockCmdableMSetCall{Call: call}
}

// MockCmdableMSetCall wrap *gomock.Call
type MockCmdableMSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableMSetCall) Return(arg0 *redis.StatusCmd) *MockCmdableMSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableMSetCall) Do(f func(context.Context, ...any) *redis.StatusCmd) *MockCmdableMSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableMSetCall) DoAndReturn(f func(context.Context, ...any) *redis.StatusCmd) *MockCmdableMSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MSetNX mocks base method.
func (m *MockCmdable) MSetNX(ctx context.Context, values ...any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MSetNX", varargs...)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// MSetNX indicates an expected call of MSetNX.
func (mr *MockCmdableMockRecorder) MSetNX(ctx any, values ...any) *MockCmdableMSetNXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSetNX", reflect.TypeOf((*MockCmdable)(nil).MSetNX), varargs...)
	return &MockCmdableMSetNXCall{Call: call}
}

// MockCmdableMSetNXCall wrap *gomock.Call
type MockCmdableMSetNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableMSetNXCall) Return(arg0 *redis.BoolCmd) *MockCmdableMSetNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableMSetNXCall) Do(f func(context.Context, ...any) *redis.BoolCmd) *MockCmdableMSetNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableMSetNXCall) DoAndReturn(f func(context.Context, ...any) *redis.BoolCmd) *MockCmdableMSetNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MemoryUsage mocks base method.
func (m *MockCmdable) MemoryUsage(ctx context.Context, key string, samples ...int) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range samples {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MemoryUsage", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// MemoryUsage indicates an expected call of MemoryUsage.
func (mr *MockCmdableMockRecorder) MemoryUsage(ctx, key any, samples ...any) *MockCmdableMemoryUsageCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, samples...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MemoryUsage", reflect.TypeOf((*MockCmdable)(nil).MemoryUsage), varargs...)
	return &MockCmdableMemoryUsageCall{Call: call}
}

// MockCmdableMemoryUsageCall wrap *gomock.Call
type MockCmdableMemoryUsageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableMemoryUsageCall) Return(arg0 *redis.IntCmd) *MockCmdableMemoryUsageCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableMemoryUsageCall) Do(f func(context.Context, string, ...int) *redis.IntCmd) *MockCmdableMemoryUsageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableMemoryUsageCall) DoAndReturn(f func(context.Context, string, ...int) *redis.IntCmd) *MockCmdableMemoryUsageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Migrate mocks base method.
func (m *MockCmdable) Migrate(ctx context.Context, host, port, key string, db int, timeout time.Duration) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Migrate", ctx, host, port, key, db, timeout)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Migrate indicates an expected call of Migrate.
func (mr *MockCmdableMockRecorder) Migrate(ctx, host, port, key, db, timeout any) *MockCmdableMigrateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Migrate", reflect.TypeOf((*MockCmdable)(nil).Migrate), ctx, host, port, key, db, timeout)
	return &MockCmdableMigrateCall{Call: call}
}

// MockCmdableMigrateCall wrap *gomock.Call
type MockCmdableMigrateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableMigrateCall) Return(arg0 *redis.StatusCmd) *MockCmdableMigrateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableMigrateCall) Do(f func(context.Context, string, string, string, int, time.Duration) *redis.StatusCmd) *MockCmdableMigrateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableMigrateCall) DoAndReturn(f func(context.Context, string, string, string, int, time.Duration) *redis.StatusCmd) *MockCmdableMigrateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModuleLoadex mocks base method.
func (m *MockCmdable) ModuleLoadex(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ModuleLoadex", ctx, conf)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ModuleLoadex indicates an expected call of ModuleLoadex.
func (mr *MockCmdableMockRecorder) ModuleLoadex(ctx, conf any) *MockCmdableModuleLoadexCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModuleLoadex", reflect.TypeOf((*MockCmdable)(nil).ModuleLoadex), ctx, conf)
	return &MockCmdableModuleLoadexCall{Call: call}
}

// MockCmdableModuleLoadexCall wrap *gomock.Call
type MockCmdableModuleLoadexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableModuleLoadexCall) Return(arg0 *redis.StringCmd) *MockCmdableModuleLoadexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableModuleLoadexCall) Do(f func(context.Context, *redis.ModuleLoadexConfig) *redis.StringCmd) *MockCmdableModuleLoadexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableModuleLoadexCall) DoAndReturn(f func(context.Context, *redis.ModuleLoadexConfig) *redis.StringCmd) *MockCmdableModuleLoadexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Move mocks base method.
func (m *MockCmdable) Move(ctx context.Context, key string, db int) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Move", ctx, key, db)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// Move indicates an expected call of Move.
func (mr *MockCmdableMockRecorder) Move(ctx, key, db any) *MockCmdableMoveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Move", reflect.TypeOf((*MockCmdable)(nil).Move), ctx, key, db)
	return &MockCmdableMoveCall{Call: call}
}

// MockCmdableMoveCall wrap *gomock.Call
type MockCmdableMoveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableMoveCall) Return(arg0 *redis.BoolCmd) *MockCmdableMoveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableMoveCall) Do(f func(context.Context, string, int) *redis.BoolCmd) *MockCmdableMoveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableMoveCall) DoAndReturn(f func(context.Context, string, int) *redis.BoolCmd) *MockCmdableMoveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ObjectEncoding mocks base method.
func (m *MockCmdable) ObjectEncoding(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ObjectEncoding", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ObjectEncoding indicates an expected call of ObjectEncoding.
func (mr *MockCmdableMockRecorder) ObjectEncoding(ctx, key any) *MockCmdableObjectEncodingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ObjectEncoding", reflect.TypeOf((*MockCmdable)(nil).ObjectEncoding), ctx, key)
	return &MockCmdableObjectEncodingCall{Call: call}
}

// MockCmdableObjectEncodingCall wrap *gomock.Call
type MockCmdableObjectEncodingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableObjectEncodingCall) Return(arg0 *redis.StringCmd) *MockCmdableObjectEncodingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableObjectEncodingCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableObjectEncodingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableObjectEncodingCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableObjectEncodingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ObjectFreq mocks base method.
func (m *MockCmdable) ObjectFreq(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ObjectFreq", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ObjectFreq indicates an expected call of ObjectFreq.
func (mr *MockCmdableMockRecorder) ObjectFreq(ctx, key any) *MockCmdableObjectFreqCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ObjectFreq", reflect.TypeOf((*MockCmdable)(nil).ObjectFreq), ctx, key)
	return &MockCmdableObjectFreqCall{Call: call}
}

// MockCmdableObjectFreqCall wrap *gomock.Call
type MockCmdableObjectFreqCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableObjectFreqCall) Return(arg0 *redis.IntCmd) *MockCmdableObjectFreqCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableObjectFreqCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableObjectFreqCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableObjectFreqCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableObjectFreqCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ObjectIdleTime mocks base method.
func (m *MockCmdable) ObjectIdleTime(ctx context.Context, key string) *redis.DurationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ObjectIdleTime", ctx, key)
	ret0, _ := ret[0].(*redis.DurationCmd)
	return ret0
}

// ObjectIdleTime indicates an expected call of ObjectIdleTime.
func (mr *MockCmdableMockRecorder) ObjectIdleTime(ctx, key any) *MockCmdableObjectIdleTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ObjectIdleTime", reflect.TypeOf((*MockCmdable)(nil).ObjectIdleTime), ctx, key)
	return &MockCmdableObjectIdleTimeCall{Call: call}
}

// MockCmdableObjectIdleTimeCall wrap *gomock.Call
type MockCmdableObjectIdleTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableObjectIdleTimeCall) Return(arg0 *redis.DurationCmd) *MockCmdableObjectIdleTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableObjectIdleTimeCall) Do(f func(context.Context, string) *redis.DurationCmd) *MockCmdableObjectIdleTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableObjectIdleTimeCall) DoAndReturn(f func(context.Context, string) *redis.DurationCmd) *MockCmdableObjectIdleTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ObjectRefCount mocks base method.
func (m *MockCmdable) ObjectRefCount(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ObjectRefCount", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ObjectRefCount indicates an expected call of ObjectRefCount.
func (mr *MockCmdableMockRecorder) ObjectRefCount(ctx, key any) *MockCmdableObjectRefCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ObjectRefCount", reflect.TypeOf((*MockCmdable)(nil).ObjectRefCount), ctx, key)
	return &MockCmdableObjectRefCountCall{Call: call}
}

// MockCmdableObjectRefCountCall wrap *gomock.Call
type MockCmdableObjectRefCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableObjectRefCountCall) Return(arg0 *redis.IntCmd) *MockCmdableObjectRefCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableObjectRefCountCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableObjectRefCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableObjectRefCountCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableObjectRefCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PExpire mocks base method.
func (m *MockCmdable) PExpire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PExpire", ctx, key, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// PExpire indicates an expected call of PExpire.
func (mr *MockCmdableMockRecorder) PExpire(ctx, key, expiration any) *MockCmdablePExpireCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PExpire", reflect.TypeOf((*MockCmdable)(nil).PExpire), ctx, key, expiration)
	return &MockCmdablePExpireCall{Call: call}
}

// MockCmdablePExpireCall wrap *gomock.Call
type MockCmdablePExpireCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePExpireCall) Return(arg0 *redis.BoolCmd) *MockCmdablePExpireCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePExpireCall) Do(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdablePExpireCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePExpireCall) DoAndReturn(f func(context.Context, string, time.Duration) *redis.BoolCmd) *MockCmdablePExpireCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PExpireAt mocks base method.
func (m *MockCmdable) PExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PExpireAt", ctx, key, tm)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// PExpireAt indicates an expected call of PExpireAt.
func (mr *MockCmdableMockRecorder) PExpireAt(ctx, key, tm any) *MockCmdablePExpireAtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PExpireAt", reflect.TypeOf((*MockCmdable)(nil).PExpireAt), ctx, key, tm)
	return &MockCmdablePExpireAtCall{Call: call}
}

// MockCmdablePExpireAtCall wrap *gomock.Call
type MockCmdablePExpireAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePExpireAtCall) Return(arg0 *redis.BoolCmd) *MockCmdablePExpireAtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePExpireAtCall) Do(f func(context.Context, string, time.Time) *redis.BoolCmd) *MockCmdablePExpireAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePExpireAtCall) DoAndReturn(f func(context.Context, string, time.Time) *redis.BoolCmd) *MockCmdablePExpireAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PExpireTime mocks base method.
func (m *MockCmdable) PExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PExpireTime", ctx, key)
	ret0, _ := ret[0].(*redis.DurationCmd)
	return ret0
}

// PExpireTime indicates an expected call of PExpireTime.
func (mr *MockCmdableMockRecorder) PExpireTime(ctx, key any) *MockCmdablePExpireTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PExpireTime", reflect.TypeOf((*MockCmdable)(nil).PExpireTime), ctx, key)
	return &MockCmdablePExpireTimeCall{Call: call}
}

// MockCmdablePExpireTimeCall wrap *gomock.Call
type MockCmdablePExpireTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePExpireTimeCall) Return(arg0 *redis.DurationCmd) *MockCmdablePExpireTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePExpireTimeCall) Do(f func(context.Context, string) *redis.DurationCmd) *MockCmdablePExpireTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePExpireTimeCall) DoAndReturn(f func(context.Context, string) *redis.DurationCmd) *MockCmdablePExpireTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PFAdd mocks base method.
func (m *MockCmdable) PFAdd(ctx context.Context, key string, els ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range els {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PFAdd", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// PFAdd indicates an expected call of PFAdd.
func (mr *MockCmdableMockRecorder) PFAdd(ctx, key any, els ...any) *MockCmdablePFAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, els...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PFAdd", reflect.TypeOf((*MockCmdable)(nil).PFAdd), varargs...)
	return &MockCmdablePFAddCall{Call: call}
}

// MockCmdablePFAddCall wrap *gomock.Call
type MockCmdablePFAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePFAddCall) Return(arg0 *redis.IntCmd) *MockCmdablePFAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePFAddCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdablePFAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePFAddCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdablePFAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PFCount mocks base method.
func (m *MockCmdable) PFCount(ctx context.Context, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PFCount", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// PFCount indicates an expected call of PFCount.
func (mr *MockCmdableMockRecorder) PFCount(ctx any, keys ...any) *MockCmdablePFCountCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PFCount", reflect.TypeOf((*MockCmdable)(nil).PFCount), varargs...)
	return &MockCmdablePFCountCall{Call: call}
}

// MockCmdablePFCountCall wrap *gomock.Call
type MockCmdablePFCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePFCountCall) Return(arg0 *redis.IntCmd) *MockCmdablePFCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePFCountCall) Do(f func(context.Context, ...string) *redis.IntCmd) *MockCmdablePFCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePFCountCall) DoAndReturn(f func(context.Context, ...string) *redis.IntCmd) *MockCmdablePFCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PFMerge mocks base method.
func (m *MockCmdable) PFMerge(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, dest}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PFMerge", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// PFMerge indicates an expected call of PFMerge.
func (mr *MockCmdableMockRecorder) PFMerge(ctx, dest any, keys ...any) *MockCmdablePFMergeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, dest}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PFMerge", reflect.TypeOf((*MockCmdable)(nil).PFMerge), varargs...)
	return &MockCmdablePFMergeCall{Call: call}
}

// MockCmdablePFMergeCall wrap *gomock.Call
type MockCmdablePFMergeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePFMergeCall) Return(arg0 *redis.StatusCmd) *MockCmdablePFMergeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePFMergeCall) Do(f func(context.Context, string, ...string) *redis.StatusCmd) *MockCmdablePFMergeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePFMergeCall) DoAndReturn(f func(context.Context, string, ...string) *redis.StatusCmd) *MockCmdablePFMergeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PTTL mocks base method.
func (m *MockCmdable) PTTL(ctx context.Context, key string) *redis.DurationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PTTL", ctx, key)
	ret0, _ := ret[0].(*redis.DurationCmd)
	return ret0
}

// PTTL indicates an expected call of PTTL.
func (mr *MockCmdableMockRecorder) PTTL(ctx, key any) *MockCmdablePTTLCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PTTL", reflect.TypeOf((*MockCmdable)(nil).PTTL), ctx, key)
	return &MockCmdablePTTLCall{Call: call}
}

// MockCmdablePTTLCall wrap *gomock.Call
type MockCmdablePTTLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePTTLCall) Return(arg0 *redis.DurationCmd) *MockCmdablePTTLCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePTTLCall) Do(f func(context.Context, string) *redis.DurationCmd) *MockCmdablePTTLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePTTLCall) DoAndReturn(f func(context.Context, string) *redis.DurationCmd) *MockCmdablePTTLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Persist mocks base method.
func (m *MockCmdable) Persist(ctx context.Context, key string) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Persist", ctx, key)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// Persist indicates an expected call of Persist.
func (mr *MockCmdableMockRecorder) Persist(ctx, key any) *MockCmdablePersistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Persist", reflect.TypeOf((*MockCmdable)(nil).Persist), ctx, key)
	return &MockCmdablePersistCall{Call: call}
}

// MockCmdablePersistCall wrap *gomock.Call
type MockCmdablePersistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePersistCall) Return(arg0 *redis.BoolCmd) *MockCmdablePersistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePersistCall) Do(f func(context.Context, string) *redis.BoolCmd) *MockCmdablePersistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePersistCall) DoAndReturn(f func(context.Context, string) *redis.BoolCmd) *MockCmdablePersistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ping mocks base method.
func (m *MockCmdable) Ping(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockCmdableMockRecorder) Ping(ctx any) *MockCmdablePingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockCmdable)(nil).Ping), ctx)
	return &MockCmdablePingCall{Call: call}
}

// MockCmdablePingCall wrap *gomock.Call
type MockCmdablePingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePingCall) Return(arg0 *redis.StatusCmd) *MockCmdablePingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePingCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdablePingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePingCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdablePingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Pipeline mocks base method.
func (m *MockCmdable) Pipeline() redis.Pipeliner {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pipeline")
	ret0, _ := ret[0].(redis.Pipeliner)
	return ret0
}

// Pipeline indicates an expected call of Pipeline.
func (mr *MockCmdableMockRecorder) Pipeline() *MockCmdablePipelineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pipeline", reflect.TypeOf((*MockCmdable)(nil).Pipeline))
	return &MockCmdablePipelineCall{Call: call}
}

// MockCmdablePipelineCall wrap *gomock.Call
type MockCmdablePipelineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePipelineCall) Return(arg0 redis.Pipeliner) *MockCmdablePipelineCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePipelineCall) Do(f func() redis.Pipeliner) *MockCmdablePipelineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePipelineCall) DoAndReturn(f func() redis.Pipeliner) *MockCmdablePipelineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Pipelined mocks base method.
func (m *MockCmdable) Pipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pipelined", ctx, fn)
	ret0, _ := ret[0].([]redis.Cmder)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Pipelined indicates an expected call of Pipelined.
func (mr *MockCmdableMockRecorder) Pipelined(ctx, fn any) *MockCmdablePipelinedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pipelined", reflect.TypeOf((*MockCmdable)(nil).Pipelined), ctx, fn)
	return &MockCmdablePipelinedCall{Call: call}
}

// MockCmdablePipelinedCall wrap *gomock.Call
type MockCmdablePipelinedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePipelinedCall) Return(arg0 []redis.Cmder, arg1 error) *MockCmdablePipelinedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePipelinedCall) Do(f func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)) *MockCmdablePipelinedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePipelinedCall) DoAndReturn(f func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)) *MockCmdablePipelinedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PubSubChannels mocks base method.
func (m *MockCmdable) PubSubChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PubSubChannels", ctx, pattern)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// PubSubChannels indicates an expected call of PubSubChannels.
func (mr *MockCmdableMockRecorder) PubSubChannels(ctx, pattern any) *MockCmdablePubSubChannelsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PubSubChannels", reflect.TypeOf((*MockCmdable)(nil).PubSubChannels), ctx, pattern)
	return &MockCmdablePubSubChannelsCall{Call: call}
}

// MockCmdablePubSubChannelsCall wrap *gomock.Call
type MockCmdablePubSubChannelsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePubSubChannelsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdablePubSubChannelsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePubSubChannelsCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdablePubSubChannelsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePubSubChannelsCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdablePubSubChannelsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PubSubNumPat mocks base method.
func (m *MockCmdable) PubSubNumPat(ctx context.Context) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PubSubNumPat", ctx)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// PubSubNumPat indicates an expected call of PubSubNumPat.
func (mr *MockCmdableMockRecorder) PubSubNumPat(ctx any) *MockCmdablePubSubNumPatCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PubSubNumPat", reflect.TypeOf((*MockCmdable)(nil).PubSubNumPat), ctx)
	return &MockCmdablePubSubNumPatCall{Call: call}
}

// MockCmdablePubSubNumPatCall wrap *gomock.Call
type MockCmdablePubSubNumPatCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePubSubNumPatCall) Return(arg0 *redis.IntCmd) *MockCmdablePubSubNumPatCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePubSubNumPatCall) Do(f func(context.Context) *redis.IntCmd) *MockCmdablePubSubNumPatCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePubSubNumPatCall) DoAndReturn(f func(context.Context) *redis.IntCmd) *MockCmdablePubSubNumPatCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PubSubNumSub mocks base method.
func (m *MockCmdable) PubSubNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range channels {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PubSubNumSub", varargs...)
	ret0, _ := ret[0].(*redis.MapStringIntCmd)
	return ret0
}

// PubSubNumSub indicates an expected call of PubSubNumSub.
func (mr *MockCmdableMockRecorder) PubSubNumSub(ctx any, channels ...any) *MockCmdablePubSubNumSubCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, channels...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PubSubNumSub", reflect.TypeOf((*MockCmdable)(nil).PubSubNumSub), varargs...)
	return &MockCmdablePubSubNumSubCall{Call: call}
}

// MockCmdablePubSubNumSubCall wrap *gomock.Call
type MockCmdablePubSubNumSubCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePubSubNumSubCall) Return(arg0 *redis.MapStringIntCmd) *MockCmdablePubSubNumSubCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePubSubNumSubCall) Do(f func(context.Context, ...string) *redis.MapStringIntCmd) *MockCmdablePubSubNumSubCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePubSubNumSubCall) DoAndReturn(f func(context.Context, ...string) *redis.MapStringIntCmd) *MockCmdablePubSubNumSubCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PubSubShardChannels mocks base method.
func (m *MockCmdable) PubSubShardChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PubSubShardChannels", ctx, pattern)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// PubSubShardChannels indicates an expected call of PubSubShardChannels.
func (mr *MockCmdableMockRecorder) PubSubShardChannels(ctx, pattern any) *MockCmdablePubSubShardChannelsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PubSubShardChannels", reflect.TypeOf((*MockCmdable)(nil).PubSubShardChannels), ctx, pattern)
	return &MockCmdablePubSubShardChannelsCall{Call: call}
}

// MockCmdablePubSubShardChannelsCall wrap *gomock.Call
type MockCmdablePubSubShardChannelsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePubSubShardChannelsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdablePubSubShardChannelsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePubSubShardChannelsCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdablePubSubShardChannelsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePubSubShardChannelsCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdablePubSubShardChannelsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PubSubShardNumSub mocks base method.
func (m *MockCmdable) PubSubShardNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range channels {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PubSubShardNumSub", varargs...)
	ret0, _ := ret[0].(*redis.MapStringIntCmd)
	return ret0
}

// PubSubShardNumSub indicates an expected call of PubSubShardNumSub.
func (mr *MockCmdableMockRecorder) PubSubShardNumSub(ctx any, channels ...any) *MockCmdablePubSubShardNumSubCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, channels...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PubSubShardNumSub", reflect.TypeOf((*MockCmdable)(nil).PubSubShardNumSub), varargs...)
	return &MockCmdablePubSubShardNumSubCall{Call: call}
}

// MockCmdablePubSubShardNumSubCall wrap *gomock.Call
type MockCmdablePubSubShardNumSubCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePubSubShardNumSubCall) Return(arg0 *redis.MapStringIntCmd) *MockCmdablePubSubShardNumSubCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePubSubShardNumSubCall) Do(f func(context.Context, ...string) *redis.MapStringIntCmd) *MockCmdablePubSubShardNumSubCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePubSubShardNumSubCall) DoAndReturn(f func(context.Context, ...string) *redis.MapStringIntCmd) *MockCmdablePubSubShardNumSubCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Publish mocks base method.
func (m *MockCmdable) Publish(ctx context.Context, channel string, message any) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", ctx, channel, message)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockCmdableMockRecorder) Publish(ctx, channel, message any) *MockCmdablePublishCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockCmdable)(nil).Publish), ctx, channel, message)
	return &MockCmdablePublishCall{Call: call}
}

// MockCmdablePublishCall wrap *gomock.Call
type MockCmdablePublishCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdablePublishCall) Return(arg0 *redis.IntCmd) *MockCmdablePublishCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdablePublishCall) Do(f func(context.Context, string, any) *redis.IntCmd) *MockCmdablePublishCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdablePublishCall) DoAndReturn(f func(context.Context, string, any) *redis.IntCmd) *MockCmdablePublishCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Quit mocks base method.
func (m *MockCmdable) Quit(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Quit", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Quit indicates an expected call of Quit.
func (mr *MockCmdableMockRecorder) Quit(ctx any) *MockCmdableQuitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Quit", reflect.TypeOf((*MockCmdable)(nil).Quit), ctx)
	return &MockCmdableQuitCall{Call: call}
}

// MockCmdableQuitCall wrap *gomock.Call
type MockCmdableQuitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableQuitCall) Return(arg0 *redis.StatusCmd) *MockCmdableQuitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableQuitCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableQuitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableQuitCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableQuitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RPop mocks base method.
func (m *MockCmdable) RPop(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RPop", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// RPop indicates an expected call of RPop.
func (mr *MockCmdableMockRecorder) RPop(ctx, key any) *MockCmdableRPopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPop", reflect.TypeOf((*MockCmdable)(nil).RPop), ctx, key)
	return &MockCmdableRPopCall{Call: call}
}

// MockCmdableRPopCall wrap *gomock.Call
type MockCmdableRPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRPopCall) Return(arg0 *redis.StringCmd) *MockCmdableRPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRPopCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableRPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRPopCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableRPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RPopCount mocks base method.
func (m *MockCmdable) RPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RPopCount", ctx, key, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// RPopCount indicates an expected call of RPopCount.
func (mr *MockCmdableMockRecorder) RPopCount(ctx, key, count any) *MockCmdableRPopCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPopCount", reflect.TypeOf((*MockCmdable)(nil).RPopCount), ctx, key, count)
	return &MockCmdableRPopCountCall{Call: call}
}

// MockCmdableRPopCountCall wrap *gomock.Call
type MockCmdableRPopCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRPopCountCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableRPopCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRPopCountCall) Do(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableRPopCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRPopCountCall) DoAndReturn(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableRPopCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RPopLPush mocks base method.
func (m *MockCmdable) RPopLPush(ctx context.Context, source, destination string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RPopLPush", ctx, source, destination)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// RPopLPush indicates an expected call of RPopLPush.
func (mr *MockCmdableMockRecorder) RPopLPush(ctx, source, destination any) *MockCmdableRPopLPushCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPopLPush", reflect.TypeOf((*MockCmdable)(nil).RPopLPush), ctx, source, destination)
	return &MockCmdableRPopLPushCall{Call: call}
}

// MockCmdableRPopLPushCall wrap *gomock.Call
type MockCmdableRPopLPushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRPopLPushCall) Return(arg0 *redis.StringCmd) *MockCmdableRPopLPushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRPopLPushCall) Do(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableRPopLPushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRPopLPushCall) DoAndReturn(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableRPopLPushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RPush mocks base method.
func (m *MockCmdable) RPush(ctx context.Context, key string, values ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RPush", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// RPush indicates an expected call of RPush.
func (mr *MockCmdableMockRecorder) RPush(ctx, key any, values ...any) *MockCmdableRPushCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPush", reflect.TypeOf((*MockCmdable)(nil).RPush), varargs...)
	return &MockCmdableRPushCall{Call: call}
}

// MockCmdableRPushCall wrap *gomock.Call
type MockCmdableRPushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRPushCall) Return(arg0 *redis.IntCmd) *MockCmdableRPushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRPushCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableRPushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRPushCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableRPushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RPushX mocks base method.
func (m *MockCmdable) RPushX(ctx context.Context, key string, values ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RPushX", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// RPushX indicates an expected call of RPushX.
func (mr *MockCmdableMockRecorder) RPushX(ctx, key any, values ...any) *MockCmdableRPushXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPushX", reflect.TypeOf((*MockCmdable)(nil).RPushX), varargs...)
	return &MockCmdableRPushXCall{Call: call}
}

// MockCmdableRPushXCall wrap *gomock.Call
type MockCmdableRPushXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRPushXCall) Return(arg0 *redis.IntCmd) *MockCmdableRPushXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRPushXCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableRPushXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRPushXCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableRPushXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RandomKey mocks base method.
func (m *MockCmdable) RandomKey(ctx context.Context) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RandomKey", ctx)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// RandomKey indicates an expected call of RandomKey.
func (mr *MockCmdableMockRecorder) RandomKey(ctx any) *MockCmdableRandomKeyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RandomKey", reflect.TypeOf((*MockCmdable)(nil).RandomKey), ctx)
	return &MockCmdableRandomKeyCall{Call: call}
}

// MockCmdableRandomKeyCall wrap *gomock.Call
type MockCmdableRandomKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRandomKeyCall) Return(arg0 *redis.StringCmd) *MockCmdableRandomKeyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRandomKeyCall) Do(f func(context.Context) *redis.StringCmd) *MockCmdableRandomKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRandomKeyCall) DoAndReturn(f func(context.Context) *redis.StringCmd) *MockCmdableRandomKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadOnly mocks base method.
func (m *MockCmdable) ReadOnly(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadOnly", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ReadOnly indicates an expected call of ReadOnly.
func (mr *MockCmdableMockRecorder) ReadOnly(ctx any) *MockCmdableReadOnlyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOnly", reflect.TypeOf((*MockCmdable)(nil).ReadOnly), ctx)
	return &MockCmdableReadOnlyCall{Call: call}
}

// MockCmdableReadOnlyCall wrap *gomock.Call
type MockCmdableReadOnlyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableReadOnlyCall) Return(arg0 *redis.StatusCmd) *MockCmdableReadOnlyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableReadOnlyCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableReadOnlyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableReadOnlyCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableReadOnlyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadWrite mocks base method.
func (m *MockCmdable) ReadWrite(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadWrite", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ReadWrite indicates an expected call of ReadWrite.
func (mr *MockCmdableMockRecorder) ReadWrite(ctx any) *MockCmdableReadWriteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadWrite", reflect.TypeOf((*MockCmdable)(nil).ReadWrite), ctx)
	return &MockCmdableReadWriteCall{Call: call}
}

// MockCmdableReadWriteCall wrap *gomock.Call
type MockCmdableReadWriteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableReadWriteCall) Return(arg0 *redis.StatusCmd) *MockCmdableReadWriteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableReadWriteCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableReadWriteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableReadWriteCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableReadWriteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rename mocks base method.
func (m *MockCmdable) Rename(ctx context.Context, key, newkey string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rename", ctx, key, newkey)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Rename indicates an expected call of Rename.
func (mr *MockCmdableMockRecorder) Rename(ctx, key, newkey any) *MockCmdableRenameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rename", reflect.TypeOf((*MockCmdable)(nil).Rename), ctx, key, newkey)
	return &MockCmdableRenameCall{Call: call}
}

// MockCmdableRenameCall wrap *gomock.Call
type MockCmdableRenameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRenameCall) Return(arg0 *redis.StatusCmd) *MockCmdableRenameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRenameCall) Do(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableRenameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRenameCall) DoAndReturn(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableRenameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RenameNX mocks base method.
func (m *MockCmdable) RenameNX(ctx context.Context, key, newkey string) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RenameNX", ctx, key, newkey)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// RenameNX indicates an expected call of RenameNX.
func (mr *MockCmdableMockRecorder) RenameNX(ctx, key, newkey any) *MockCmdableRenameNXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RenameNX", reflect.TypeOf((*MockCmdable)(nil).RenameNX), ctx, key, newkey)
	return &MockCmdableRenameNXCall{Call: call}
}

// MockCmdableRenameNXCall wrap *gomock.Call
type MockCmdableRenameNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRenameNXCall) Return(arg0 *redis.BoolCmd) *MockCmdableRenameNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRenameNXCall) Do(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableRenameNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRenameNXCall) DoAndReturn(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableRenameNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Restore mocks base method.
func (m *MockCmdable) Restore(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Restore", ctx, key, ttl, value)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Restore indicates an expected call of Restore.
func (mr *MockCmdableMockRecorder) Restore(ctx, key, ttl, value any) *MockCmdableRestoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Restore", reflect.TypeOf((*MockCmdable)(nil).Restore), ctx, key, ttl, value)
	return &MockCmdableRestoreCall{Call: call}
}

// MockCmdableRestoreCall wrap *gomock.Call
type MockCmdableRestoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRestoreCall) Return(arg0 *redis.StatusCmd) *MockCmdableRestoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRestoreCall) Do(f func(context.Context, string, time.Duration, string) *redis.StatusCmd) *MockCmdableRestoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRestoreCall) DoAndReturn(f func(context.Context, string, time.Duration, string) *redis.StatusCmd) *MockCmdableRestoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestoreReplace mocks base method.
func (m *MockCmdable) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestoreReplace", ctx, key, ttl, value)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// RestoreReplace indicates an expected call of RestoreReplace.
func (mr *MockCmdableMockRecorder) RestoreReplace(ctx, key, ttl, value any) *MockCmdableRestoreReplaceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoreReplace", reflect.TypeOf((*MockCmdable)(nil).RestoreReplace), ctx, key, ttl, value)
	return &MockCmdableRestoreReplaceCall{Call: call}
}

// MockCmdableRestoreReplaceCall wrap *gomock.Call
type MockCmdableRestoreReplaceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableRestoreReplaceCall) Return(arg0 *redis.StatusCmd) *MockCmdableRestoreReplaceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableRestoreReplaceCall) Do(f func(context.Context, string, time.Duration, string) *redis.StatusCmd) *MockCmdableRestoreReplaceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableRestoreReplaceCall) DoAndReturn(f func(context.Context, string, time.Duration, string) *redis.StatusCmd) *MockCmdableRestoreReplaceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SAdd mocks base method.
func (m *MockCmdable) SAdd(ctx context.Context, key string, members ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SAdd", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SAdd indicates an expected call of SAdd.
func (mr *MockCmdableMockRecorder) SAdd(ctx, key any, members ...any) *MockCmdableSAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SAdd", reflect.TypeOf((*MockCmdable)(nil).SAdd), varargs...)
	return &MockCmdableSAddCall{Call: call}
}

// MockCmdableSAddCall wrap *gomock.Call
type MockCmdableSAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSAddCall) Return(arg0 *redis.IntCmd) *MockCmdableSAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSAddCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableSAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSAddCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableSAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SCard mocks base method.
func (m *MockCmdable) SCard(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SCard", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SCard indicates an expected call of SCard.
func (mr *MockCmdableMockRecorder) SCard(ctx, key any) *MockCmdableSCardCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SCard", reflect.TypeOf((*MockCmdable)(nil).SCard), ctx, key)
	return &MockCmdableSCardCall{Call: call}
}

// MockCmdableSCardCall wrap *gomock.Call
type MockCmdableSCardCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSCardCall) Return(arg0 *redis.IntCmd) *MockCmdableSCardCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSCardCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableSCardCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSCardCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableSCardCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SDiff mocks base method.
func (m *MockCmdable) SDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SDiff", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// SDiff indicates an expected call of SDiff.
func (mr *MockCmdableMockRecorder) SDiff(ctx any, keys ...any) *MockCmdableSDiffCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SDiff", reflect.TypeOf((*MockCmdable)(nil).SDiff), varargs...)
	return &MockCmdableSDiffCall{Call: call}
}

// MockCmdableSDiffCall wrap *gomock.Call
type MockCmdableSDiffCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSDiffCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSDiffCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSDiffCall) Do(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableSDiffCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSDiffCall) DoAndReturn(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableSDiffCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SDiffStore mocks base method.
func (m *MockCmdable) SDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destination}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SDiffStore", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SDiffStore indicates an expected call of SDiffStore.
func (mr *MockCmdableMockRecorder) SDiffStore(ctx, destination any, keys ...any) *MockCmdableSDiffStoreCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destination}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SDiffStore", reflect.TypeOf((*MockCmdable)(nil).SDiffStore), varargs...)
	return &MockCmdableSDiffStoreCall{Call: call}
}

// MockCmdableSDiffStoreCall wrap *gomock.Call
type MockCmdableSDiffStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSDiffStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableSDiffStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSDiffStoreCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableSDiffStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSDiffStoreCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableSDiffStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SInter mocks base method.
func (m *MockCmdable) SInter(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SInter", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// SInter indicates an expected call of SInter.
func (mr *MockCmdableMockRecorder) SInter(ctx any, keys ...any) *MockCmdableSInterCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SInter", reflect.TypeOf((*MockCmdable)(nil).SInter), varargs...)
	return &MockCmdableSInterCall{Call: call}
}

// MockCmdableSInterCall wrap *gomock.Call
type MockCmdableSInterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSInterCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSInterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSInterCall) Do(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableSInterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSInterCall) DoAndReturn(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableSInterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SInterCard mocks base method.
func (m *MockCmdable) SInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, limit}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SInterCard", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SInterCard indicates an expected call of SInterCard.
func (mr *MockCmdableMockRecorder) SInterCard(ctx, limit any, keys ...any) *MockCmdableSInterCardCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, limit}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SInterCard", reflect.TypeOf((*MockCmdable)(nil).SInterCard), varargs...)
	return &MockCmdableSInterCardCall{Call: call}
}

// MockCmdableSInterCardCall wrap *gomock.Call
type MockCmdableSInterCardCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSInterCardCall) Return(arg0 *redis.IntCmd) *MockCmdableSInterCardCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSInterCardCall) Do(f func(context.Context, int64, ...string) *redis.IntCmd) *MockCmdableSInterCardCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSInterCardCall) DoAndReturn(f func(context.Context, int64, ...string) *redis.IntCmd) *MockCmdableSInterCardCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SInterStore mocks base method.
func (m *MockCmdable) SInterStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destination}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SInterStore", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SInterStore indicates an expected call of SInterStore.
func (mr *MockCmdableMockRecorder) SInterStore(ctx, destination any, keys ...any) *MockCmdableSInterStoreCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destination}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SInterStore", reflect.TypeOf((*MockCmdable)(nil).SInterStore), varargs...)
	return &MockCmdableSInterStoreCall{Call: call}
}

// MockCmdableSInterStoreCall wrap *gomock.Call
type MockCmdableSInterStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSInterStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableSInterStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSInterStoreCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableSInterStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSInterStoreCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableSInterStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SIsMember mocks base method.
func (m *MockCmdable) SIsMember(ctx context.Context, key string, member any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SIsMember", ctx, key, member)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// SIsMember indicates an expected call of SIsMember.
func (mr *MockCmdableMockRecorder) SIsMember(ctx, key, member any) *MockCmdableSIsMemberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SIsMember", reflect.TypeOf((*MockCmdable)(nil).SIsMember), ctx, key, member)
	return &MockCmdableSIsMemberCall{Call: call}
}

// MockCmdableSIsMemberCall wrap *gomock.Call
type MockCmdableSIsMemberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSIsMemberCall) Return(arg0 *redis.BoolCmd) *MockCmdableSIsMemberCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSIsMemberCall) Do(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableSIsMemberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSIsMemberCall) DoAndReturn(f func(context.Context, string, any) *redis.BoolCmd) *MockCmdableSIsMemberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SMIsMember mocks base method.
func (m *MockCmdable) SMIsMember(ctx context.Context, key string, members ...any) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SMIsMember", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// SMIsMember indicates an expected call of SMIsMember.
func (mr *MockCmdableMockRecorder) SMIsMember(ctx, key any, members ...any) *MockCmdableSMIsMemberCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SMIsMember", reflect.TypeOf((*MockCmdable)(nil).SMIsMember), varargs...)
	return &MockCmdableSMIsMemberCall{Call: call}
}

// MockCmdableSMIsMemberCall wrap *gomock.Call
type MockCmdableSMIsMemberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSMIsMemberCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableSMIsMemberCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSMIsMemberCall) Do(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableSMIsMemberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSMIsMemberCall) DoAndReturn(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableSMIsMemberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SMembers mocks base method.
func (m *MockCmdable) SMembers(ctx context.Context, key string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SMembers", ctx, key)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// SMembers indicates an expected call of SMembers.
func (mr *MockCmdableMockRecorder) SMembers(ctx, key any) *MockCmdableSMembersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SMembers", reflect.TypeOf((*MockCmdable)(nil).SMembers), ctx, key)
	return &MockCmdableSMembersCall{Call: call}
}

// MockCmdableSMembersCall wrap *gomock.Call
type MockCmdableSMembersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSMembersCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSMembersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSMembersCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableSMembersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSMembersCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableSMembersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SMembersMap mocks base method.
func (m *MockCmdable) SMembersMap(ctx context.Context, key string) *redis.StringStructMapCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SMembersMap", ctx, key)
	ret0, _ := ret[0].(*redis.StringStructMapCmd)
	return ret0
}

// SMembersMap indicates an expected call of SMembersMap.
func (mr *MockCmdableMockRecorder) SMembersMap(ctx, key any) *MockCmdableSMembersMapCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SMembersMap", reflect.TypeOf((*MockCmdable)(nil).SMembersMap), ctx, key)
	return &MockCmdableSMembersMapCall{Call: call}
}

// MockCmdableSMembersMapCall wrap *gomock.Call
type MockCmdableSMembersMapCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSMembersMapCall) Return(arg0 *redis.StringStructMapCmd) *MockCmdableSMembersMapCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSMembersMapCall) Do(f func(context.Context, string) *redis.StringStructMapCmd) *MockCmdableSMembersMapCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSMembersMapCall) DoAndReturn(f func(context.Context, string) *redis.StringStructMapCmd) *MockCmdableSMembersMapCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SMove mocks base method.
func (m *MockCmdable) SMove(ctx context.Context, source, destination string, member any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SMove", ctx, source, destination, member)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// SMove indicates an expected call of SMove.
func (mr *MockCmdableMockRecorder) SMove(ctx, source, destination, member any) *MockCmdableSMoveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SMove", reflect.TypeOf((*MockCmdable)(nil).SMove), ctx, source, destination, member)
	return &MockCmdableSMoveCall{Call: call}
}

// MockCmdableSMoveCall wrap *gomock.Call
type MockCmdableSMoveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSMoveCall) Return(arg0 *redis.BoolCmd) *MockCmdableSMoveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSMoveCall) Do(f func(context.Context, string, string, any) *redis.BoolCmd) *MockCmdableSMoveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSMoveCall) DoAndReturn(f func(context.Context, string, string, any) *redis.BoolCmd) *MockCmdableSMoveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SPop mocks base method.
func (m *MockCmdable) SPop(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SPop", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// SPop indicates an expected call of SPop.
func (mr *MockCmdableMockRecorder) SPop(ctx, key any) *MockCmdableSPopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SPop", reflect.TypeOf((*MockCmdable)(nil).SPop), ctx, key)
	return &MockCmdableSPopCall{Call: call}
}

// MockCmdableSPopCall wrap *gomock.Call
type MockCmdableSPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSPopCall) Return(arg0 *redis.StringCmd) *MockCmdableSPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSPopCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableSPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSPopCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableSPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SPopN mocks base method.
func (m *MockCmdable) SPopN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SPopN", ctx, key, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// SPopN indicates an expected call of SPopN.
func (mr *MockCmdableMockRecorder) SPopN(ctx, key, count any) *MockCmdableSPopNCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SPopN", reflect.TypeOf((*MockCmdable)(nil).SPopN), ctx, key, count)
	return &MockCmdableSPopNCall{Call: call}
}

// MockCmdableSPopNCall wrap *gomock.Call
type MockCmdableSPopNCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSPopNCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSPopNCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSPopNCall) Do(f func(context.Context, string, int64) *redis.StringSliceCmd) *MockCmdableSPopNCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSPopNCall) DoAndReturn(f func(context.Context, string, int64) *redis.StringSliceCmd) *MockCmdableSPopNCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SPublish mocks base method.
func (m *MockCmdable) SPublish(ctx context.Context, channel string, message any) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SPublish", ctx, channel, message)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SPublish indicates an expected call of SPublish.
func (mr *MockCmdableMockRecorder) SPublish(ctx, channel, message any) *MockCmdableSPublishCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SPublish", reflect.TypeOf((*MockCmdable)(nil).SPublish), ctx, channel, message)
	return &MockCmdableSPublishCall{Call: call}
}

// MockCmdableSPublishCall wrap *gomock.Call
type MockCmdableSPublishCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSPublishCall) Return(arg0 *redis.IntCmd) *MockCmdableSPublishCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSPublishCall) Do(f func(context.Context, string, any) *redis.IntCmd) *MockCmdableSPublishCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSPublishCall) DoAndReturn(f func(context.Context, string, any) *redis.IntCmd) *MockCmdableSPublishCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SRandMember mocks base method.
func (m *MockCmdable) SRandMember(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SRandMember", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// SRandMember indicates an expected call of SRandMember.
func (mr *MockCmdableMockRecorder) SRandMember(ctx, key any) *MockCmdableSRandMemberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SRandMember", reflect.TypeOf((*MockCmdable)(nil).SRandMember), ctx, key)
	return &MockCmdableSRandMemberCall{Call: call}
}

// MockCmdableSRandMemberCall wrap *gomock.Call
type MockCmdableSRandMemberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSRandMemberCall) Return(arg0 *redis.StringCmd) *MockCmdableSRandMemberCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSRandMemberCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableSRandMemberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSRandMemberCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableSRandMemberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SRandMemberN mocks base method.
func (m *MockCmdable) SRandMemberN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SRandMemberN", ctx, key, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// SRandMemberN indicates an expected call of SRandMemberN.
func (mr *MockCmdableMockRecorder) SRandMemberN(ctx, key, count any) *MockCmdableSRandMemberNCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SRandMemberN", reflect.TypeOf((*MockCmdable)(nil).SRandMemberN), ctx, key, count)
	return &MockCmdableSRandMemberNCall{Call: call}
}

// MockCmdableSRandMemberNCall wrap *gomock.Call
type MockCmdableSRandMemberNCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSRandMemberNCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSRandMemberNCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSRandMemberNCall) Do(f func(context.Context, string, int64) *redis.StringSliceCmd) *MockCmdableSRandMemberNCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSRandMemberNCall) DoAndReturn(f func(context.Context, string, int64) *redis.StringSliceCmd) *MockCmdableSRandMemberNCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SRem mocks base method.
func (m *MockCmdable) SRem(ctx context.Context, key string, members ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SRem", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SRem indicates an expected call of SRem.
func (mr *MockCmdableMockRecorder) SRem(ctx, key any, members ...any) *MockCmdableSRemCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SRem", reflect.TypeOf((*MockCmdable)(nil).SRem), varargs...)
	return &MockCmdableSRemCall{Call: call}
}

// MockCmdableSRemCall wrap *gomock.Call
type MockCmdableSRemCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSRemCall) Return(arg0 *redis.IntCmd) *MockCmdableSRemCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSRemCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableSRemCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSRemCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableSRemCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SScan mocks base method.
func (m *MockCmdable) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SScan", ctx, key, cursor, match, count)
	ret0, _ := ret[0].(*redis.ScanCmd)
	return ret0
}

// SScan indicates an expected call of SScan.
func (mr *MockCmdableMockRecorder) SScan(ctx, key, cursor, match, count any) *MockCmdableSScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SScan", reflect.TypeOf((*MockCmdable)(nil).SScan), ctx, key, cursor, match, count)
	return &MockCmdableSScanCall{Call: call}
}

// MockCmdableSScanCall wrap *gomock.Call
type MockCmdableSScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSScanCall) Return(arg0 *redis.ScanCmd) *MockCmdableSScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSScanCall) Do(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableSScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSScanCall) DoAndReturn(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableSScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SUnion mocks base method.
func (m *MockCmdable) SUnion(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SUnion", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// SUnion indicates an expected call of SUnion.
func (mr *MockCmdableMockRecorder) SUnion(ctx any, keys ...any) *MockCmdableSUnionCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SUnion", reflect.TypeOf((*MockCmdable)(nil).SUnion), varargs...)
	return &MockCmdableSUnionCall{Call: call}
}

// MockCmdableSUnionCall wrap *gomock.Call
type MockCmdableSUnionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSUnionCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSUnionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSUnionCall) Do(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableSUnionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSUnionCall) DoAndReturn(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableSUnionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SUnionStore mocks base method.
func (m *MockCmdable) SUnionStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destination}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SUnionStore", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SUnionStore indicates an expected call of SUnionStore.
func (mr *MockCmdableMockRecorder) SUnionStore(ctx, destination any, keys ...any) *MockCmdableSUnionStoreCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destination}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SUnionStore", reflect.TypeOf((*MockCmdable)(nil).SUnionStore), varargs...)
	return &MockCmdableSUnionStoreCall{Call: call}
}

// MockCmdableSUnionStoreCall wrap *gomock.Call
type MockCmdableSUnionStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSUnionStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableSUnionStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSUnionStoreCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableSUnionStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSUnionStoreCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableSUnionStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Save mocks base method.
func (m *MockCmdable) Save(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockCmdableMockRecorder) Save(ctx any) *MockCmdableSaveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockCmdable)(nil).Save), ctx)
	return &MockCmdableSaveCall{Call: call}
}

// MockCmdableSaveCall wrap *gomock.Call
type MockCmdableSaveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSaveCall) Return(arg0 *redis.StatusCmd) *MockCmdableSaveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSaveCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableSaveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSaveCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableSaveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Scan mocks base method.
func (m *MockCmdable) Scan(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Scan", ctx, cursor, match, count)
	ret0, _ := ret[0].(*redis.ScanCmd)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockCmdableMockRecorder) Scan(ctx, cursor, match, count any) *MockCmdableScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockCmdable)(nil).Scan), ctx, cursor, match, count)
	return &MockCmdableScanCall{Call: call}
}

// MockCmdableScanCall wrap *gomock.Call
type MockCmdableScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableScanCall) Return(arg0 *redis.ScanCmd) *MockCmdableScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableScanCall) Do(f func(context.Context, uint64, string, int64) *redis.ScanCmd) *MockCmdableScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableScanCall) DoAndReturn(f func(context.Context, uint64, string, int64) *redis.ScanCmd) *MockCmdableScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ScanType mocks base method.
func (m *MockCmdable) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScanType", ctx, cursor, match, count, keyType)
	ret0, _ := ret[0].(*redis.ScanCmd)
	return ret0
}

// ScanType indicates an expected call of ScanType.
func (mr *MockCmdableMockRecorder) ScanType(ctx, cursor, match, count, keyType any) *MockCmdableScanTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanType", reflect.TypeOf((*MockCmdable)(nil).ScanType), ctx, cursor, match, count, keyType)
	return &MockCmdableScanTypeCall{Call: call}
}

// MockCmdableScanTypeCall wrap *gomock.Call
type MockCmdableScanTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableScanTypeCall) Return(arg0 *redis.ScanCmd) *MockCmdableScanTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableScanTypeCall) Do(f func(context.Context, uint64, string, int64, string) *redis.ScanCmd) *MockCmdableScanTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableScanTypeCall) DoAndReturn(f func(context.Context, uint64, string, int64, string) *redis.ScanCmd) *MockCmdableScanTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ScriptExists mocks base method.
func (m *MockCmdable) ScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range hashes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScriptExists", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// ScriptExists indicates an expected call of ScriptExists.
func (mr *MockCmdableMockRecorder) ScriptExists(ctx any, hashes ...any) *MockCmdableScriptExistsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, hashes...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScriptExists", reflect.TypeOf((*MockCmdable)(nil).ScriptExists), varargs...)
	return &MockCmdableScriptExistsCall{Call: call}
}

// MockCmdableScriptExistsCall wrap *gomock.Call
type MockCmdableScriptExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableScriptExistsCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableScriptExistsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableScriptExistsCall) Do(f func(context.Context, ...string) *redis.BoolSliceCmd) *MockCmdableScriptExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableScriptExistsCall) DoAndReturn(f func(context.Context, ...string) *redis.BoolSliceCmd) *MockCmdableScriptExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ScriptFlush mocks base method.
func (m *MockCmdable) ScriptFlush(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScriptFlush", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ScriptFlush indicates an expected call of ScriptFlush.
func (mr *MockCmdableMockRecorder) ScriptFlush(ctx any) *MockCmdableScriptFlushCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScriptFlush", reflect.TypeOf((*MockCmdable)(nil).ScriptFlush), ctx)
	return &MockCmdableScriptFlushCall{Call: call}
}

// MockCmdableScriptFlushCall wrap *gomock.Call
type MockCmdableScriptFlushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableScriptFlushCall) Return(arg0 *redis.StatusCmd) *MockCmdableScriptFlushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableScriptFlushCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableScriptFlushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableScriptFlushCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableScriptFlushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ScriptKill mocks base method.
func (m *MockCmdable) ScriptKill(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScriptKill", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ScriptKill indicates an expected call of ScriptKill.
func (mr *MockCmdableMockRecorder) ScriptKill(ctx any) *MockCmdableScriptKillCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScriptKill", reflect.TypeOf((*MockCmdable)(nil).ScriptKill), ctx)
	return &MockCmdableScriptKillCall{Call: call}
}

// MockCmdableScriptKillCall wrap *gomock.Call
type MockCmdableScriptKillCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableScriptKillCall) Return(arg0 *redis.StatusCmd) *MockCmdableScriptKillCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableScriptKillCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableScriptKillCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableScriptKillCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableScriptKillCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ScriptLoad mocks base method.
func (m *MockCmdable) ScriptLoad(ctx context.Context, script string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScriptLoad", ctx, script)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ScriptLoad indicates an expected call of ScriptLoad.
func (mr *MockCmdableMockRecorder) ScriptLoad(ctx, script any) *MockCmdableScriptLoadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScriptLoad", reflect.TypeOf((*MockCmdable)(nil).ScriptLoad), ctx, script)
	return &MockCmdableScriptLoadCall{Call: call}
}

// MockCmdableScriptLoadCall wrap *gomock.Call
type MockCmdableScriptLoadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableScriptLoadCall) Return(arg0 *redis.StringCmd) *MockCmdableScriptLoadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableScriptLoadCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableScriptLoadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableScriptLoadCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableScriptLoadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Set mocks base method.
func (m *MockCmdable) Set(ctx context.Context, key string, value any, expiration time.Duration) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockCmdableMockRecorder) Set(ctx, key, value, expiration any) *MockCmdableSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCmdable)(nil).Set), ctx, key, value, expiration)
	return &MockCmdableSetCall{Call: call}
}

// MockCmdableSetCall wrap *gomock.Call
type MockCmdableSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSetCall) Return(arg0 *redis.StatusCmd) *MockCmdableSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSetCall) Do(f func(context.Context, string, any, time.Duration) *redis.StatusCmd) *MockCmdableSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSetCall) DoAndReturn(f func(context.Context, string, any, time.Duration) *redis.StatusCmd) *MockCmdableSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetArgs mocks base method.
func (m *MockCmdable) SetArgs(ctx context.Context, key string, value any, a redis.SetArgs) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetArgs", ctx, key, value, a)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// SetArgs indicates an expected call of SetArgs.
func (mr *MockCmdableMockRecorder) SetArgs(ctx, key, value, a any) *MockCmdableSetArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetArgs", reflect.TypeOf((*MockCmdable)(nil).SetArgs), ctx, key, value, a)
	return &MockCmdableSetArgsCall{Call: call}
}

// MockCmdableSetArgsCall wrap *gomock.Call
type MockCmdableSetArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSetArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableSetArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSetArgsCall) Do(f func(context.Context, string, any, redis.SetArgs) *redis.StatusCmd) *MockCmdableSetArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSetArgsCall) DoAndReturn(f func(context.Context, string, any, redis.SetArgs) *redis.StatusCmd) *MockCmdableSetArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBit mocks base method.
func (m *MockCmdable) SetBit(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetBit", ctx, key, offset, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SetBit indicates an expected call of SetBit.
func (mr *MockCmdableMockRecorder) SetBit(ctx, key, offset, value any) *MockCmdableSetBitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBit", reflect.TypeOf((*MockCmdable)(nil).SetBit), ctx, key, offset, value)
	return &MockCmdableSetBitCall{Call: call}
}

// MockCmdableSetBitCall wrap *gomock.Call
type MockCmdableSetBitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSetBitCall) Return(arg0 *redis.IntCmd) *MockCmdableSetBitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSetBitCall) Do(f func(context.Context, string, int64, int) *redis.IntCmd) *MockCmdableSetBitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSetBitCall) DoAndReturn(f func(context.Context, string, int64, int) *redis.IntCmd) *MockCmdableSetBitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetEx mocks base method.
func (m *MockCmdable) SetEx(ctx context.Context, key string, value any, expiration time.Duration) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetEx", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// SetEx indicates an expected call of SetEx.
func (mr *MockCmdableMockRecorder) SetEx(ctx, key, value, expiration any) *MockCmdableSetExCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEx", reflect.TypeOf((*MockCmdable)(nil).SetEx), ctx, key, value, expiration)
	return &MockCmdableSetExCall{Call: call}
}

// MockCmdableSetExCall wrap *gomock.Call
type MockCmdableSetExCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSetExCall) Return(arg0 *redis.StatusCmd) *MockCmdableSetExCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSetExCall) Do(f func(context.Context, string, any, time.Duration) *redis.StatusCmd) *MockCmdableSetExCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSetExCall) DoAndReturn(f func(context.Context, string, any, time.Duration) *redis.StatusCmd) *MockCmdableSetExCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNX mocks base method.
func (m *MockCmdable) SetNX(ctx context.Context, key string, value any, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetNX", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// SetNX indicates an expected call of SetNX.
func (mr *MockCmdableMockRecorder) SetNX(ctx, key, value, expiration any) *MockCmdableSetNXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNX", reflect.TypeOf((*MockCmdable)(nil).SetNX), ctx, key, value, expiration)
	return &MockCmdableSetNXCall{Call: call}
}

// MockCmdableSetNXCall wrap *gomock.Call
type MockCmdableSetNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSetNXCall) Return(arg0 *redis.BoolCmd) *MockCmdableSetNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSetNXCall) Do(f func(context.Context, string, any, time.Duration) *redis.BoolCmd) *MockCmdableSetNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSetNXCall) DoAndReturn(f func(context.Context, string, any, time.Duration) *redis.BoolCmd) *MockCmdableSetNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetRange mocks base method.
func (m *MockCmdable) SetRange(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRange", ctx, key, offset, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SetRange indicates an expected call of SetRange.
func (mr *MockCmdableMockRecorder) SetRange(ctx, key, offset, value any) *MockCmdableSetRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRange", reflect.TypeOf((*MockCmdable)(nil).SetRange), ctx, key, offset, value)
	return &MockCmdableSetRangeCall{Call: call}
}

// MockCmdableSetRangeCall wrap *gomock.Call
type MockCmdableSetRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSetRangeCall) Return(arg0 *redis.IntCmd) *MockCmdableSetRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSetRangeCall) Do(f func(context.Context, string, int64, string) *redis.IntCmd) *MockCmdableSetRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSetRangeCall) DoAndReturn(f func(context.Context, string, int64, string) *redis.IntCmd) *MockCmdableSetRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetXX mocks base method.
func (m *MockCmdable) SetXX(ctx context.Context, key string, value any, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetXX", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// SetXX indicates an expected call of SetXX.
func (mr *MockCmdableMockRecorder) SetXX(ctx, key, value, expiration any) *MockCmdableSetXXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetXX", reflect.TypeOf((*MockCmdable)(nil).SetXX), ctx, key, value, expiration)
	return &MockCmdableSetXXCall{Call: call}
}

// MockCmdableSetXXCall wrap *gomock.Call
type MockCmdableSetXXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSetXXCall) Return(arg0 *redis.BoolCmd) *MockCmdableSetXXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSetXXCall) Do(f func(context.Context, string, any, time.Duration) *redis.BoolCmd) *MockCmdableSetXXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSetXXCall) DoAndReturn(f func(context.Context, string, any, time.Duration) *redis.BoolCmd) *MockCmdableSetXXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Shutdown mocks base method.
func (m *MockCmdable) Shutdown(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Shutdown", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockCmdableMockRecorder) Shutdown(ctx any) *MockCmdableShutdownCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockCmdable)(nil).Shutdown), ctx)
	return &MockCmdableShutdownCall{Call: call}
}

// MockCmdableShutdownCall wrap *gomock.Call
type MockCmdableShutdownCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableShutdownCall) Return(arg0 *redis.StatusCmd) *MockCmdableShutdownCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableShutdownCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableShutdownCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableShutdownCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableShutdownCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ShutdownNoSave mocks base method.
func (m *MockCmdable) ShutdownNoSave(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShutdownNoSave", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ShutdownNoSave indicates an expected call of ShutdownNoSave.
func (mr *MockCmdableMockRecorder) ShutdownNoSave(ctx any) *MockCmdableShutdownNoSaveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownNoSave", reflect.TypeOf((*MockCmdable)(nil).ShutdownNoSave), ctx)
	return &MockCmdableShutdownNoSaveCall{Call: call}
}

// MockCmdableShutdownNoSaveCall wrap *gomock.Call
type MockCmdableShutdownNoSaveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableShutdownNoSaveCall) Return(arg0 *redis.StatusCmd) *MockCmdableShutdownNoSaveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableShutdownNoSaveCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableShutdownNoSaveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableShutdownNoSaveCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableShutdownNoSaveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ShutdownSave mocks base method.
func (m *MockCmdable) ShutdownSave(ctx context.Context) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShutdownSave", ctx)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// ShutdownSave indicates an expected call of ShutdownSave.
func (mr *MockCmdableMockRecorder) ShutdownSave(ctx any) *MockCmdableShutdownSaveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShutdownSave", reflect.TypeOf((*MockCmdable)(nil).ShutdownSave), ctx)
	return &MockCmdableShutdownSaveCall{Call: call}
}

// MockCmdableShutdownSaveCall wrap *gomock.Call
type MockCmdableShutdownSaveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableShutdownSaveCall) Return(arg0 *redis.StatusCmd) *MockCmdableShutdownSaveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableShutdownSaveCall) Do(f func(context.Context) *redis.StatusCmd) *MockCmdableShutdownSaveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableShutdownSaveCall) DoAndReturn(f func(context.Context) *redis.StatusCmd) *MockCmdableShutdownSaveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SlaveOf mocks base method.
func (m *MockCmdable) SlaveOf(ctx context.Context, host, port string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SlaveOf", ctx, host, port)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// SlaveOf indicates an expected call of SlaveOf.
func (mr *MockCmdableMockRecorder) SlaveOf(ctx, host, port any) *MockCmdableSlaveOfCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlaveOf", reflect.TypeOf((*MockCmdable)(nil).SlaveOf), ctx, host, port)
	return &MockCmdableSlaveOfCall{Call: call}
}

// MockCmdableSlaveOfCall wrap *gomock.Call
type MockCmdableSlaveOfCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSlaveOfCall) Return(arg0 *redis.StatusCmd) *MockCmdableSlaveOfCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSlaveOfCall) Do(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableSlaveOfCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSlaveOfCall) DoAndReturn(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableSlaveOfCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SlowLogGet mocks base method.
func (m *MockCmdable) SlowLogGet(ctx context.Context, num int64) *redis.SlowLogCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SlowLogGet", ctx, num)
	ret0, _ := ret[0].(*redis.SlowLogCmd)
	return ret0
}

// SlowLogGet indicates an expected call of SlowLogGet.
func (mr *MockCmdableMockRecorder) SlowLogGet(ctx, num any) *MockCmdableSlowLogGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlowLogGet", reflect.TypeOf((*MockCmdable)(nil).SlowLogGet), ctx, num)
	return &MockCmdableSlowLogGetCall{Call: call}
}

// MockCmdableSlowLogGetCall wrap *gomock.Call
type MockCmdableSlowLogGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSlowLogGetCall) Return(arg0 *redis.SlowLogCmd) *MockCmdableSlowLogGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSlowLogGetCall) Do(f func(context.Context, int64) *redis.SlowLogCmd) *MockCmdableSlowLogGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSlowLogGetCall) DoAndReturn(f func(context.Context, int64) *redis.SlowLogCmd) *MockCmdableSlowLogGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sort mocks base method.
func (m *MockCmdable) Sort(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sort", ctx, key, sort)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// Sort indicates an expected call of Sort.
func (mr *MockCmdableMockRecorder) Sort(ctx, key, sort any) *MockCmdableSortCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sort", reflect.TypeOf((*MockCmdable)(nil).Sort), ctx, key, sort)
	return &MockCmdableSortCall{Call: call}
}

// MockCmdableSortCall wrap *gomock.Call
type MockCmdableSortCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSortCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSortCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSortCall) Do(f func(context.Context, string, *redis.Sort) *redis.StringSliceCmd) *MockCmdableSortCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSortCall) DoAndReturn(f func(context.Context, string, *redis.Sort) *redis.StringSliceCmd) *MockCmdableSortCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SortInterfaces mocks base method.
func (m *MockCmdable) SortInterfaces(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SortInterfaces", ctx, key, sort)
	ret0, _ := ret[0].(*redis.SliceCmd)
	return ret0
}

// SortInterfaces indicates an expected call of SortInterfaces.
func (mr *MockCmdableMockRecorder) SortInterfaces(ctx, key, sort any) *MockCmdableSortInterfacesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SortInterfaces", reflect.TypeOf((*MockCmdable)(nil).SortInterfaces), ctx, key, sort)
	return &MockCmdableSortInterfacesCall{Call: call}
}

// MockCmdableSortInterfacesCall wrap *gomock.Call
type MockCmdableSortInterfacesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSortInterfacesCall) Return(arg0 *redis.SliceCmd) *MockCmdableSortInterfacesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSortInterfacesCall) Do(f func(context.Context, string, *redis.Sort) *redis.SliceCmd) *MockCmdableSortInterfacesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSortInterfacesCall) DoAndReturn(f func(context.Context, string, *redis.Sort) *redis.SliceCmd) *MockCmdableSortInterfacesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SortRO mocks base method.
func (m *MockCmdable) SortRO(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SortRO", ctx, key, sort)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// SortRO indicates an expected call of SortRO.
func (mr *MockCmdableMockRecorder) SortRO(ctx, key, sort any) *MockCmdableSortROCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SortRO", reflect.TypeOf((*MockCmdable)(nil).SortRO), ctx, key, sort)
	return &MockCmdableSortROCall{Call: call}
}

// MockCmdableSortROCall wrap *gomock.Call
type MockCmdableSortROCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSortROCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableSortROCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSortROCall) Do(f func(context.Context, string, *redis.Sort) *redis.StringSliceCmd) *MockCmdableSortROCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSortROCall) DoAndReturn(f func(context.Context, string, *redis.Sort) *redis.StringSliceCmd) *MockCmdableSortROCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SortStore mocks base method.
func (m *MockCmdable) SortStore(ctx context.Context, key, store string, sort *redis.Sort) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SortStore", ctx, key, store, sort)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// SortStore indicates an expected call of SortStore.
func (mr *MockCmdableMockRecorder) SortStore(ctx, key, store, sort any) *MockCmdableSortStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SortStore", reflect.TypeOf((*MockCmdable)(nil).SortStore), ctx, key, store, sort)
	return &MockCmdableSortStoreCall{Call: call}
}

// MockCmdableSortStoreCall wrap *gomock.Call
type MockCmdableSortStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableSortStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableSortStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableSortStoreCall) Do(f func(context.Context, string, string, *redis.Sort) *redis.IntCmd) *MockCmdableSortStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableSortStoreCall) DoAndReturn(f func(context.Context, string, string, *redis.Sort) *redis.IntCmd) *MockCmdableSortStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StrLen mocks base method.
func (m *MockCmdable) StrLen(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StrLen", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// StrLen indicates an expected call of StrLen.
func (mr *MockCmdableMockRecorder) StrLen(ctx, key any) *MockCmdableStrLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StrLen", reflect.TypeOf((*MockCmdable)(nil).StrLen), ctx, key)
	return &MockCmdableStrLenCall{Call: call}
}

// MockCmdableStrLenCall wrap *gomock.Call
type MockCmdableStrLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableStrLenCall) Return(arg0 *redis.IntCmd) *MockCmdableStrLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableStrLenCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableStrLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableStrLenCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableStrLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestAdd mocks base method.
func (m *MockCmdable) TDigestAdd(ctx context.Context, key string, elements ...float64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestAdd", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TDigestAdd indicates an expected call of TDigestAdd.
func (mr *MockCmdableMockRecorder) TDigestAdd(ctx, key any, elements ...any) *MockCmdableTDigestAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestAdd", reflect.TypeOf((*MockCmdable)(nil).TDigestAdd), varargs...)
	return &MockCmdableTDigestAddCall{Call: call}
}

// MockCmdableTDigestAddCall wrap *gomock.Call
type MockCmdableTDigestAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestAddCall) Return(arg0 *redis.StatusCmd) *MockCmdableTDigestAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestAddCall) Do(f func(context.Context, string, ...float64) *redis.StatusCmd) *MockCmdableTDigestAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestAddCall) DoAndReturn(f func(context.Context, string, ...float64) *redis.StatusCmd) *MockCmdableTDigestAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestByRank mocks base method.
func (m *MockCmdable) TDigestByRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range rank {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestByRank", varargs...)
	ret0, _ := ret[0].(*redis.FloatSliceCmd)
	return ret0
}

// TDigestByRank indicates an expected call of TDigestByRank.
func (mr *MockCmdableMockRecorder) TDigestByRank(ctx, key any, rank ...any) *MockCmdableTDigestByRankCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, rank...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestByRank", reflect.TypeOf((*MockCmdable)(nil).TDigestByRank), varargs...)
	return &MockCmdableTDigestByRankCall{Call: call}
}

// MockCmdableTDigestByRankCall wrap *gomock.Call
type MockCmdableTDigestByRankCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestByRankCall) Return(arg0 *redis.FloatSliceCmd) *MockCmdableTDigestByRankCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestByRankCall) Do(f func(context.Context, string, ...uint64) *redis.FloatSliceCmd) *MockCmdableTDigestByRankCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestByRankCall) DoAndReturn(f func(context.Context, string, ...uint64) *redis.FloatSliceCmd) *MockCmdableTDigestByRankCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestByRevRank mocks base method.
func (m *MockCmdable) TDigestByRevRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range rank {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestByRevRank", varargs...)
	ret0, _ := ret[0].(*redis.FloatSliceCmd)
	return ret0
}

// TDigestByRevRank indicates an expected call of TDigestByRevRank.
func (mr *MockCmdableMockRecorder) TDigestByRevRank(ctx, key any, rank ...any) *MockCmdableTDigestByRevRankCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, rank...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestByRevRank", reflect.TypeOf((*MockCmdable)(nil).TDigestByRevRank), varargs...)
	return &MockCmdableTDigestByRevRankCall{Call: call}
}

// MockCmdableTDigestByRevRankCall wrap *gomock.Call
type MockCmdableTDigestByRevRankCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestByRevRankCall) Return(arg0 *redis.FloatSliceCmd) *MockCmdableTDigestByRevRankCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestByRevRankCall) Do(f func(context.Context, string, ...uint64) *redis.FloatSliceCmd) *MockCmdableTDigestByRevRankCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestByRevRankCall) DoAndReturn(f func(context.Context, string, ...uint64) *redis.FloatSliceCmd) *MockCmdableTDigestByRevRankCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestCDF mocks base method.
func (m *MockCmdable) TDigestCDF(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestCDF", varargs...)
	ret0, _ := ret[0].(*redis.FloatSliceCmd)
	return ret0
}

// TDigestCDF indicates an expected call of TDigestCDF.
func (mr *MockCmdableMockRecorder) TDigestCDF(ctx, key any, elements ...any) *MockCmdableTDigestCDFCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestCDF", reflect.TypeOf((*MockCmdable)(nil).TDigestCDF), varargs...)
	return &MockCmdableTDigestCDFCall{Call: call}
}

// MockCmdableTDigestCDFCall wrap *gomock.Call
type MockCmdableTDigestCDFCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestCDFCall) Return(arg0 *redis.FloatSliceCmd) *MockCmdableTDigestCDFCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestCDFCall) Do(f func(context.Context, string, ...float64) *redis.FloatSliceCmd) *MockCmdableTDigestCDFCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestCDFCall) DoAndReturn(f func(context.Context, string, ...float64) *redis.FloatSliceCmd) *MockCmdableTDigestCDFCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestCreate mocks base method.
func (m *MockCmdable) TDigestCreate(ctx context.Context, key string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TDigestCreate", ctx, key)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TDigestCreate indicates an expected call of TDigestCreate.
func (mr *MockCmdableMockRecorder) TDigestCreate(ctx, key any) *MockCmdableTDigestCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestCreate", reflect.TypeOf((*MockCmdable)(nil).TDigestCreate), ctx, key)
	return &MockCmdableTDigestCreateCall{Call: call}
}

// MockCmdableTDigestCreateCall wrap *gomock.Call
type MockCmdableTDigestCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestCreateCall) Return(arg0 *redis.StatusCmd) *MockCmdableTDigestCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestCreateCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTDigestCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestCreateCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTDigestCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestCreateWithCompression mocks base method.
func (m *MockCmdable) TDigestCreateWithCompression(ctx context.Context, key string, compression int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TDigestCreateWithCompression", ctx, key, compression)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TDigestCreateWithCompression indicates an expected call of TDigestCreateWithCompression.
func (mr *MockCmdableMockRecorder) TDigestCreateWithCompression(ctx, key, compression any) *MockCmdableTDigestCreateWithCompressionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestCreateWithCompression", reflect.TypeOf((*MockCmdable)(nil).TDigestCreateWithCompression), ctx, key, compression)
	return &MockCmdableTDigestCreateWithCompressionCall{Call: call}
}

// MockCmdableTDigestCreateWithCompressionCall wrap *gomock.Call
type MockCmdableTDigestCreateWithCompressionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestCreateWithCompressionCall) Return(arg0 *redis.StatusCmd) *MockCmdableTDigestCreateWithCompressionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestCreateWithCompressionCall) Do(f func(context.Context, string, int64) *redis.StatusCmd) *MockCmdableTDigestCreateWithCompressionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestCreateWithCompressionCall) DoAndReturn(f func(context.Context, string, int64) *redis.StatusCmd) *MockCmdableTDigestCreateWithCompressionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestInfo mocks base method.
func (m *MockCmdable) TDigestInfo(ctx context.Context, key string) *redis.TDigestInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TDigestInfo", ctx, key)
	ret0, _ := ret[0].(*redis.TDigestInfoCmd)
	return ret0
}

// TDigestInfo indicates an expected call of TDigestInfo.
func (mr *MockCmdableMockRecorder) TDigestInfo(ctx, key any) *MockCmdableTDigestInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestInfo", reflect.TypeOf((*MockCmdable)(nil).TDigestInfo), ctx, key)
	return &MockCmdableTDigestInfoCall{Call: call}
}

// MockCmdableTDigestInfoCall wrap *gomock.Call
type MockCmdableTDigestInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestInfoCall) Return(arg0 *redis.TDigestInfoCmd) *MockCmdableTDigestInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestInfoCall) Do(f func(context.Context, string) *redis.TDigestInfoCmd) *MockCmdableTDigestInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestInfoCall) DoAndReturn(f func(context.Context, string) *redis.TDigestInfoCmd) *MockCmdableTDigestInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestMax mocks base method.
func (m *MockCmdable) TDigestMax(ctx context.Context, key string) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TDigestMax", ctx, key)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// TDigestMax indicates an expected call of TDigestMax.
func (mr *MockCmdableMockRecorder) TDigestMax(ctx, key any) *MockCmdableTDigestMaxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestMax", reflect.TypeOf((*MockCmdable)(nil).TDigestMax), ctx, key)
	return &MockCmdableTDigestMaxCall{Call: call}
}

// MockCmdableTDigestMaxCall wrap *gomock.Call
type MockCmdableTDigestMaxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestMaxCall) Return(arg0 *redis.FloatCmd) *MockCmdableTDigestMaxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestMaxCall) Do(f func(context.Context, string) *redis.FloatCmd) *MockCmdableTDigestMaxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestMaxCall) DoAndReturn(f func(context.Context, string) *redis.FloatCmd) *MockCmdableTDigestMaxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestMerge mocks base method.
func (m *MockCmdable) TDigestMerge(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destKey, options}
	for _, a := range sourceKeys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestMerge", varargs...)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TDigestMerge indicates an expected call of TDigestMerge.
func (mr *MockCmdableMockRecorder) TDigestMerge(ctx, destKey, options any, sourceKeys ...any) *MockCmdableTDigestMergeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destKey, options}, sourceKeys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestMerge", reflect.TypeOf((*MockCmdable)(nil).TDigestMerge), varargs...)
	return &MockCmdableTDigestMergeCall{Call: call}
}

// MockCmdableTDigestMergeCall wrap *gomock.Call
type MockCmdableTDigestMergeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestMergeCall) Return(arg0 *redis.StatusCmd) *MockCmdableTDigestMergeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestMergeCall) Do(f func(context.Context, string, *redis.TDigestMergeOptions, ...string) *redis.StatusCmd) *MockCmdableTDigestMergeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestMergeCall) DoAndReturn(f func(context.Context, string, *redis.TDigestMergeOptions, ...string) *redis.StatusCmd) *MockCmdableTDigestMergeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestMin mocks base method.
func (m *MockCmdable) TDigestMin(ctx context.Context, key string) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TDigestMin", ctx, key)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// TDigestMin indicates an expected call of TDigestMin.
func (mr *MockCmdableMockRecorder) TDigestMin(ctx, key any) *MockCmdableTDigestMinCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestMin", reflect.TypeOf((*MockCmdable)(nil).TDigestMin), ctx, key)
	return &MockCmdableTDigestMinCall{Call: call}
}

// MockCmdableTDigestMinCall wrap *gomock.Call
type MockCmdableTDigestMinCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestMinCall) Return(arg0 *redis.FloatCmd) *MockCmdableTDigestMinCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestMinCall) Do(f func(context.Context, string) *redis.FloatCmd) *MockCmdableTDigestMinCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestMinCall) DoAndReturn(f func(context.Context, string) *redis.FloatCmd) *MockCmdableTDigestMinCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestQuantile mocks base method.
func (m *MockCmdable) TDigestQuantile(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestQuantile", varargs...)
	ret0, _ := ret[0].(*redis.FloatSliceCmd)
	return ret0
}

// TDigestQuantile indicates an expected call of TDigestQuantile.
func (mr *MockCmdableMockRecorder) TDigestQuantile(ctx, key any, elements ...any) *MockCmdableTDigestQuantileCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestQuantile", reflect.TypeOf((*MockCmdable)(nil).TDigestQuantile), varargs...)
	return &MockCmdableTDigestQuantileCall{Call: call}
}

// MockCmdableTDigestQuantileCall wrap *gomock.Call
type MockCmdableTDigestQuantileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestQuantileCall) Return(arg0 *redis.FloatSliceCmd) *MockCmdableTDigestQuantileCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestQuantileCall) Do(f func(context.Context, string, ...float64) *redis.FloatSliceCmd) *MockCmdableTDigestQuantileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestQuantileCall) DoAndReturn(f func(context.Context, string, ...float64) *redis.FloatSliceCmd) *MockCmdableTDigestQuantileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestRank mocks base method.
func (m *MockCmdable) TDigestRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestRank", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// TDigestRank indicates an expected call of TDigestRank.
func (mr *MockCmdableMockRecorder) TDigestRank(ctx, key any, values ...any) *MockCmdableTDigestRankCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestRank", reflect.TypeOf((*MockCmdable)(nil).TDigestRank), varargs...)
	return &MockCmdableTDigestRankCall{Call: call}
}

// MockCmdableTDigestRankCall wrap *gomock.Call
type MockCmdableTDigestRankCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestRankCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableTDigestRankCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestRankCall) Do(f func(context.Context, string, ...float64) *redis.IntSliceCmd) *MockCmdableTDigestRankCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestRankCall) DoAndReturn(f func(context.Context, string, ...float64) *redis.IntSliceCmd) *MockCmdableTDigestRankCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestReset mocks base method.
func (m *MockCmdable) TDigestReset(ctx context.Context, key string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TDigestReset", ctx, key)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TDigestReset indicates an expected call of TDigestReset.
func (mr *MockCmdableMockRecorder) TDigestReset(ctx, key any) *MockCmdableTDigestResetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestReset", reflect.TypeOf((*MockCmdable)(nil).TDigestReset), ctx, key)
	return &MockCmdableTDigestResetCall{Call: call}
}

// MockCmdableTDigestResetCall wrap *gomock.Call
type MockCmdableTDigestResetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestResetCall) Return(arg0 *redis.StatusCmd) *MockCmdableTDigestResetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestResetCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTDigestResetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestResetCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTDigestResetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestRevRank mocks base method.
func (m *MockCmdable) TDigestRevRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range values {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TDigestRevRank", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// TDigestRevRank indicates an expected call of TDigestRevRank.
func (mr *MockCmdableMockRecorder) TDigestRevRank(ctx, key any, values ...any) *MockCmdableTDigestRevRankCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, values...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestRevRank", reflect.TypeOf((*MockCmdable)(nil).TDigestRevRank), varargs...)
	return &MockCmdableTDigestRevRankCall{Call: call}
}

// MockCmdableTDigestRevRankCall wrap *gomock.Call
type MockCmdableTDigestRevRankCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestRevRankCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableTDigestRevRankCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestRevRankCall) Do(f func(context.Context, string, ...float64) *redis.IntSliceCmd) *MockCmdableTDigestRevRankCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestRevRankCall) DoAndReturn(f func(context.Context, string, ...float64) *redis.IntSliceCmd) *MockCmdableTDigestRevRankCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TDigestTrimmedMean mocks base method.
func (m *MockCmdable) TDigestTrimmedMean(ctx context.Context, key string, lowCutQuantile, highCutQuantile float64) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TDigestTrimmedMean", ctx, key, lowCutQuantile, highCutQuantile)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// TDigestTrimmedMean indicates an expected call of TDigestTrimmedMean.
func (mr *MockCmdableMockRecorder) TDigestTrimmedMean(ctx, key, lowCutQuantile, highCutQuantile any) *MockCmdableTDigestTrimmedMeanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TDigestTrimmedMean", reflect.TypeOf((*MockCmdable)(nil).TDigestTrimmedMean), ctx, key, lowCutQuantile, highCutQuantile)
	return &MockCmdableTDigestTrimmedMeanCall{Call: call}
}

// MockCmdableTDigestTrimmedMeanCall wrap *gomock.Call
type MockCmdableTDigestTrimmedMeanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTDigestTrimmedMeanCall) Return(arg0 *redis.FloatCmd) *MockCmdableTDigestTrimmedMeanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTDigestTrimmedMeanCall) Do(f func(context.Context, string, float64, float64) *redis.FloatCmd) *MockCmdableTDigestTrimmedMeanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTDigestTrimmedMeanCall) DoAndReturn(f func(context.Context, string, float64, float64) *redis.FloatCmd) *MockCmdableTDigestTrimmedMeanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSAdd mocks base method.
func (m *MockCmdable) TSAdd(ctx context.Context, key string, timestamp any, value float64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSAdd", ctx, key, timestamp, value)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// TSAdd indicates an expected call of TSAdd.
func (mr *MockCmdableMockRecorder) TSAdd(ctx, key, timestamp, value any) *MockCmdableTSAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSAdd", reflect.TypeOf((*MockCmdable)(nil).TSAdd), ctx, key, timestamp, value)
	return &MockCmdableTSAddCall{Call: call}
}

// MockCmdableTSAddCall wrap *gomock.Call
type MockCmdableTSAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSAddCall) Return(arg0 *redis.IntCmd) *MockCmdableTSAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSAddCall) Do(f func(context.Context, string, any, float64) *redis.IntCmd) *MockCmdableTSAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSAddCall) DoAndReturn(f func(context.Context, string, any, float64) *redis.IntCmd) *MockCmdableTSAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSAddWithArgs mocks base method.
func (m *MockCmdable) TSAddWithArgs(ctx context.Context, key string, timestamp any, value float64, options *redis.TSOptions) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSAddWithArgs", ctx, key, timestamp, value, options)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// TSAddWithArgs indicates an expected call of TSAddWithArgs.
func (mr *MockCmdableMockRecorder) TSAddWithArgs(ctx, key, timestamp, value, options any) *MockCmdableTSAddWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSAddWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSAddWithArgs), ctx, key, timestamp, value, options)
	return &MockCmdableTSAddWithArgsCall{Call: call}
}

// MockCmdableTSAddWithArgsCall wrap *gomock.Call
type MockCmdableTSAddWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSAddWithArgsCall) Return(arg0 *redis.IntCmd) *MockCmdableTSAddWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSAddWithArgsCall) Do(f func(context.Context, string, any, float64, *redis.TSOptions) *redis.IntCmd) *MockCmdableTSAddWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSAddWithArgsCall) DoAndReturn(f func(context.Context, string, any, float64, *redis.TSOptions) *redis.IntCmd) *MockCmdableTSAddWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSAlter mocks base method.
func (m *MockCmdable) TSAlter(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSAlter", ctx, key, options)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TSAlter indicates an expected call of TSAlter.
func (mr *MockCmdableMockRecorder) TSAlter(ctx, key, options any) *MockCmdableTSAlterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSAlter", reflect.TypeOf((*MockCmdable)(nil).TSAlter), ctx, key, options)
	return &MockCmdableTSAlterCall{Call: call}
}

// MockCmdableTSAlterCall wrap *gomock.Call
type MockCmdableTSAlterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSAlterCall) Return(arg0 *redis.StatusCmd) *MockCmdableTSAlterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSAlterCall) Do(f func(context.Context, string, *redis.TSAlterOptions) *redis.StatusCmd) *MockCmdableTSAlterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSAlterCall) DoAndReturn(f func(context.Context, string, *redis.TSAlterOptions) *redis.StatusCmd) *MockCmdableTSAlterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSCreate mocks base method.
func (m *MockCmdable) TSCreate(ctx context.Context, key string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSCreate", ctx, key)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TSCreate indicates an expected call of TSCreate.
func (mr *MockCmdableMockRecorder) TSCreate(ctx, key any) *MockCmdableTSCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSCreate", reflect.TypeOf((*MockCmdable)(nil).TSCreate), ctx, key)
	return &MockCmdableTSCreateCall{Call: call}
}

// MockCmdableTSCreateCall wrap *gomock.Call
type MockCmdableTSCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSCreateCall) Return(arg0 *redis.StatusCmd) *MockCmdableTSCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSCreateCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTSCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSCreateCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTSCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSCreateRule mocks base method.
func (m *MockCmdable) TSCreateRule(ctx context.Context, sourceKey, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSCreateRule", ctx, sourceKey, destKey, aggregator, bucketDuration)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TSCreateRule indicates an expected call of TSCreateRule.
func (mr *MockCmdableMockRecorder) TSCreateRule(ctx, sourceKey, destKey, aggregator, bucketDuration any) *MockCmdableTSCreateRuleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSCreateRule", reflect.TypeOf((*MockCmdable)(nil).TSCreateRule), ctx, sourceKey, destKey, aggregator, bucketDuration)
	return &MockCmdableTSCreateRuleCall{Call: call}
}

// MockCmdableTSCreateRuleCall wrap *gomock.Call
type MockCmdableTSCreateRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSCreateRuleCall) Return(arg0 *redis.StatusCmd) *MockCmdableTSCreateRuleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSCreateRuleCall) Do(f func(context.Context, string, string, redis.Aggregator, int) *redis.StatusCmd) *MockCmdableTSCreateRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSCreateRuleCall) DoAndReturn(f func(context.Context, string, string, redis.Aggregator, int) *redis.StatusCmd) *MockCmdableTSCreateRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSCreateRuleWithArgs mocks base method.
func (m *MockCmdable) TSCreateRuleWithArgs(ctx context.Context, sourceKey, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSCreateRuleWithArgs", ctx, sourceKey, destKey, aggregator, bucketDuration, options)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TSCreateRuleWithArgs indicates an expected call of TSCreateRuleWithArgs.
func (mr *MockCmdableMockRecorder) TSCreateRuleWithArgs(ctx, sourceKey, destKey, aggregator, bucketDuration, options any) *MockCmdableTSCreateRuleWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSCreateRuleWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSCreateRuleWithArgs), ctx, sourceKey, destKey, aggregator, bucketDuration, options)
	return &MockCmdableTSCreateRuleWithArgsCall{Call: call}
}

// MockCmdableTSCreateRuleWithArgsCall wrap *gomock.Call
type MockCmdableTSCreateRuleWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSCreateRuleWithArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableTSCreateRuleWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSCreateRuleWithArgsCall) Do(f func(context.Context, string, string, redis.Aggregator, int, *redis.TSCreateRuleOptions) *redis.StatusCmd) *MockCmdableTSCreateRuleWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSCreateRuleWithArgsCall) DoAndReturn(f func(context.Context, string, string, redis.Aggregator, int, *redis.TSCreateRuleOptions) *redis.StatusCmd) *MockCmdableTSCreateRuleWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSCreateWithArgs mocks base method.
func (m *MockCmdable) TSCreateWithArgs(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSCreateWithArgs", ctx, key, options)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TSCreateWithArgs indicates an expected call of TSCreateWithArgs.
func (mr *MockCmdableMockRecorder) TSCreateWithArgs(ctx, key, options any) *MockCmdableTSCreateWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSCreateWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSCreateWithArgs), ctx, key, options)
	return &MockCmdableTSCreateWithArgsCall{Call: call}
}

// MockCmdableTSCreateWithArgsCall wrap *gomock.Call
type MockCmdableTSCreateWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSCreateWithArgsCall) Return(arg0 *redis.StatusCmd) *MockCmdableTSCreateWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSCreateWithArgsCall) Do(f func(context.Context, string, *redis.TSOptions) *redis.StatusCmd) *MockCmdableTSCreateWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSCreateWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.TSOptions) *redis.StatusCmd) *MockCmdableTSCreateWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSDecrBy mocks base method.
func (m *MockCmdable) TSDecrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSDecrBy", ctx, Key, timestamp)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// TSDecrBy indicates an expected call of TSDecrBy.
func (mr *MockCmdableMockRecorder) TSDecrBy(ctx, Key, timestamp any) *MockCmdableTSDecrByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSDecrBy", reflect.TypeOf((*MockCmdable)(nil).TSDecrBy), ctx, Key, timestamp)
	return &MockCmdableTSDecrByCall{Call: call}
}

// MockCmdableTSDecrByCall wrap *gomock.Call
type MockCmdableTSDecrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSDecrByCall) Return(arg0 *redis.IntCmd) *MockCmdableTSDecrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSDecrByCall) Do(f func(context.Context, string, float64) *redis.IntCmd) *MockCmdableTSDecrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSDecrByCall) DoAndReturn(f func(context.Context, string, float64) *redis.IntCmd) *MockCmdableTSDecrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSDecrByWithArgs mocks base method.
func (m *MockCmdable) TSDecrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSDecrByWithArgs", ctx, key, timestamp, options)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// TSDecrByWithArgs indicates an expected call of TSDecrByWithArgs.
func (mr *MockCmdableMockRecorder) TSDecrByWithArgs(ctx, key, timestamp, options any) *MockCmdableTSDecrByWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSDecrByWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSDecrByWithArgs), ctx, key, timestamp, options)
	return &MockCmdableTSDecrByWithArgsCall{Call: call}
}

// MockCmdableTSDecrByWithArgsCall wrap *gomock.Call
type MockCmdableTSDecrByWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSDecrByWithArgsCall) Return(arg0 *redis.IntCmd) *MockCmdableTSDecrByWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSDecrByWithArgsCall) Do(f func(context.Context, string, float64, *redis.TSIncrDecrOptions) *redis.IntCmd) *MockCmdableTSDecrByWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSDecrByWithArgsCall) DoAndReturn(f func(context.Context, string, float64, *redis.TSIncrDecrOptions) *redis.IntCmd) *MockCmdableTSDecrByWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSDel mocks base method.
func (m *MockCmdable) TSDel(ctx context.Context, Key string, fromTimestamp, toTimestamp int) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSDel", ctx, Key, fromTimestamp, toTimestamp)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// TSDel indicates an expected call of TSDel.
func (mr *MockCmdableMockRecorder) TSDel(ctx, Key, fromTimestamp, toTimestamp any) *MockCmdableTSDelCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSDel", reflect.TypeOf((*MockCmdable)(nil).TSDel), ctx, Key, fromTimestamp, toTimestamp)
	return &MockCmdableTSDelCall{Call: call}
}

// MockCmdableTSDelCall wrap *gomock.Call
type MockCmdableTSDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSDelCall) Return(arg0 *redis.IntCmd) *MockCmdableTSDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSDelCall) Do(f func(context.Context, string, int, int) *redis.IntCmd) *MockCmdableTSDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSDelCall) DoAndReturn(f func(context.Context, string, int, int) *redis.IntCmd) *MockCmdableTSDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSDeleteRule mocks base method.
func (m *MockCmdable) TSDeleteRule(ctx context.Context, sourceKey, destKey string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSDeleteRule", ctx, sourceKey, destKey)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TSDeleteRule indicates an expected call of TSDeleteRule.
func (mr *MockCmdableMockRecorder) TSDeleteRule(ctx, sourceKey, destKey any) *MockCmdableTSDeleteRuleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSDeleteRule", reflect.TypeOf((*MockCmdable)(nil).TSDeleteRule), ctx, sourceKey, destKey)
	return &MockCmdableTSDeleteRuleCall{Call: call}
}

// MockCmdableTSDeleteRuleCall wrap *gomock.Call
type MockCmdableTSDeleteRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSDeleteRuleCall) Return(arg0 *redis.StatusCmd) *MockCmdableTSDeleteRuleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSDeleteRuleCall) Do(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableTSDeleteRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSDeleteRuleCall) DoAndReturn(f func(context.Context, string, string) *redis.StatusCmd) *MockCmdableTSDeleteRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSGet mocks base method.
func (m *MockCmdable) TSGet(ctx context.Context, key string) *redis.TSTimestampValueCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSGet", ctx, key)
	ret0, _ := ret[0].(*redis.TSTimestampValueCmd)
	return ret0
}

// TSGet indicates an expected call of TSGet.
func (mr *MockCmdableMockRecorder) TSGet(ctx, key any) *MockCmdableTSGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSGet", reflect.TypeOf((*MockCmdable)(nil).TSGet), ctx, key)
	return &MockCmdableTSGetCall{Call: call}
}

// MockCmdableTSGetCall wrap *gomock.Call
type MockCmdableTSGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSGetCall) Return(arg0 *redis.TSTimestampValueCmd) *MockCmdableTSGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSGetCall) Do(f func(context.Context, string) *redis.TSTimestampValueCmd) *MockCmdableTSGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSGetCall) DoAndReturn(f func(context.Context, string) *redis.TSTimestampValueCmd) *MockCmdableTSGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSGetWithArgs mocks base method.
func (m *MockCmdable) TSGetWithArgs(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSGetWithArgs", ctx, key, options)
	ret0, _ := ret[0].(*redis.TSTimestampValueCmd)
	return ret0
}

// TSGetWithArgs indicates an expected call of TSGetWithArgs.
func (mr *MockCmdableMockRecorder) TSGetWithArgs(ctx, key, options any) *MockCmdableTSGetWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSGetWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSGetWithArgs), ctx, key, options)
	return &MockCmdableTSGetWithArgsCall{Call: call}
}

// MockCmdableTSGetWithArgsCall wrap *gomock.Call
type MockCmdableTSGetWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSGetWithArgsCall) Return(arg0 *redis.TSTimestampValueCmd) *MockCmdableTSGetWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSGetWithArgsCall) Do(f func(context.Context, string, *redis.TSGetOptions) *redis.TSTimestampValueCmd) *MockCmdableTSGetWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSGetWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.TSGetOptions) *redis.TSTimestampValueCmd) *MockCmdableTSGetWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSIncrBy mocks base method.
func (m *MockCmdable) TSIncrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSIncrBy", ctx, Key, timestamp)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// TSIncrBy indicates an expected call of TSIncrBy.
func (mr *MockCmdableMockRecorder) TSIncrBy(ctx, Key, timestamp any) *MockCmdableTSIncrByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSIncrBy", reflect.TypeOf((*MockCmdable)(nil).TSIncrBy), ctx, Key, timestamp)
	return &MockCmdableTSIncrByCall{Call: call}
}

// MockCmdableTSIncrByCall wrap *gomock.Call
type MockCmdableTSIncrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSIncrByCall) Return(arg0 *redis.IntCmd) *MockCmdableTSIncrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSIncrByCall) Do(f func(context.Context, string, float64) *redis.IntCmd) *MockCmdableTSIncrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSIncrByCall) DoAndReturn(f func(context.Context, string, float64) *redis.IntCmd) *MockCmdableTSIncrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSIncrByWithArgs mocks base method.
func (m *MockCmdable) TSIncrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSIncrByWithArgs", ctx, key, timestamp, options)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// TSIncrByWithArgs indicates an expected call of TSIncrByWithArgs.
func (mr *MockCmdableMockRecorder) TSIncrByWithArgs(ctx, key, timestamp, options any) *MockCmdableTSIncrByWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSIncrByWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSIncrByWithArgs), ctx, key, timestamp, options)
	return &MockCmdableTSIncrByWithArgsCall{Call: call}
}

// MockCmdableTSIncrByWithArgsCall wrap *gomock.Call
type MockCmdableTSIncrByWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSIncrByWithArgsCall) Return(arg0 *redis.IntCmd) *MockCmdableTSIncrByWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSIncrByWithArgsCall) Do(f func(context.Context, string, float64, *redis.TSIncrDecrOptions) *redis.IntCmd) *MockCmdableTSIncrByWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSIncrByWithArgsCall) DoAndReturn(f func(context.Context, string, float64, *redis.TSIncrDecrOptions) *redis.IntCmd) *MockCmdableTSIncrByWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSInfo mocks base method.
func (m *MockCmdable) TSInfo(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSInfo", ctx, key)
	ret0, _ := ret[0].(*redis.MapStringInterfaceCmd)
	return ret0
}

// TSInfo indicates an expected call of TSInfo.
func (mr *MockCmdableMockRecorder) TSInfo(ctx, key any) *MockCmdableTSInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSInfo", reflect.TypeOf((*MockCmdable)(nil).TSInfo), ctx, key)
	return &MockCmdableTSInfoCall{Call: call}
}

// MockCmdableTSInfoCall wrap *gomock.Call
type MockCmdableTSInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSInfoCall) Return(arg0 *redis.MapStringInterfaceCmd) *MockCmdableTSInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSInfoCall) Do(f func(context.Context, string) *redis.MapStringInterfaceCmd) *MockCmdableTSInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSInfoCall) DoAndReturn(f func(context.Context, string) *redis.MapStringInterfaceCmd) *MockCmdableTSInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSInfoWithArgs mocks base method.
func (m *MockCmdable) TSInfoWithArgs(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSInfoWithArgs", ctx, key, options)
	ret0, _ := ret[0].(*redis.MapStringInterfaceCmd)
	return ret0
}

// TSInfoWithArgs indicates an expected call of TSInfoWithArgs.
func (mr *MockCmdableMockRecorder) TSInfoWithArgs(ctx, key, options any) *MockCmdableTSInfoWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSInfoWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSInfoWithArgs), ctx, key, options)
	return &MockCmdableTSInfoWithArgsCall{Call: call}
}

// MockCmdableTSInfoWithArgsCall wrap *gomock.Call
type MockCmdableTSInfoWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSInfoWithArgsCall) Return(arg0 *redis.MapStringInterfaceCmd) *MockCmdableTSInfoWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSInfoWithArgsCall) Do(f func(context.Context, string, *redis.TSInfoOptions) *redis.MapStringInterfaceCmd) *MockCmdableTSInfoWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSInfoWithArgsCall) DoAndReturn(f func(context.Context, string, *redis.TSInfoOptions) *redis.MapStringInterfaceCmd) *MockCmdableTSInfoWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSMAdd mocks base method.
func (m *MockCmdable) TSMAdd(ctx context.Context, ktvSlices [][]any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSMAdd", ctx, ktvSlices)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// TSMAdd indicates an expected call of TSMAdd.
func (mr *MockCmdableMockRecorder) TSMAdd(ctx, ktvSlices any) *MockCmdableTSMAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSMAdd", reflect.TypeOf((*MockCmdable)(nil).TSMAdd), ctx, ktvSlices)
	return &MockCmdableTSMAddCall{Call: call}
}

// MockCmdableTSMAddCall wrap *gomock.Call
type MockCmdableTSMAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSMAddCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableTSMAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSMAddCall) Do(f func(context.Context, [][]any) *redis.IntSliceCmd) *MockCmdableTSMAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSMAddCall) DoAndReturn(f func(context.Context, [][]any) *redis.IntSliceCmd) *MockCmdableTSMAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSMGet mocks base method.
func (m *MockCmdable) TSMGet(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSMGet", ctx, filters)
	ret0, _ := ret[0].(*redis.MapStringSliceInterfaceCmd)
	return ret0
}

// TSMGet indicates an expected call of TSMGet.
func (mr *MockCmdableMockRecorder) TSMGet(ctx, filters any) *MockCmdableTSMGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSMGet", reflect.TypeOf((*MockCmdable)(nil).TSMGet), ctx, filters)
	return &MockCmdableTSMGetCall{Call: call}
}

// MockCmdableTSMGetCall wrap *gomock.Call
type MockCmdableTSMGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSMGetCall) Return(arg0 *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMGetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSMGetCall) Do(f func(context.Context, []string) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSMGetCall) DoAndReturn(f func(context.Context, []string) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSMGetWithArgs mocks base method.
func (m *MockCmdable) TSMGetWithArgs(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSMGetWithArgs", ctx, filters, options)
	ret0, _ := ret[0].(*redis.MapStringSliceInterfaceCmd)
	return ret0
}

// TSMGetWithArgs indicates an expected call of TSMGetWithArgs.
func (mr *MockCmdableMockRecorder) TSMGetWithArgs(ctx, filters, options any) *MockCmdableTSMGetWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSMGetWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSMGetWithArgs), ctx, filters, options)
	return &MockCmdableTSMGetWithArgsCall{Call: call}
}

// MockCmdableTSMGetWithArgsCall wrap *gomock.Call
type MockCmdableTSMGetWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSMGetWithArgsCall) Return(arg0 *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMGetWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSMGetWithArgsCall) Do(f func(context.Context, []string, *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMGetWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSMGetWithArgsCall) DoAndReturn(f func(context.Context, []string, *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMGetWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSMRange mocks base method.
func (m *MockCmdable) TSMRange(ctx context.Context, fromTimestamp, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSMRange", ctx, fromTimestamp, toTimestamp, filterExpr)
	ret0, _ := ret[0].(*redis.MapStringSliceInterfaceCmd)
	return ret0
}

// TSMRange indicates an expected call of TSMRange.
func (mr *MockCmdableMockRecorder) TSMRange(ctx, fromTimestamp, toTimestamp, filterExpr any) *MockCmdableTSMRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSMRange", reflect.TypeOf((*MockCmdable)(nil).TSMRange), ctx, fromTimestamp, toTimestamp, filterExpr)
	return &MockCmdableTSMRangeCall{Call: call}
}

// MockCmdableTSMRangeCall wrap *gomock.Call
type MockCmdableTSMRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSMRangeCall) Return(arg0 *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSMRangeCall) Do(f func(context.Context, int, int, []string) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSMRangeCall) DoAndReturn(f func(context.Context, int, int, []string) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSMRangeWithArgs mocks base method.
func (m *MockCmdable) TSMRangeWithArgs(ctx context.Context, fromTimestamp, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSMRangeWithArgs", ctx, fromTimestamp, toTimestamp, filterExpr, options)
	ret0, _ := ret[0].(*redis.MapStringSliceInterfaceCmd)
	return ret0
}

// TSMRangeWithArgs indicates an expected call of TSMRangeWithArgs.
func (mr *MockCmdableMockRecorder) TSMRangeWithArgs(ctx, fromTimestamp, toTimestamp, filterExpr, options any) *MockCmdableTSMRangeWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSMRangeWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSMRangeWithArgs), ctx, fromTimestamp, toTimestamp, filterExpr, options)
	return &MockCmdableTSMRangeWithArgsCall{Call: call}
}

// MockCmdableTSMRangeWithArgsCall wrap *gomock.Call
type MockCmdableTSMRangeWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSMRangeWithArgsCall) Return(arg0 *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRangeWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSMRangeWithArgsCall) Do(f func(context.Context, int, int, []string, *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRangeWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSMRangeWithArgsCall) DoAndReturn(f func(context.Context, int, int, []string, *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRangeWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSMRevRange mocks base method.
func (m *MockCmdable) TSMRevRange(ctx context.Context, fromTimestamp, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSMRevRange", ctx, fromTimestamp, toTimestamp, filterExpr)
	ret0, _ := ret[0].(*redis.MapStringSliceInterfaceCmd)
	return ret0
}

// TSMRevRange indicates an expected call of TSMRevRange.
func (mr *MockCmdableMockRecorder) TSMRevRange(ctx, fromTimestamp, toTimestamp, filterExpr any) *MockCmdableTSMRevRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSMRevRange", reflect.TypeOf((*MockCmdable)(nil).TSMRevRange), ctx, fromTimestamp, toTimestamp, filterExpr)
	return &MockCmdableTSMRevRangeCall{Call: call}
}

// MockCmdableTSMRevRangeCall wrap *gomock.Call
type MockCmdableTSMRevRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSMRevRangeCall) Return(arg0 *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRevRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSMRevRangeCall) Do(f func(context.Context, int, int, []string) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRevRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSMRevRangeCall) DoAndReturn(f func(context.Context, int, int, []string) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRevRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSMRevRangeWithArgs mocks base method.
func (m *MockCmdable) TSMRevRangeWithArgs(ctx context.Context, fromTimestamp, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSMRevRangeWithArgs", ctx, fromTimestamp, toTimestamp, filterExpr, options)
	ret0, _ := ret[0].(*redis.MapStringSliceInterfaceCmd)
	return ret0
}

// TSMRevRangeWithArgs indicates an expected call of TSMRevRangeWithArgs.
func (mr *MockCmdableMockRecorder) TSMRevRangeWithArgs(ctx, fromTimestamp, toTimestamp, filterExpr, options any) *MockCmdableTSMRevRangeWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSMRevRangeWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSMRevRangeWithArgs), ctx, fromTimestamp, toTimestamp, filterExpr, options)
	return &MockCmdableTSMRevRangeWithArgsCall{Call: call}
}

// MockCmdableTSMRevRangeWithArgsCall wrap *gomock.Call
type MockCmdableTSMRevRangeWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSMRevRangeWithArgsCall) Return(arg0 *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRevRangeWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSMRevRangeWithArgsCall) Do(f func(context.Context, int, int, []string, *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRevRangeWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSMRevRangeWithArgsCall) DoAndReturn(f func(context.Context, int, int, []string, *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd) *MockCmdableTSMRevRangeWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSQueryIndex mocks base method.
func (m *MockCmdable) TSQueryIndex(ctx context.Context, filterExpr []string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSQueryIndex", ctx, filterExpr)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// TSQueryIndex indicates an expected call of TSQueryIndex.
func (mr *MockCmdableMockRecorder) TSQueryIndex(ctx, filterExpr any) *MockCmdableTSQueryIndexCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSQueryIndex", reflect.TypeOf((*MockCmdable)(nil).TSQueryIndex), ctx, filterExpr)
	return &MockCmdableTSQueryIndexCall{Call: call}
}

// MockCmdableTSQueryIndexCall wrap *gomock.Call
type MockCmdableTSQueryIndexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSQueryIndexCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableTSQueryIndexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSQueryIndexCall) Do(f func(context.Context, []string) *redis.StringSliceCmd) *MockCmdableTSQueryIndexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSQueryIndexCall) DoAndReturn(f func(context.Context, []string) *redis.StringSliceCmd) *MockCmdableTSQueryIndexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSRange mocks base method.
func (m *MockCmdable) TSRange(ctx context.Context, key string, fromTimestamp, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSRange", ctx, key, fromTimestamp, toTimestamp)
	ret0, _ := ret[0].(*redis.TSTimestampValueSliceCmd)
	return ret0
}

// TSRange indicates an expected call of TSRange.
func (mr *MockCmdableMockRecorder) TSRange(ctx, key, fromTimestamp, toTimestamp any) *MockCmdableTSRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSRange", reflect.TypeOf((*MockCmdable)(nil).TSRange), ctx, key, fromTimestamp, toTimestamp)
	return &MockCmdableTSRangeCall{Call: call}
}

// MockCmdableTSRangeCall wrap *gomock.Call
type MockCmdableTSRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSRangeCall) Return(arg0 *redis.TSTimestampValueSliceCmd) *MockCmdableTSRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSRangeCall) Do(f func(context.Context, string, int, int) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSRangeCall) DoAndReturn(f func(context.Context, string, int, int) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSRangeWithArgs mocks base method.
func (m *MockCmdable) TSRangeWithArgs(ctx context.Context, key string, fromTimestamp, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSRangeWithArgs", ctx, key, fromTimestamp, toTimestamp, options)
	ret0, _ := ret[0].(*redis.TSTimestampValueSliceCmd)
	return ret0
}

// TSRangeWithArgs indicates an expected call of TSRangeWithArgs.
func (mr *MockCmdableMockRecorder) TSRangeWithArgs(ctx, key, fromTimestamp, toTimestamp, options any) *MockCmdableTSRangeWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSRangeWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSRangeWithArgs), ctx, key, fromTimestamp, toTimestamp, options)
	return &MockCmdableTSRangeWithArgsCall{Call: call}
}

// MockCmdableTSRangeWithArgsCall wrap *gomock.Call
type MockCmdableTSRangeWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSRangeWithArgsCall) Return(arg0 *redis.TSTimestampValueSliceCmd) *MockCmdableTSRangeWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSRangeWithArgsCall) Do(f func(context.Context, string, int, int, *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRangeWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSRangeWithArgsCall) DoAndReturn(f func(context.Context, string, int, int, *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRangeWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSRevRange mocks base method.
func (m *MockCmdable) TSRevRange(ctx context.Context, key string, fromTimestamp, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSRevRange", ctx, key, fromTimestamp, toTimestamp)
	ret0, _ := ret[0].(*redis.TSTimestampValueSliceCmd)
	return ret0
}

// TSRevRange indicates an expected call of TSRevRange.
func (mr *MockCmdableMockRecorder) TSRevRange(ctx, key, fromTimestamp, toTimestamp any) *MockCmdableTSRevRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSRevRange", reflect.TypeOf((*MockCmdable)(nil).TSRevRange), ctx, key, fromTimestamp, toTimestamp)
	return &MockCmdableTSRevRangeCall{Call: call}
}

// MockCmdableTSRevRangeCall wrap *gomock.Call
type MockCmdableTSRevRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSRevRangeCall) Return(arg0 *redis.TSTimestampValueSliceCmd) *MockCmdableTSRevRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSRevRangeCall) Do(f func(context.Context, string, int, int) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRevRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSRevRangeCall) DoAndReturn(f func(context.Context, string, int, int) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRevRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TSRevRangeWithArgs mocks base method.
func (m *MockCmdable) TSRevRangeWithArgs(ctx context.Context, key string, fromTimestamp, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TSRevRangeWithArgs", ctx, key, fromTimestamp, toTimestamp, options)
	ret0, _ := ret[0].(*redis.TSTimestampValueSliceCmd)
	return ret0
}

// TSRevRangeWithArgs indicates an expected call of TSRevRangeWithArgs.
func (mr *MockCmdableMockRecorder) TSRevRangeWithArgs(ctx, key, fromTimestamp, toTimestamp, options any) *MockCmdableTSRevRangeWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TSRevRangeWithArgs", reflect.TypeOf((*MockCmdable)(nil).TSRevRangeWithArgs), ctx, key, fromTimestamp, toTimestamp, options)
	return &MockCmdableTSRevRangeWithArgsCall{Call: call}
}

// MockCmdableTSRevRangeWithArgsCall wrap *gomock.Call
type MockCmdableTSRevRangeWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTSRevRangeWithArgsCall) Return(arg0 *redis.TSTimestampValueSliceCmd) *MockCmdableTSRevRangeWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTSRevRangeWithArgsCall) Do(f func(context.Context, string, int, int, *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRevRangeWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTSRevRangeWithArgsCall) DoAndReturn(f func(context.Context, string, int, int, *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd) *MockCmdableTSRevRangeWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TTL mocks base method.
func (m *MockCmdable) TTL(ctx context.Context, key string) *redis.DurationCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TTL", ctx, key)
	ret0, _ := ret[0].(*redis.DurationCmd)
	return ret0
}

// TTL indicates an expected call of TTL.
func (mr *MockCmdableMockRecorder) TTL(ctx, key any) *MockCmdableTTLCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TTL", reflect.TypeOf((*MockCmdable)(nil).TTL), ctx, key)
	return &MockCmdableTTLCall{Call: call}
}

// MockCmdableTTLCall wrap *gomock.Call
type MockCmdableTTLCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTTLCall) Return(arg0 *redis.DurationCmd) *MockCmdableTTLCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTTLCall) Do(f func(context.Context, string) *redis.DurationCmd) *MockCmdableTTLCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTTLCall) DoAndReturn(f func(context.Context, string) *redis.DurationCmd) *MockCmdableTTLCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Time mocks base method.
func (m *MockCmdable) Time(ctx context.Context) *redis.TimeCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Time", ctx)
	ret0, _ := ret[0].(*redis.TimeCmd)
	return ret0
}

// Time indicates an expected call of Time.
func (mr *MockCmdableMockRecorder) Time(ctx any) *MockCmdableTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Time", reflect.TypeOf((*MockCmdable)(nil).Time), ctx)
	return &MockCmdableTimeCall{Call: call}
}

// MockCmdableTimeCall wrap *gomock.Call
type MockCmdableTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTimeCall) Return(arg0 *redis.TimeCmd) *MockCmdableTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTimeCall) Do(f func(context.Context) *redis.TimeCmd) *MockCmdableTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTimeCall) DoAndReturn(f func(context.Context) *redis.TimeCmd) *MockCmdableTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKAdd mocks base method.
func (m *MockCmdable) TopKAdd(ctx context.Context, key string, elements ...any) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TopKAdd", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// TopKAdd indicates an expected call of TopKAdd.
func (mr *MockCmdableMockRecorder) TopKAdd(ctx, key any, elements ...any) *MockCmdableTopKAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKAdd", reflect.TypeOf((*MockCmdable)(nil).TopKAdd), varargs...)
	return &MockCmdableTopKAddCall{Call: call}
}

// MockCmdableTopKAddCall wrap *gomock.Call
type MockCmdableTopKAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKAddCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableTopKAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKAddCall) Do(f func(context.Context, string, ...any) *redis.StringSliceCmd) *MockCmdableTopKAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKAddCall) DoAndReturn(f func(context.Context, string, ...any) *redis.StringSliceCmd) *MockCmdableTopKAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKCount mocks base method.
func (m *MockCmdable) TopKCount(ctx context.Context, key string, elements ...any) *redis.IntSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TopKCount", varargs...)
	ret0, _ := ret[0].(*redis.IntSliceCmd)
	return ret0
}

// TopKCount indicates an expected call of TopKCount.
func (mr *MockCmdableMockRecorder) TopKCount(ctx, key any, elements ...any) *MockCmdableTopKCountCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKCount", reflect.TypeOf((*MockCmdable)(nil).TopKCount), varargs...)
	return &MockCmdableTopKCountCall{Call: call}
}

// MockCmdableTopKCountCall wrap *gomock.Call
type MockCmdableTopKCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKCountCall) Return(arg0 *redis.IntSliceCmd) *MockCmdableTopKCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKCountCall) Do(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableTopKCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKCountCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntSliceCmd) *MockCmdableTopKCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKIncrBy mocks base method.
func (m *MockCmdable) TopKIncrBy(ctx context.Context, key string, elements ...any) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TopKIncrBy", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// TopKIncrBy indicates an expected call of TopKIncrBy.
func (mr *MockCmdableMockRecorder) TopKIncrBy(ctx, key any, elements ...any) *MockCmdableTopKIncrByCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKIncrBy", reflect.TypeOf((*MockCmdable)(nil).TopKIncrBy), varargs...)
	return &MockCmdableTopKIncrByCall{Call: call}
}

// MockCmdableTopKIncrByCall wrap *gomock.Call
type MockCmdableTopKIncrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKIncrByCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableTopKIncrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKIncrByCall) Do(f func(context.Context, string, ...any) *redis.StringSliceCmd) *MockCmdableTopKIncrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKIncrByCall) DoAndReturn(f func(context.Context, string, ...any) *redis.StringSliceCmd) *MockCmdableTopKIncrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKInfo mocks base method.
func (m *MockCmdable) TopKInfo(ctx context.Context, key string) *redis.TopKInfoCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopKInfo", ctx, key)
	ret0, _ := ret[0].(*redis.TopKInfoCmd)
	return ret0
}

// TopKInfo indicates an expected call of TopKInfo.
func (mr *MockCmdableMockRecorder) TopKInfo(ctx, key any) *MockCmdableTopKInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKInfo", reflect.TypeOf((*MockCmdable)(nil).TopKInfo), ctx, key)
	return &MockCmdableTopKInfoCall{Call: call}
}

// MockCmdableTopKInfoCall wrap *gomock.Call
type MockCmdableTopKInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKInfoCall) Return(arg0 *redis.TopKInfoCmd) *MockCmdableTopKInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKInfoCall) Do(f func(context.Context, string) *redis.TopKInfoCmd) *MockCmdableTopKInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKInfoCall) DoAndReturn(f func(context.Context, string) *redis.TopKInfoCmd) *MockCmdableTopKInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKList mocks base method.
func (m *MockCmdable) TopKList(ctx context.Context, key string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopKList", ctx, key)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// TopKList indicates an expected call of TopKList.
func (mr *MockCmdableMockRecorder) TopKList(ctx, key any) *MockCmdableTopKListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKList", reflect.TypeOf((*MockCmdable)(nil).TopKList), ctx, key)
	return &MockCmdableTopKListCall{Call: call}
}

// MockCmdableTopKListCall wrap *gomock.Call
type MockCmdableTopKListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKListCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableTopKListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKListCall) Do(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableTopKListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKListCall) DoAndReturn(f func(context.Context, string) *redis.StringSliceCmd) *MockCmdableTopKListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKListWithCount mocks base method.
func (m *MockCmdable) TopKListWithCount(ctx context.Context, key string) *redis.MapStringIntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopKListWithCount", ctx, key)
	ret0, _ := ret[0].(*redis.MapStringIntCmd)
	return ret0
}

// TopKListWithCount indicates an expected call of TopKListWithCount.
func (mr *MockCmdableMockRecorder) TopKListWithCount(ctx, key any) *MockCmdableTopKListWithCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKListWithCount", reflect.TypeOf((*MockCmdable)(nil).TopKListWithCount), ctx, key)
	return &MockCmdableTopKListWithCountCall{Call: call}
}

// MockCmdableTopKListWithCountCall wrap *gomock.Call
type MockCmdableTopKListWithCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKListWithCountCall) Return(arg0 *redis.MapStringIntCmd) *MockCmdableTopKListWithCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKListWithCountCall) Do(f func(context.Context, string) *redis.MapStringIntCmd) *MockCmdableTopKListWithCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKListWithCountCall) DoAndReturn(f func(context.Context, string) *redis.MapStringIntCmd) *MockCmdableTopKListWithCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKQuery mocks base method.
func (m *MockCmdable) TopKQuery(ctx context.Context, key string, elements ...any) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range elements {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TopKQuery", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// TopKQuery indicates an expected call of TopKQuery.
func (mr *MockCmdableMockRecorder) TopKQuery(ctx, key any, elements ...any) *MockCmdableTopKQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, elements...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKQuery", reflect.TypeOf((*MockCmdable)(nil).TopKQuery), varargs...)
	return &MockCmdableTopKQueryCall{Call: call}
}

// MockCmdableTopKQueryCall wrap *gomock.Call
type MockCmdableTopKQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKQueryCall) Return(arg0 *redis.BoolSliceCmd) *MockCmdableTopKQueryCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKQueryCall) Do(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableTopKQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKQueryCall) DoAndReturn(f func(context.Context, string, ...any) *redis.BoolSliceCmd) *MockCmdableTopKQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKReserve mocks base method.
func (m *MockCmdable) TopKReserve(ctx context.Context, key string, k int64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopKReserve", ctx, key, k)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TopKReserve indicates an expected call of TopKReserve.
func (mr *MockCmdableMockRecorder) TopKReserve(ctx, key, k any) *MockCmdableTopKReserveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKReserve", reflect.TypeOf((*MockCmdable)(nil).TopKReserve), ctx, key, k)
	return &MockCmdableTopKReserveCall{Call: call}
}

// MockCmdableTopKReserveCall wrap *gomock.Call
type MockCmdableTopKReserveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKReserveCall) Return(arg0 *redis.StatusCmd) *MockCmdableTopKReserveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKReserveCall) Do(f func(context.Context, string, int64) *redis.StatusCmd) *MockCmdableTopKReserveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKReserveCall) DoAndReturn(f func(context.Context, string, int64) *redis.StatusCmd) *MockCmdableTopKReserveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TopKReserveWithOptions mocks base method.
func (m *MockCmdable) TopKReserveWithOptions(ctx context.Context, key string, k, width, depth int64, decay float64) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopKReserveWithOptions", ctx, key, k, width, depth, decay)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// TopKReserveWithOptions indicates an expected call of TopKReserveWithOptions.
func (mr *MockCmdableMockRecorder) TopKReserveWithOptions(ctx, key, k, width, depth, decay any) *MockCmdableTopKReserveWithOptionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopKReserveWithOptions", reflect.TypeOf((*MockCmdable)(nil).TopKReserveWithOptions), ctx, key, k, width, depth, decay)
	return &MockCmdableTopKReserveWithOptionsCall{Call: call}
}

// MockCmdableTopKReserveWithOptionsCall wrap *gomock.Call
type MockCmdableTopKReserveWithOptionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTopKReserveWithOptionsCall) Return(arg0 *redis.StatusCmd) *MockCmdableTopKReserveWithOptionsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTopKReserveWithOptionsCall) Do(f func(context.Context, string, int64, int64, int64, float64) *redis.StatusCmd) *MockCmdableTopKReserveWithOptionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTopKReserveWithOptionsCall) DoAndReturn(f func(context.Context, string, int64, int64, int64, float64) *redis.StatusCmd) *MockCmdableTopKReserveWithOptionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Touch mocks base method.
func (m *MockCmdable) Touch(ctx context.Context, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Touch", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Touch indicates an expected call of Touch.
func (mr *MockCmdableMockRecorder) Touch(ctx any, keys ...any) *MockCmdableTouchCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Touch", reflect.TypeOf((*MockCmdable)(nil).Touch), varargs...)
	return &MockCmdableTouchCall{Call: call}
}

// MockCmdableTouchCall wrap *gomock.Call
type MockCmdableTouchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTouchCall) Return(arg0 *redis.IntCmd) *MockCmdableTouchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTouchCall) Do(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableTouchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTouchCall) DoAndReturn(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableTouchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TxPipeline mocks base method.
func (m *MockCmdable) TxPipeline() redis.Pipeliner {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TxPipeline")
	ret0, _ := ret[0].(redis.Pipeliner)
	return ret0
}

// TxPipeline indicates an expected call of TxPipeline.
func (mr *MockCmdableMockRecorder) TxPipeline() *MockCmdableTxPipelineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TxPipeline", reflect.TypeOf((*MockCmdable)(nil).TxPipeline))
	return &MockCmdableTxPipelineCall{Call: call}
}

// MockCmdableTxPipelineCall wrap *gomock.Call
type MockCmdableTxPipelineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTxPipelineCall) Return(arg0 redis.Pipeliner) *MockCmdableTxPipelineCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTxPipelineCall) Do(f func() redis.Pipeliner) *MockCmdableTxPipelineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTxPipelineCall) DoAndReturn(f func() redis.Pipeliner) *MockCmdableTxPipelineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TxPipelined mocks base method.
func (m *MockCmdable) TxPipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TxPipelined", ctx, fn)
	ret0, _ := ret[0].([]redis.Cmder)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TxPipelined indicates an expected call of TxPipelined.
func (mr *MockCmdableMockRecorder) TxPipelined(ctx, fn any) *MockCmdableTxPipelinedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TxPipelined", reflect.TypeOf((*MockCmdable)(nil).TxPipelined), ctx, fn)
	return &MockCmdableTxPipelinedCall{Call: call}
}

// MockCmdableTxPipelinedCall wrap *gomock.Call
type MockCmdableTxPipelinedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTxPipelinedCall) Return(arg0 []redis.Cmder, arg1 error) *MockCmdableTxPipelinedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTxPipelinedCall) Do(f func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)) *MockCmdableTxPipelinedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTxPipelinedCall) DoAndReturn(f func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)) *MockCmdableTxPipelinedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Type mocks base method.
func (m *MockCmdable) Type(ctx context.Context, key string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type", ctx, key)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockCmdableMockRecorder) Type(ctx, key any) *MockCmdableTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockCmdable)(nil).Type), ctx, key)
	return &MockCmdableTypeCall{Call: call}
}

// MockCmdableTypeCall wrap *gomock.Call
type MockCmdableTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableTypeCall) Return(arg0 *redis.StatusCmd) *MockCmdableTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableTypeCall) Do(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableTypeCall) DoAndReturn(f func(context.Context, string) *redis.StatusCmd) *MockCmdableTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Unlink mocks base method.
func (m *MockCmdable) Unlink(ctx context.Context, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Unlink", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// Unlink indicates an expected call of Unlink.
func (mr *MockCmdableMockRecorder) Unlink(ctx any, keys ...any) *MockCmdableUnlinkCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlink", reflect.TypeOf((*MockCmdable)(nil).Unlink), varargs...)
	return &MockCmdableUnlinkCall{Call: call}
}

// MockCmdableUnlinkCall wrap *gomock.Call
type MockCmdableUnlinkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableUnlinkCall) Return(arg0 *redis.IntCmd) *MockCmdableUnlinkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableUnlinkCall) Do(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableUnlinkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableUnlinkCall) DoAndReturn(f func(context.Context, ...string) *redis.IntCmd) *MockCmdableUnlinkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VAdd mocks base method.
func (m *MockCmdable) VAdd(ctx context.Context, key, element string, val redis.Vector) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VAdd", ctx, key, element, val)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// VAdd indicates an expected call of VAdd.
func (mr *MockCmdableMockRecorder) VAdd(ctx, key, element, val any) *MockCmdableVAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VAdd", reflect.TypeOf((*MockCmdable)(nil).VAdd), ctx, key, element, val)
	return &MockCmdableVAddCall{Call: call}
}

// MockCmdableVAddCall wrap *gomock.Call
type MockCmdableVAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVAddCall) Return(arg0 *redis.BoolCmd) *MockCmdableVAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVAddCall) Do(f func(context.Context, string, string, redis.Vector) *redis.BoolCmd) *MockCmdableVAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVAddCall) DoAndReturn(f func(context.Context, string, string, redis.Vector) *redis.BoolCmd) *MockCmdableVAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VAddWithArgs mocks base method.
func (m *MockCmdable) VAddWithArgs(ctx context.Context, key, element string, val redis.Vector, addArgs *redis.VAddArgs) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VAddWithArgs", ctx, key, element, val, addArgs)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// VAddWithArgs indicates an expected call of VAddWithArgs.
func (mr *MockCmdableMockRecorder) VAddWithArgs(ctx, key, element, val, addArgs any) *MockCmdableVAddWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VAddWithArgs", reflect.TypeOf((*MockCmdable)(nil).VAddWithArgs), ctx, key, element, val, addArgs)
	return &MockCmdableVAddWithArgsCall{Call: call}
}

// MockCmdableVAddWithArgsCall wrap *gomock.Call
type MockCmdableVAddWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVAddWithArgsCall) Return(arg0 *redis.BoolCmd) *MockCmdableVAddWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVAddWithArgsCall) Do(f func(context.Context, string, string, redis.Vector, *redis.VAddArgs) *redis.BoolCmd) *MockCmdableVAddWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVAddWithArgsCall) DoAndReturn(f func(context.Context, string, string, redis.Vector, *redis.VAddArgs) *redis.BoolCmd) *MockCmdableVAddWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VCard mocks base method.
func (m *MockCmdable) VCard(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VCard", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// VCard indicates an expected call of VCard.
func (mr *MockCmdableMockRecorder) VCard(ctx, key any) *MockCmdableVCardCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VCard", reflect.TypeOf((*MockCmdable)(nil).VCard), ctx, key)
	return &MockCmdableVCardCall{Call: call}
}

// MockCmdableVCardCall wrap *gomock.Call
type MockCmdableVCardCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVCardCall) Return(arg0 *redis.IntCmd) *MockCmdableVCardCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVCardCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableVCardCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVCardCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableVCardCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VClearAttributes mocks base method.
func (m *MockCmdable) VClearAttributes(ctx context.Context, key, element string) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VClearAttributes", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// VClearAttributes indicates an expected call of VClearAttributes.
func (mr *MockCmdableMockRecorder) VClearAttributes(ctx, key, element any) *MockCmdableVClearAttributesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VClearAttributes", reflect.TypeOf((*MockCmdable)(nil).VClearAttributes), ctx, key, element)
	return &MockCmdableVClearAttributesCall{Call: call}
}

// MockCmdableVClearAttributesCall wrap *gomock.Call
type MockCmdableVClearAttributesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVClearAttributesCall) Return(arg0 *redis.BoolCmd) *MockCmdableVClearAttributesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVClearAttributesCall) Do(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableVClearAttributesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVClearAttributesCall) DoAndReturn(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableVClearAttributesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VDim mocks base method.
func (m *MockCmdable) VDim(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VDim", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// VDim indicates an expected call of VDim.
func (mr *MockCmdableMockRecorder) VDim(ctx, key any) *MockCmdableVDimCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VDim", reflect.TypeOf((*MockCmdable)(nil).VDim), ctx, key)
	return &MockCmdableVDimCall{Call: call}
}

// MockCmdableVDimCall wrap *gomock.Call
type MockCmdableVDimCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVDimCall) Return(arg0 *redis.IntCmd) *MockCmdableVDimCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVDimCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableVDimCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVDimCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableVDimCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VEmb mocks base method.
func (m *MockCmdable) VEmb(ctx context.Context, key, element string, raw bool) *redis.SliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VEmb", ctx, key, element, raw)
	ret0, _ := ret[0].(*redis.SliceCmd)
	return ret0
}

// VEmb indicates an expected call of VEmb.
func (mr *MockCmdableMockRecorder) VEmb(ctx, key, element, raw any) *MockCmdableVEmbCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VEmb", reflect.TypeOf((*MockCmdable)(nil).VEmb), ctx, key, element, raw)
	return &MockCmdableVEmbCall{Call: call}
}

// MockCmdableVEmbCall wrap *gomock.Call
type MockCmdableVEmbCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVEmbCall) Return(arg0 *redis.SliceCmd) *MockCmdableVEmbCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVEmbCall) Do(f func(context.Context, string, string, bool) *redis.SliceCmd) *MockCmdableVEmbCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVEmbCall) DoAndReturn(f func(context.Context, string, string, bool) *redis.SliceCmd) *MockCmdableVEmbCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VGetAttr mocks base method.
func (m *MockCmdable) VGetAttr(ctx context.Context, key, element string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VGetAttr", ctx, key, element)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// VGetAttr indicates an expected call of VGetAttr.
func (mr *MockCmdableMockRecorder) VGetAttr(ctx, key, element any) *MockCmdableVGetAttrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VGetAttr", reflect.TypeOf((*MockCmdable)(nil).VGetAttr), ctx, key, element)
	return &MockCmdableVGetAttrCall{Call: call}
}

// MockCmdableVGetAttrCall wrap *gomock.Call
type MockCmdableVGetAttrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVGetAttrCall) Return(arg0 *redis.StringCmd) *MockCmdableVGetAttrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVGetAttrCall) Do(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableVGetAttrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVGetAttrCall) DoAndReturn(f func(context.Context, string, string) *redis.StringCmd) *MockCmdableVGetAttrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VInfo mocks base method.
func (m *MockCmdable) VInfo(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VInfo", ctx, key)
	ret0, _ := ret[0].(*redis.MapStringInterfaceCmd)
	return ret0
}

// VInfo indicates an expected call of VInfo.
func (mr *MockCmdableMockRecorder) VInfo(ctx, key any) *MockCmdableVInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VInfo", reflect.TypeOf((*MockCmdable)(nil).VInfo), ctx, key)
	return &MockCmdableVInfoCall{Call: call}
}

// MockCmdableVInfoCall wrap *gomock.Call
type MockCmdableVInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVInfoCall) Return(arg0 *redis.MapStringInterfaceCmd) *MockCmdableVInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVInfoCall) Do(f func(context.Context, string) *redis.MapStringInterfaceCmd) *MockCmdableVInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVInfoCall) DoAndReturn(f func(context.Context, string) *redis.MapStringInterfaceCmd) *MockCmdableVInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VLinks mocks base method.
func (m *MockCmdable) VLinks(ctx context.Context, key, element string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VLinks", ctx, key, element)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// VLinks indicates an expected call of VLinks.
func (mr *MockCmdableMockRecorder) VLinks(ctx, key, element any) *MockCmdableVLinksCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VLinks", reflect.TypeOf((*MockCmdable)(nil).VLinks), ctx, key, element)
	return &MockCmdableVLinksCall{Call: call}
}

// MockCmdableVLinksCall wrap *gomock.Call
type MockCmdableVLinksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVLinksCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableVLinksCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVLinksCall) Do(f func(context.Context, string, string) *redis.StringSliceCmd) *MockCmdableVLinksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVLinksCall) DoAndReturn(f func(context.Context, string, string) *redis.StringSliceCmd) *MockCmdableVLinksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VLinksWithScores mocks base method.
func (m *MockCmdable) VLinksWithScores(ctx context.Context, key, element string) *redis.VectorScoreSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VLinksWithScores", ctx, key, element)
	ret0, _ := ret[0].(*redis.VectorScoreSliceCmd)
	return ret0
}

// VLinksWithScores indicates an expected call of VLinksWithScores.
func (mr *MockCmdableMockRecorder) VLinksWithScores(ctx, key, element any) *MockCmdableVLinksWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VLinksWithScores", reflect.TypeOf((*MockCmdable)(nil).VLinksWithScores), ctx, key, element)
	return &MockCmdableVLinksWithScoresCall{Call: call}
}

// MockCmdableVLinksWithScoresCall wrap *gomock.Call
type MockCmdableVLinksWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVLinksWithScoresCall) Return(arg0 *redis.VectorScoreSliceCmd) *MockCmdableVLinksWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVLinksWithScoresCall) Do(f func(context.Context, string, string) *redis.VectorScoreSliceCmd) *MockCmdableVLinksWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVLinksWithScoresCall) DoAndReturn(f func(context.Context, string, string) *redis.VectorScoreSliceCmd) *MockCmdableVLinksWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VRandMember mocks base method.
func (m *MockCmdable) VRandMember(ctx context.Context, key string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VRandMember", ctx, key)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// VRandMember indicates an expected call of VRandMember.
func (mr *MockCmdableMockRecorder) VRandMember(ctx, key any) *MockCmdableVRandMemberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VRandMember", reflect.TypeOf((*MockCmdable)(nil).VRandMember), ctx, key)
	return &MockCmdableVRandMemberCall{Call: call}
}

// MockCmdableVRandMemberCall wrap *gomock.Call
type MockCmdableVRandMemberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVRandMemberCall) Return(arg0 *redis.StringCmd) *MockCmdableVRandMemberCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVRandMemberCall) Do(f func(context.Context, string) *redis.StringCmd) *MockCmdableVRandMemberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVRandMemberCall) DoAndReturn(f func(context.Context, string) *redis.StringCmd) *MockCmdableVRandMemberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VRandMemberCount mocks base method.
func (m *MockCmdable) VRandMemberCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VRandMemberCount", ctx, key, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// VRandMemberCount indicates an expected call of VRandMemberCount.
func (mr *MockCmdableMockRecorder) VRandMemberCount(ctx, key, count any) *MockCmdableVRandMemberCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VRandMemberCount", reflect.TypeOf((*MockCmdable)(nil).VRandMemberCount), ctx, key, count)
	return &MockCmdableVRandMemberCountCall{Call: call}
}

// MockCmdableVRandMemberCountCall wrap *gomock.Call
type MockCmdableVRandMemberCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVRandMemberCountCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableVRandMemberCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVRandMemberCountCall) Do(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableVRandMemberCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVRandMemberCountCall) DoAndReturn(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableVRandMemberCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VRem mocks base method.
func (m *MockCmdable) VRem(ctx context.Context, key, element string) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VRem", ctx, key, element)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// VRem indicates an expected call of VRem.
func (mr *MockCmdableMockRecorder) VRem(ctx, key, element any) *MockCmdableVRemCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VRem", reflect.TypeOf((*MockCmdable)(nil).VRem), ctx, key, element)
	return &MockCmdableVRemCall{Call: call}
}

// MockCmdableVRemCall wrap *gomock.Call
type MockCmdableVRemCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVRemCall) Return(arg0 *redis.BoolCmd) *MockCmdableVRemCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVRemCall) Do(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableVRemCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVRemCall) DoAndReturn(f func(context.Context, string, string) *redis.BoolCmd) *MockCmdableVRemCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VSetAttr mocks base method.
func (m *MockCmdable) VSetAttr(ctx context.Context, key, element string, attr any) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VSetAttr", ctx, key, element, attr)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// VSetAttr indicates an expected call of VSetAttr.
func (mr *MockCmdableMockRecorder) VSetAttr(ctx, key, element, attr any) *MockCmdableVSetAttrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VSetAttr", reflect.TypeOf((*MockCmdable)(nil).VSetAttr), ctx, key, element, attr)
	return &MockCmdableVSetAttrCall{Call: call}
}

// MockCmdableVSetAttrCall wrap *gomock.Call
type MockCmdableVSetAttrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVSetAttrCall) Return(arg0 *redis.BoolCmd) *MockCmdableVSetAttrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVSetAttrCall) Do(f func(context.Context, string, string, any) *redis.BoolCmd) *MockCmdableVSetAttrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVSetAttrCall) DoAndReturn(f func(context.Context, string, string, any) *redis.BoolCmd) *MockCmdableVSetAttrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VSim mocks base method.
func (m *MockCmdable) VSim(ctx context.Context, key string, val redis.Vector) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VSim", ctx, key, val)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// VSim indicates an expected call of VSim.
func (mr *MockCmdableMockRecorder) VSim(ctx, key, val any) *MockCmdableVSimCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VSim", reflect.TypeOf((*MockCmdable)(nil).VSim), ctx, key, val)
	return &MockCmdableVSimCall{Call: call}
}

// MockCmdableVSimCall wrap *gomock.Call
type MockCmdableVSimCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVSimCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableVSimCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVSimCall) Do(f func(context.Context, string, redis.Vector) *redis.StringSliceCmd) *MockCmdableVSimCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVSimCall) DoAndReturn(f func(context.Context, string, redis.Vector) *redis.StringSliceCmd) *MockCmdableVSimCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VSimWithArgs mocks base method.
func (m *MockCmdable) VSimWithArgs(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VSimWithArgs", ctx, key, val, args)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// VSimWithArgs indicates an expected call of VSimWithArgs.
func (mr *MockCmdableMockRecorder) VSimWithArgs(ctx, key, val, args any) *MockCmdableVSimWithArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VSimWithArgs", reflect.TypeOf((*MockCmdable)(nil).VSimWithArgs), ctx, key, val, args)
	return &MockCmdableVSimWithArgsCall{Call: call}
}

// MockCmdableVSimWithArgsCall wrap *gomock.Call
type MockCmdableVSimWithArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVSimWithArgsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableVSimWithArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVSimWithArgsCall) Do(f func(context.Context, string, redis.Vector, *redis.VSimArgs) *redis.StringSliceCmd) *MockCmdableVSimWithArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVSimWithArgsCall) DoAndReturn(f func(context.Context, string, redis.Vector, *redis.VSimArgs) *redis.StringSliceCmd) *MockCmdableVSimWithArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VSimWithArgsWithScores mocks base method.
func (m *MockCmdable) VSimWithArgsWithScores(ctx context.Context, key string, val redis.Vector, args *redis.VSimArgs) *redis.VectorScoreSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VSimWithArgsWithScores", ctx, key, val, args)
	ret0, _ := ret[0].(*redis.VectorScoreSliceCmd)
	return ret0
}

// VSimWithArgsWithScores indicates an expected call of VSimWithArgsWithScores.
func (mr *MockCmdableMockRecorder) VSimWithArgsWithScores(ctx, key, val, args any) *MockCmdableVSimWithArgsWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VSimWithArgsWithScores", reflect.TypeOf((*MockCmdable)(nil).VSimWithArgsWithScores), ctx, key, val, args)
	return &MockCmdableVSimWithArgsWithScoresCall{Call: call}
}

// MockCmdableVSimWithArgsWithScoresCall wrap *gomock.Call
type MockCmdableVSimWithArgsWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVSimWithArgsWithScoresCall) Return(arg0 *redis.VectorScoreSliceCmd) *MockCmdableVSimWithArgsWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVSimWithArgsWithScoresCall) Do(f func(context.Context, string, redis.Vector, *redis.VSimArgs) *redis.VectorScoreSliceCmd) *MockCmdableVSimWithArgsWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVSimWithArgsWithScoresCall) DoAndReturn(f func(context.Context, string, redis.Vector, *redis.VSimArgs) *redis.VectorScoreSliceCmd) *MockCmdableVSimWithArgsWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VSimWithScores mocks base method.
func (m *MockCmdable) VSimWithScores(ctx context.Context, key string, val redis.Vector) *redis.VectorScoreSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VSimWithScores", ctx, key, val)
	ret0, _ := ret[0].(*redis.VectorScoreSliceCmd)
	return ret0
}

// VSimWithScores indicates an expected call of VSimWithScores.
func (mr *MockCmdableMockRecorder) VSimWithScores(ctx, key, val any) *MockCmdableVSimWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VSimWithScores", reflect.TypeOf((*MockCmdable)(nil).VSimWithScores), ctx, key, val)
	return &MockCmdableVSimWithScoresCall{Call: call}
}

// MockCmdableVSimWithScoresCall wrap *gomock.Call
type MockCmdableVSimWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableVSimWithScoresCall) Return(arg0 *redis.VectorScoreSliceCmd) *MockCmdableVSimWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableVSimWithScoresCall) Do(f func(context.Context, string, redis.Vector) *redis.VectorScoreSliceCmd) *MockCmdableVSimWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableVSimWithScoresCall) DoAndReturn(f func(context.Context, string, redis.Vector) *redis.VectorScoreSliceCmd) *MockCmdableVSimWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XAck mocks base method.
func (m *MockCmdable) XAck(ctx context.Context, stream, group string, ids ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, stream, group}
	for _, a := range ids {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "XAck", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XAck indicates an expected call of XAck.
func (mr *MockCmdableMockRecorder) XAck(ctx, stream, group any, ids ...any) *MockCmdableXAckCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, stream, group}, ids...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XAck", reflect.TypeOf((*MockCmdable)(nil).XAck), varargs...)
	return &MockCmdableXAckCall{Call: call}
}

// MockCmdableXAckCall wrap *gomock.Call
type MockCmdableXAckCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXAckCall) Return(arg0 *redis.IntCmd) *MockCmdableXAckCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXAckCall) Do(f func(context.Context, string, string, ...string) *redis.IntCmd) *MockCmdableXAckCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXAckCall) DoAndReturn(f func(context.Context, string, string, ...string) *redis.IntCmd) *MockCmdableXAckCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XAdd mocks base method.
func (m *MockCmdable) XAdd(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XAdd", ctx, a)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// XAdd indicates an expected call of XAdd.
func (mr *MockCmdableMockRecorder) XAdd(ctx, a any) *MockCmdableXAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XAdd", reflect.TypeOf((*MockCmdable)(nil).XAdd), ctx, a)
	return &MockCmdableXAddCall{Call: call}
}

// MockCmdableXAddCall wrap *gomock.Call
type MockCmdableXAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXAddCall) Return(arg0 *redis.StringCmd) *MockCmdableXAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXAddCall) Do(f func(context.Context, *redis.XAddArgs) *redis.StringCmd) *MockCmdableXAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXAddCall) DoAndReturn(f func(context.Context, *redis.XAddArgs) *redis.StringCmd) *MockCmdableXAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XAutoClaim mocks base method.
func (m *MockCmdable) XAutoClaim(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XAutoClaim", ctx, a)
	ret0, _ := ret[0].(*redis.XAutoClaimCmd)
	return ret0
}

// XAutoClaim indicates an expected call of XAutoClaim.
func (mr *MockCmdableMockRecorder) XAutoClaim(ctx, a any) *MockCmdableXAutoClaimCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XAutoClaim", reflect.TypeOf((*MockCmdable)(nil).XAutoClaim), ctx, a)
	return &MockCmdableXAutoClaimCall{Call: call}
}

// MockCmdableXAutoClaimCall wrap *gomock.Call
type MockCmdableXAutoClaimCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXAutoClaimCall) Return(arg0 *redis.XAutoClaimCmd) *MockCmdableXAutoClaimCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXAutoClaimCall) Do(f func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimCmd) *MockCmdableXAutoClaimCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXAutoClaimCall) DoAndReturn(f func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimCmd) *MockCmdableXAutoClaimCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XAutoClaimJustID mocks base method.
func (m *MockCmdable) XAutoClaimJustID(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XAutoClaimJustID", ctx, a)
	ret0, _ := ret[0].(*redis.XAutoClaimJustIDCmd)
	return ret0
}

// XAutoClaimJustID indicates an expected call of XAutoClaimJustID.
func (mr *MockCmdableMockRecorder) XAutoClaimJustID(ctx, a any) *MockCmdableXAutoClaimJustIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XAutoClaimJustID", reflect.TypeOf((*MockCmdable)(nil).XAutoClaimJustID), ctx, a)
	return &MockCmdableXAutoClaimJustIDCall{Call: call}
}

// MockCmdableXAutoClaimJustIDCall wrap *gomock.Call
type MockCmdableXAutoClaimJustIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXAutoClaimJustIDCall) Return(arg0 *redis.XAutoClaimJustIDCmd) *MockCmdableXAutoClaimJustIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXAutoClaimJustIDCall) Do(f func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd) *MockCmdableXAutoClaimJustIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXAutoClaimJustIDCall) DoAndReturn(f func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd) *MockCmdableXAutoClaimJustIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XClaim mocks base method.
func (m *MockCmdable) XClaim(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XClaim", ctx, a)
	ret0, _ := ret[0].(*redis.XMessageSliceCmd)
	return ret0
}

// XClaim indicates an expected call of XClaim.
func (mr *MockCmdableMockRecorder) XClaim(ctx, a any) *MockCmdableXClaimCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XClaim", reflect.TypeOf((*MockCmdable)(nil).XClaim), ctx, a)
	return &MockCmdableXClaimCall{Call: call}
}

// MockCmdableXClaimCall wrap *gomock.Call
type MockCmdableXClaimCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXClaimCall) Return(arg0 *redis.XMessageSliceCmd) *MockCmdableXClaimCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXClaimCall) Do(f func(context.Context, *redis.XClaimArgs) *redis.XMessageSliceCmd) *MockCmdableXClaimCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXClaimCall) DoAndReturn(f func(context.Context, *redis.XClaimArgs) *redis.XMessageSliceCmd) *MockCmdableXClaimCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XClaimJustID mocks base method.
func (m *MockCmdable) XClaimJustID(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XClaimJustID", ctx, a)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// XClaimJustID indicates an expected call of XClaimJustID.
func (mr *MockCmdableMockRecorder) XClaimJustID(ctx, a any) *MockCmdableXClaimJustIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XClaimJustID", reflect.TypeOf((*MockCmdable)(nil).XClaimJustID), ctx, a)
	return &MockCmdableXClaimJustIDCall{Call: call}
}

// MockCmdableXClaimJustIDCall wrap *gomock.Call
type MockCmdableXClaimJustIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXClaimJustIDCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableXClaimJustIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXClaimJustIDCall) Do(f func(context.Context, *redis.XClaimArgs) *redis.StringSliceCmd) *MockCmdableXClaimJustIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXClaimJustIDCall) DoAndReturn(f func(context.Context, *redis.XClaimArgs) *redis.StringSliceCmd) *MockCmdableXClaimJustIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XDel mocks base method.
func (m *MockCmdable) XDel(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, stream}
	for _, a := range ids {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "XDel", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XDel indicates an expected call of XDel.
func (mr *MockCmdableMockRecorder) XDel(ctx, stream any, ids ...any) *MockCmdableXDelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, stream}, ids...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XDel", reflect.TypeOf((*MockCmdable)(nil).XDel), varargs...)
	return &MockCmdableXDelCall{Call: call}
}

// MockCmdableXDelCall wrap *gomock.Call
type MockCmdableXDelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXDelCall) Return(arg0 *redis.IntCmd) *MockCmdableXDelCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXDelCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableXDelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXDelCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableXDelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XGroupCreate mocks base method.
func (m *MockCmdable) XGroupCreate(ctx context.Context, stream, group, start string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XGroupCreate", ctx, stream, group, start)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// XGroupCreate indicates an expected call of XGroupCreate.
func (mr *MockCmdableMockRecorder) XGroupCreate(ctx, stream, group, start any) *MockCmdableXGroupCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XGroupCreate", reflect.TypeOf((*MockCmdable)(nil).XGroupCreate), ctx, stream, group, start)
	return &MockCmdableXGroupCreateCall{Call: call}
}

// MockCmdableXGroupCreateCall wrap *gomock.Call
type MockCmdableXGroupCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXGroupCreateCall) Return(arg0 *redis.StatusCmd) *MockCmdableXGroupCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXGroupCreateCall) Do(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableXGroupCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXGroupCreateCall) DoAndReturn(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableXGroupCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XGroupCreateConsumer mocks base method.
func (m *MockCmdable) XGroupCreateConsumer(ctx context.Context, stream, group, consumer string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XGroupCreateConsumer", ctx, stream, group, consumer)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XGroupCreateConsumer indicates an expected call of XGroupCreateConsumer.
func (mr *MockCmdableMockRecorder) XGroupCreateConsumer(ctx, stream, group, consumer any) *MockCmdableXGroupCreateConsumerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XGroupCreateConsumer", reflect.TypeOf((*MockCmdable)(nil).XGroupCreateConsumer), ctx, stream, group, consumer)
	return &MockCmdableXGroupCreateConsumerCall{Call: call}
}

// MockCmdableXGroupCreateConsumerCall wrap *gomock.Call
type MockCmdableXGroupCreateConsumerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXGroupCreateConsumerCall) Return(arg0 *redis.IntCmd) *MockCmdableXGroupCreateConsumerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXGroupCreateConsumerCall) Do(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableXGroupCreateConsumerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXGroupCreateConsumerCall) DoAndReturn(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableXGroupCreateConsumerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XGroupCreateMkStream mocks base method.
func (m *MockCmdable) XGroupCreateMkStream(ctx context.Context, stream, group, start string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XGroupCreateMkStream", ctx, stream, group, start)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// XGroupCreateMkStream indicates an expected call of XGroupCreateMkStream.
func (mr *MockCmdableMockRecorder) XGroupCreateMkStream(ctx, stream, group, start any) *MockCmdableXGroupCreateMkStreamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XGroupCreateMkStream", reflect.TypeOf((*MockCmdable)(nil).XGroupCreateMkStream), ctx, stream, group, start)
	return &MockCmdableXGroupCreateMkStreamCall{Call: call}
}

// MockCmdableXGroupCreateMkStreamCall wrap *gomock.Call
type MockCmdableXGroupCreateMkStreamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXGroupCreateMkStreamCall) Return(arg0 *redis.StatusCmd) *MockCmdableXGroupCreateMkStreamCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXGroupCreateMkStreamCall) Do(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableXGroupCreateMkStreamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXGroupCreateMkStreamCall) DoAndReturn(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableXGroupCreateMkStreamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XGroupDelConsumer mocks base method.
func (m *MockCmdable) XGroupDelConsumer(ctx context.Context, stream, group, consumer string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XGroupDelConsumer", ctx, stream, group, consumer)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XGroupDelConsumer indicates an expected call of XGroupDelConsumer.
func (mr *MockCmdableMockRecorder) XGroupDelConsumer(ctx, stream, group, consumer any) *MockCmdableXGroupDelConsumerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XGroupDelConsumer", reflect.TypeOf((*MockCmdable)(nil).XGroupDelConsumer), ctx, stream, group, consumer)
	return &MockCmdableXGroupDelConsumerCall{Call: call}
}

// MockCmdableXGroupDelConsumerCall wrap *gomock.Call
type MockCmdableXGroupDelConsumerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXGroupDelConsumerCall) Return(arg0 *redis.IntCmd) *MockCmdableXGroupDelConsumerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXGroupDelConsumerCall) Do(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableXGroupDelConsumerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXGroupDelConsumerCall) DoAndReturn(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableXGroupDelConsumerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XGroupDestroy mocks base method.
func (m *MockCmdable) XGroupDestroy(ctx context.Context, stream, group string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XGroupDestroy", ctx, stream, group)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XGroupDestroy indicates an expected call of XGroupDestroy.
func (mr *MockCmdableMockRecorder) XGroupDestroy(ctx, stream, group any) *MockCmdableXGroupDestroyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XGroupDestroy", reflect.TypeOf((*MockCmdable)(nil).XGroupDestroy), ctx, stream, group)
	return &MockCmdableXGroupDestroyCall{Call: call}
}

// MockCmdableXGroupDestroyCall wrap *gomock.Call
type MockCmdableXGroupDestroyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXGroupDestroyCall) Return(arg0 *redis.IntCmd) *MockCmdableXGroupDestroyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXGroupDestroyCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableXGroupDestroyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXGroupDestroyCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableXGroupDestroyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XGroupSetID mocks base method.
func (m *MockCmdable) XGroupSetID(ctx context.Context, stream, group, start string) *redis.StatusCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XGroupSetID", ctx, stream, group, start)
	ret0, _ := ret[0].(*redis.StatusCmd)
	return ret0
}

// XGroupSetID indicates an expected call of XGroupSetID.
func (mr *MockCmdableMockRecorder) XGroupSetID(ctx, stream, group, start any) *MockCmdableXGroupSetIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XGroupSetID", reflect.TypeOf((*MockCmdable)(nil).XGroupSetID), ctx, stream, group, start)
	return &MockCmdableXGroupSetIDCall{Call: call}
}

// MockCmdableXGroupSetIDCall wrap *gomock.Call
type MockCmdableXGroupSetIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXGroupSetIDCall) Return(arg0 *redis.StatusCmd) *MockCmdableXGroupSetIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXGroupSetIDCall) Do(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableXGroupSetIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXGroupSetIDCall) DoAndReturn(f func(context.Context, string, string, string) *redis.StatusCmd) *MockCmdableXGroupSetIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XInfoConsumers mocks base method.
func (m *MockCmdable) XInfoConsumers(ctx context.Context, key, group string) *redis.XInfoConsumersCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XInfoConsumers", ctx, key, group)
	ret0, _ := ret[0].(*redis.XInfoConsumersCmd)
	return ret0
}

// XInfoConsumers indicates an expected call of XInfoConsumers.
func (mr *MockCmdableMockRecorder) XInfoConsumers(ctx, key, group any) *MockCmdableXInfoConsumersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XInfoConsumers", reflect.TypeOf((*MockCmdable)(nil).XInfoConsumers), ctx, key, group)
	return &MockCmdableXInfoConsumersCall{Call: call}
}

// MockCmdableXInfoConsumersCall wrap *gomock.Call
type MockCmdableXInfoConsumersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXInfoConsumersCall) Return(arg0 *redis.XInfoConsumersCmd) *MockCmdableXInfoConsumersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXInfoConsumersCall) Do(f func(context.Context, string, string) *redis.XInfoConsumersCmd) *MockCmdableXInfoConsumersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXInfoConsumersCall) DoAndReturn(f func(context.Context, string, string) *redis.XInfoConsumersCmd) *MockCmdableXInfoConsumersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XInfoGroups mocks base method.
func (m *MockCmdable) XInfoGroups(ctx context.Context, key string) *redis.XInfoGroupsCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XInfoGroups", ctx, key)
	ret0, _ := ret[0].(*redis.XInfoGroupsCmd)
	return ret0
}

// XInfoGroups indicates an expected call of XInfoGroups.
func (mr *MockCmdableMockRecorder) XInfoGroups(ctx, key any) *MockCmdableXInfoGroupsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XInfoGroups", reflect.TypeOf((*MockCmdable)(nil).XInfoGroups), ctx, key)
	return &MockCmdableXInfoGroupsCall{Call: call}
}

// MockCmdableXInfoGroupsCall wrap *gomock.Call
type MockCmdableXInfoGroupsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXInfoGroupsCall) Return(arg0 *redis.XInfoGroupsCmd) *MockCmdableXInfoGroupsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXInfoGroupsCall) Do(f func(context.Context, string) *redis.XInfoGroupsCmd) *MockCmdableXInfoGroupsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXInfoGroupsCall) DoAndReturn(f func(context.Context, string) *redis.XInfoGroupsCmd) *MockCmdableXInfoGroupsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XInfoStream mocks base method.
func (m *MockCmdable) XInfoStream(ctx context.Context, key string) *redis.XInfoStreamCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XInfoStream", ctx, key)
	ret0, _ := ret[0].(*redis.XInfoStreamCmd)
	return ret0
}

// XInfoStream indicates an expected call of XInfoStream.
func (mr *MockCmdableMockRecorder) XInfoStream(ctx, key any) *MockCmdableXInfoStreamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XInfoStream", reflect.TypeOf((*MockCmdable)(nil).XInfoStream), ctx, key)
	return &MockCmdableXInfoStreamCall{Call: call}
}

// MockCmdableXInfoStreamCall wrap *gomock.Call
type MockCmdableXInfoStreamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXInfoStreamCall) Return(arg0 *redis.XInfoStreamCmd) *MockCmdableXInfoStreamCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXInfoStreamCall) Do(f func(context.Context, string) *redis.XInfoStreamCmd) *MockCmdableXInfoStreamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXInfoStreamCall) DoAndReturn(f func(context.Context, string) *redis.XInfoStreamCmd) *MockCmdableXInfoStreamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XInfoStreamFull mocks base method.
func (m *MockCmdable) XInfoStreamFull(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XInfoStreamFull", ctx, key, count)
	ret0, _ := ret[0].(*redis.XInfoStreamFullCmd)
	return ret0
}

// XInfoStreamFull indicates an expected call of XInfoStreamFull.
func (mr *MockCmdableMockRecorder) XInfoStreamFull(ctx, key, count any) *MockCmdableXInfoStreamFullCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XInfoStreamFull", reflect.TypeOf((*MockCmdable)(nil).XInfoStreamFull), ctx, key, count)
	return &MockCmdableXInfoStreamFullCall{Call: call}
}

// MockCmdableXInfoStreamFullCall wrap *gomock.Call
type MockCmdableXInfoStreamFullCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXInfoStreamFullCall) Return(arg0 *redis.XInfoStreamFullCmd) *MockCmdableXInfoStreamFullCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXInfoStreamFullCall) Do(f func(context.Context, string, int) *redis.XInfoStreamFullCmd) *MockCmdableXInfoStreamFullCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXInfoStreamFullCall) DoAndReturn(f func(context.Context, string, int) *redis.XInfoStreamFullCmd) *MockCmdableXInfoStreamFullCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XLen mocks base method.
func (m *MockCmdable) XLen(ctx context.Context, stream string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XLen", ctx, stream)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XLen indicates an expected call of XLen.
func (mr *MockCmdableMockRecorder) XLen(ctx, stream any) *MockCmdableXLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XLen", reflect.TypeOf((*MockCmdable)(nil).XLen), ctx, stream)
	return &MockCmdableXLenCall{Call: call}
}

// MockCmdableXLenCall wrap *gomock.Call
type MockCmdableXLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXLenCall) Return(arg0 *redis.IntCmd) *MockCmdableXLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXLenCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableXLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXLenCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableXLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XPending mocks base method.
func (m *MockCmdable) XPending(ctx context.Context, stream, group string) *redis.XPendingCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XPending", ctx, stream, group)
	ret0, _ := ret[0].(*redis.XPendingCmd)
	return ret0
}

// XPending indicates an expected call of XPending.
func (mr *MockCmdableMockRecorder) XPending(ctx, stream, group any) *MockCmdableXPendingCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XPending", reflect.TypeOf((*MockCmdable)(nil).XPending), ctx, stream, group)
	return &MockCmdableXPendingCall{Call: call}
}

// MockCmdableXPendingCall wrap *gomock.Call
type MockCmdableXPendingCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXPendingCall) Return(arg0 *redis.XPendingCmd) *MockCmdableXPendingCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXPendingCall) Do(f func(context.Context, string, string) *redis.XPendingCmd) *MockCmdableXPendingCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXPendingCall) DoAndReturn(f func(context.Context, string, string) *redis.XPendingCmd) *MockCmdableXPendingCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XPendingExt mocks base method.
func (m *MockCmdable) XPendingExt(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XPendingExt", ctx, a)
	ret0, _ := ret[0].(*redis.XPendingExtCmd)
	return ret0
}

// XPendingExt indicates an expected call of XPendingExt.
func (mr *MockCmdableMockRecorder) XPendingExt(ctx, a any) *MockCmdableXPendingExtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XPendingExt", reflect.TypeOf((*MockCmdable)(nil).XPendingExt), ctx, a)
	return &MockCmdableXPendingExtCall{Call: call}
}

// MockCmdableXPendingExtCall wrap *gomock.Call
type MockCmdableXPendingExtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXPendingExtCall) Return(arg0 *redis.XPendingExtCmd) *MockCmdableXPendingExtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXPendingExtCall) Do(f func(context.Context, *redis.XPendingExtArgs) *redis.XPendingExtCmd) *MockCmdableXPendingExtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXPendingExtCall) DoAndReturn(f func(context.Context, *redis.XPendingExtArgs) *redis.XPendingExtCmd) *MockCmdableXPendingExtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XRange mocks base method.
func (m *MockCmdable) XRange(ctx context.Context, stream, start, stop string) *redis.XMessageSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XRange", ctx, stream, start, stop)
	ret0, _ := ret[0].(*redis.XMessageSliceCmd)
	return ret0
}

// XRange indicates an expected call of XRange.
func (mr *MockCmdableMockRecorder) XRange(ctx, stream, start, stop any) *MockCmdableXRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XRange", reflect.TypeOf((*MockCmdable)(nil).XRange), ctx, stream, start, stop)
	return &MockCmdableXRangeCall{Call: call}
}

// MockCmdableXRangeCall wrap *gomock.Call
type MockCmdableXRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXRangeCall) Return(arg0 *redis.XMessageSliceCmd) *MockCmdableXRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXRangeCall) Do(f func(context.Context, string, string, string) *redis.XMessageSliceCmd) *MockCmdableXRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXRangeCall) DoAndReturn(f func(context.Context, string, string, string) *redis.XMessageSliceCmd) *MockCmdableXRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XRangeN mocks base method.
func (m *MockCmdable) XRangeN(ctx context.Context, stream, start, stop string, count int64) *redis.XMessageSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XRangeN", ctx, stream, start, stop, count)
	ret0, _ := ret[0].(*redis.XMessageSliceCmd)
	return ret0
}

// XRangeN indicates an expected call of XRangeN.
func (mr *MockCmdableMockRecorder) XRangeN(ctx, stream, start, stop, count any) *MockCmdableXRangeNCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XRangeN", reflect.TypeOf((*MockCmdable)(nil).XRangeN), ctx, stream, start, stop, count)
	return &MockCmdableXRangeNCall{Call: call}
}

// MockCmdableXRangeNCall wrap *gomock.Call
type MockCmdableXRangeNCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXRangeNCall) Return(arg0 *redis.XMessageSliceCmd) *MockCmdableXRangeNCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXRangeNCall) Do(f func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd) *MockCmdableXRangeNCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXRangeNCall) DoAndReturn(f func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd) *MockCmdableXRangeNCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XRead mocks base method.
func (m *MockCmdable) XRead(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XRead", ctx, a)
	ret0, _ := ret[0].(*redis.XStreamSliceCmd)
	return ret0
}

// XRead indicates an expected call of XRead.
func (mr *MockCmdableMockRecorder) XRead(ctx, a any) *MockCmdableXReadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XRead", reflect.TypeOf((*MockCmdable)(nil).XRead), ctx, a)
	return &MockCmdableXReadCall{Call: call}
}

// MockCmdableXReadCall wrap *gomock.Call
type MockCmdableXReadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXReadCall) Return(arg0 *redis.XStreamSliceCmd) *MockCmdableXReadCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXReadCall) Do(f func(context.Context, *redis.XReadArgs) *redis.XStreamSliceCmd) *MockCmdableXReadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXReadCall) DoAndReturn(f func(context.Context, *redis.XReadArgs) *redis.XStreamSliceCmd) *MockCmdableXReadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XReadGroup mocks base method.
func (m *MockCmdable) XReadGroup(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XReadGroup", ctx, a)
	ret0, _ := ret[0].(*redis.XStreamSliceCmd)
	return ret0
}

// XReadGroup indicates an expected call of XReadGroup.
func (mr *MockCmdableMockRecorder) XReadGroup(ctx, a any) *MockCmdableXReadGroupCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XReadGroup", reflect.TypeOf((*MockCmdable)(nil).XReadGroup), ctx, a)
	return &MockCmdableXReadGroupCall{Call: call}
}

// MockCmdableXReadGroupCall wrap *gomock.Call
type MockCmdableXReadGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXReadGroupCall) Return(arg0 *redis.XStreamSliceCmd) *MockCmdableXReadGroupCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXReadGroupCall) Do(f func(context.Context, *redis.XReadGroupArgs) *redis.XStreamSliceCmd) *MockCmdableXReadGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXReadGroupCall) DoAndReturn(f func(context.Context, *redis.XReadGroupArgs) *redis.XStreamSliceCmd) *MockCmdableXReadGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XReadStreams mocks base method.
func (m *MockCmdable) XReadStreams(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range streams {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "XReadStreams", varargs...)
	ret0, _ := ret[0].(*redis.XStreamSliceCmd)
	return ret0
}

// XReadStreams indicates an expected call of XReadStreams.
func (mr *MockCmdableMockRecorder) XReadStreams(ctx any, streams ...any) *MockCmdableXReadStreamsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, streams...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XReadStreams", reflect.TypeOf((*MockCmdable)(nil).XReadStreams), varargs...)
	return &MockCmdableXReadStreamsCall{Call: call}
}

// MockCmdableXReadStreamsCall wrap *gomock.Call
type MockCmdableXReadStreamsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXReadStreamsCall) Return(arg0 *redis.XStreamSliceCmd) *MockCmdableXReadStreamsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXReadStreamsCall) Do(f func(context.Context, ...string) *redis.XStreamSliceCmd) *MockCmdableXReadStreamsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXReadStreamsCall) DoAndReturn(f func(context.Context, ...string) *redis.XStreamSliceCmd) *MockCmdableXReadStreamsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XRevRange mocks base method.
func (m *MockCmdable) XRevRange(ctx context.Context, stream, start, stop string) *redis.XMessageSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XRevRange", ctx, stream, start, stop)
	ret0, _ := ret[0].(*redis.XMessageSliceCmd)
	return ret0
}

// XRevRange indicates an expected call of XRevRange.
func (mr *MockCmdableMockRecorder) XRevRange(ctx, stream, start, stop any) *MockCmdableXRevRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XRevRange", reflect.TypeOf((*MockCmdable)(nil).XRevRange), ctx, stream, start, stop)
	return &MockCmdableXRevRangeCall{Call: call}
}

// MockCmdableXRevRangeCall wrap *gomock.Call
type MockCmdableXRevRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXRevRangeCall) Return(arg0 *redis.XMessageSliceCmd) *MockCmdableXRevRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXRevRangeCall) Do(f func(context.Context, string, string, string) *redis.XMessageSliceCmd) *MockCmdableXRevRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXRevRangeCall) DoAndReturn(f func(context.Context, string, string, string) *redis.XMessageSliceCmd) *MockCmdableXRevRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XRevRangeN mocks base method.
func (m *MockCmdable) XRevRangeN(ctx context.Context, stream, start, stop string, count int64) *redis.XMessageSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XRevRangeN", ctx, stream, start, stop, count)
	ret0, _ := ret[0].(*redis.XMessageSliceCmd)
	return ret0
}

// XRevRangeN indicates an expected call of XRevRangeN.
func (mr *MockCmdableMockRecorder) XRevRangeN(ctx, stream, start, stop, count any) *MockCmdableXRevRangeNCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XRevRangeN", reflect.TypeOf((*MockCmdable)(nil).XRevRangeN), ctx, stream, start, stop, count)
	return &MockCmdableXRevRangeNCall{Call: call}
}

// MockCmdableXRevRangeNCall wrap *gomock.Call
type MockCmdableXRevRangeNCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXRevRangeNCall) Return(arg0 *redis.XMessageSliceCmd) *MockCmdableXRevRangeNCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXRevRangeNCall) Do(f func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd) *MockCmdableXRevRangeNCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXRevRangeNCall) DoAndReturn(f func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd) *MockCmdableXRevRangeNCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XTrimMaxLen mocks base method.
func (m *MockCmdable) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XTrimMaxLen", ctx, key, maxLen)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XTrimMaxLen indicates an expected call of XTrimMaxLen.
func (mr *MockCmdableMockRecorder) XTrimMaxLen(ctx, key, maxLen any) *MockCmdableXTrimMaxLenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XTrimMaxLen", reflect.TypeOf((*MockCmdable)(nil).XTrimMaxLen), ctx, key, maxLen)
	return &MockCmdableXTrimMaxLenCall{Call: call}
}

// MockCmdableXTrimMaxLenCall wrap *gomock.Call
type MockCmdableXTrimMaxLenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXTrimMaxLenCall) Return(arg0 *redis.IntCmd) *MockCmdableXTrimMaxLenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXTrimMaxLenCall) Do(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableXTrimMaxLenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXTrimMaxLenCall) DoAndReturn(f func(context.Context, string, int64) *redis.IntCmd) *MockCmdableXTrimMaxLenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XTrimMaxLenApprox mocks base method.
func (m *MockCmdable) XTrimMaxLenApprox(ctx context.Context, key string, maxLen, limit int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XTrimMaxLenApprox", ctx, key, maxLen, limit)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XTrimMaxLenApprox indicates an expected call of XTrimMaxLenApprox.
func (mr *MockCmdableMockRecorder) XTrimMaxLenApprox(ctx, key, maxLen, limit any) *MockCmdableXTrimMaxLenApproxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XTrimMaxLenApprox", reflect.TypeOf((*MockCmdable)(nil).XTrimMaxLenApprox), ctx, key, maxLen, limit)
	return &MockCmdableXTrimMaxLenApproxCall{Call: call}
}

// MockCmdableXTrimMaxLenApproxCall wrap *gomock.Call
type MockCmdableXTrimMaxLenApproxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXTrimMaxLenApproxCall) Return(arg0 *redis.IntCmd) *MockCmdableXTrimMaxLenApproxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXTrimMaxLenApproxCall) Do(f func(context.Context, string, int64, int64) *redis.IntCmd) *MockCmdableXTrimMaxLenApproxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXTrimMaxLenApproxCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.IntCmd) *MockCmdableXTrimMaxLenApproxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XTrimMinID mocks base method.
func (m *MockCmdable) XTrimMinID(ctx context.Context, key, minID string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XTrimMinID", ctx, key, minID)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XTrimMinID indicates an expected call of XTrimMinID.
func (mr *MockCmdableMockRecorder) XTrimMinID(ctx, key, minID any) *MockCmdableXTrimMinIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XTrimMinID", reflect.TypeOf((*MockCmdable)(nil).XTrimMinID), ctx, key, minID)
	return &MockCmdableXTrimMinIDCall{Call: call}
}

// MockCmdableXTrimMinIDCall wrap *gomock.Call
type MockCmdableXTrimMinIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXTrimMinIDCall) Return(arg0 *redis.IntCmd) *MockCmdableXTrimMinIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXTrimMinIDCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableXTrimMinIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXTrimMinIDCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableXTrimMinIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// XTrimMinIDApprox mocks base method.
func (m *MockCmdable) XTrimMinIDApprox(ctx context.Context, key, minID string, limit int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "XTrimMinIDApprox", ctx, key, minID, limit)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// XTrimMinIDApprox indicates an expected call of XTrimMinIDApprox.
func (mr *MockCmdableMockRecorder) XTrimMinIDApprox(ctx, key, minID, limit any) *MockCmdableXTrimMinIDApproxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "XTrimMinIDApprox", reflect.TypeOf((*MockCmdable)(nil).XTrimMinIDApprox), ctx, key, minID, limit)
	return &MockCmdableXTrimMinIDApproxCall{Call: call}
}

// MockCmdableXTrimMinIDApproxCall wrap *gomock.Call
type MockCmdableXTrimMinIDApproxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableXTrimMinIDApproxCall) Return(arg0 *redis.IntCmd) *MockCmdableXTrimMinIDApproxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableXTrimMinIDApproxCall) Do(f func(context.Context, string, string, int64) *redis.IntCmd) *MockCmdableXTrimMinIDApproxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableXTrimMinIDApproxCall) DoAndReturn(f func(context.Context, string, string, int64) *redis.IntCmd) *MockCmdableXTrimMinIDApproxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZAdd mocks base method.
func (m *MockCmdable) ZAdd(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZAdd", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZAdd indicates an expected call of ZAdd.
func (mr *MockCmdableMockRecorder) ZAdd(ctx, key any, members ...any) *MockCmdableZAddCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAdd", reflect.TypeOf((*MockCmdable)(nil).ZAdd), varargs...)
	return &MockCmdableZAddCall{Call: call}
}

// MockCmdableZAddCall wrap *gomock.Call
type MockCmdableZAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZAddCall) Return(arg0 *redis.IntCmd) *MockCmdableZAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZAddCall) Do(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZAddCall) DoAndReturn(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZAddArgs mocks base method.
func (m *MockCmdable) ZAddArgs(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZAddArgs", ctx, key, args)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZAddArgs indicates an expected call of ZAddArgs.
func (mr *MockCmdableMockRecorder) ZAddArgs(ctx, key, args any) *MockCmdableZAddArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAddArgs", reflect.TypeOf((*MockCmdable)(nil).ZAddArgs), ctx, key, args)
	return &MockCmdableZAddArgsCall{Call: call}
}

// MockCmdableZAddArgsCall wrap *gomock.Call
type MockCmdableZAddArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZAddArgsCall) Return(arg0 *redis.IntCmd) *MockCmdableZAddArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZAddArgsCall) Do(f func(context.Context, string, redis.ZAddArgs) *redis.IntCmd) *MockCmdableZAddArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZAddArgsCall) DoAndReturn(f func(context.Context, string, redis.ZAddArgs) *redis.IntCmd) *MockCmdableZAddArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZAddArgsIncr mocks base method.
func (m *MockCmdable) ZAddArgsIncr(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZAddArgsIncr", ctx, key, args)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// ZAddArgsIncr indicates an expected call of ZAddArgsIncr.
func (mr *MockCmdableMockRecorder) ZAddArgsIncr(ctx, key, args any) *MockCmdableZAddArgsIncrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAddArgsIncr", reflect.TypeOf((*MockCmdable)(nil).ZAddArgsIncr), ctx, key, args)
	return &MockCmdableZAddArgsIncrCall{Call: call}
}

// MockCmdableZAddArgsIncrCall wrap *gomock.Call
type MockCmdableZAddArgsIncrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZAddArgsIncrCall) Return(arg0 *redis.FloatCmd) *MockCmdableZAddArgsIncrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZAddArgsIncrCall) Do(f func(context.Context, string, redis.ZAddArgs) *redis.FloatCmd) *MockCmdableZAddArgsIncrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZAddArgsIncrCall) DoAndReturn(f func(context.Context, string, redis.ZAddArgs) *redis.FloatCmd) *MockCmdableZAddArgsIncrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZAddGT mocks base method.
func (m *MockCmdable) ZAddGT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZAddGT", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZAddGT indicates an expected call of ZAddGT.
func (mr *MockCmdableMockRecorder) ZAddGT(ctx, key any, members ...any) *MockCmdableZAddGTCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAddGT", reflect.TypeOf((*MockCmdable)(nil).ZAddGT), varargs...)
	return &MockCmdableZAddGTCall{Call: call}
}

// MockCmdableZAddGTCall wrap *gomock.Call
type MockCmdableZAddGTCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZAddGTCall) Return(arg0 *redis.IntCmd) *MockCmdableZAddGTCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZAddGTCall) Do(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddGTCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZAddGTCall) DoAndReturn(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddGTCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZAddLT mocks base method.
func (m *MockCmdable) ZAddLT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZAddLT", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZAddLT indicates an expected call of ZAddLT.
func (mr *MockCmdableMockRecorder) ZAddLT(ctx, key any, members ...any) *MockCmdableZAddLTCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAddLT", reflect.TypeOf((*MockCmdable)(nil).ZAddLT), varargs...)
	return &MockCmdableZAddLTCall{Call: call}
}

// MockCmdableZAddLTCall wrap *gomock.Call
type MockCmdableZAddLTCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZAddLTCall) Return(arg0 *redis.IntCmd) *MockCmdableZAddLTCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZAddLTCall) Do(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddLTCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZAddLTCall) DoAndReturn(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddLTCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZAddNX mocks base method.
func (m *MockCmdable) ZAddNX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZAddNX", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZAddNX indicates an expected call of ZAddNX.
func (mr *MockCmdableMockRecorder) ZAddNX(ctx, key any, members ...any) *MockCmdableZAddNXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAddNX", reflect.TypeOf((*MockCmdable)(nil).ZAddNX), varargs...)
	return &MockCmdableZAddNXCall{Call: call}
}

// MockCmdableZAddNXCall wrap *gomock.Call
type MockCmdableZAddNXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZAddNXCall) Return(arg0 *redis.IntCmd) *MockCmdableZAddNXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZAddNXCall) Do(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddNXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZAddNXCall) DoAndReturn(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddNXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZAddXX mocks base method.
func (m *MockCmdable) ZAddXX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZAddXX", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZAddXX indicates an expected call of ZAddXX.
func (mr *MockCmdableMockRecorder) ZAddXX(ctx, key any, members ...any) *MockCmdableZAddXXCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZAddXX", reflect.TypeOf((*MockCmdable)(nil).ZAddXX), varargs...)
	return &MockCmdableZAddXXCall{Call: call}
}

// MockCmdableZAddXXCall wrap *gomock.Call
type MockCmdableZAddXXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZAddXXCall) Return(arg0 *redis.IntCmd) *MockCmdableZAddXXCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZAddXXCall) Do(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddXXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZAddXXCall) DoAndReturn(f func(context.Context, string, ...redis.Z) *redis.IntCmd) *MockCmdableZAddXXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZCard mocks base method.
func (m *MockCmdable) ZCard(ctx context.Context, key string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZCard", ctx, key)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZCard indicates an expected call of ZCard.
func (mr *MockCmdableMockRecorder) ZCard(ctx, key any) *MockCmdableZCardCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZCard", reflect.TypeOf((*MockCmdable)(nil).ZCard), ctx, key)
	return &MockCmdableZCardCall{Call: call}
}

// MockCmdableZCardCall wrap *gomock.Call
type MockCmdableZCardCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZCardCall) Return(arg0 *redis.IntCmd) *MockCmdableZCardCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZCardCall) Do(f func(context.Context, string) *redis.IntCmd) *MockCmdableZCardCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZCardCall) DoAndReturn(f func(context.Context, string) *redis.IntCmd) *MockCmdableZCardCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZCount mocks base method.
func (m *MockCmdable) ZCount(ctx context.Context, key, min, max string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZCount", ctx, key, min, max)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZCount indicates an expected call of ZCount.
func (mr *MockCmdableMockRecorder) ZCount(ctx, key, min, max any) *MockCmdableZCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZCount", reflect.TypeOf((*MockCmdable)(nil).ZCount), ctx, key, min, max)
	return &MockCmdableZCountCall{Call: call}
}

// MockCmdableZCountCall wrap *gomock.Call
type MockCmdableZCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZCountCall) Return(arg0 *redis.IntCmd) *MockCmdableZCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZCountCall) Do(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZCountCall) DoAndReturn(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZDiff mocks base method.
func (m *MockCmdable) ZDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZDiff", varargs...)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZDiff indicates an expected call of ZDiff.
func (mr *MockCmdableMockRecorder) ZDiff(ctx any, keys ...any) *MockCmdableZDiffCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZDiff", reflect.TypeOf((*MockCmdable)(nil).ZDiff), varargs...)
	return &MockCmdableZDiffCall{Call: call}
}

// MockCmdableZDiffCall wrap *gomock.Call
type MockCmdableZDiffCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZDiffCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZDiffCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZDiffCall) Do(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableZDiffCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZDiffCall) DoAndReturn(f func(context.Context, ...string) *redis.StringSliceCmd) *MockCmdableZDiffCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZDiffStore mocks base method.
func (m *MockCmdable) ZDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, destination}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZDiffStore", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZDiffStore indicates an expected call of ZDiffStore.
func (mr *MockCmdableMockRecorder) ZDiffStore(ctx, destination any, keys ...any) *MockCmdableZDiffStoreCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, destination}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZDiffStore", reflect.TypeOf((*MockCmdable)(nil).ZDiffStore), varargs...)
	return &MockCmdableZDiffStoreCall{Call: call}
}

// MockCmdableZDiffStoreCall wrap *gomock.Call
type MockCmdableZDiffStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZDiffStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableZDiffStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZDiffStoreCall) Do(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableZDiffStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZDiffStoreCall) DoAndReturn(f func(context.Context, string, ...string) *redis.IntCmd) *MockCmdableZDiffStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZDiffWithScores mocks base method.
func (m *MockCmdable) ZDiffWithScores(ctx context.Context, keys ...string) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZDiffWithScores", varargs...)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZDiffWithScores indicates an expected call of ZDiffWithScores.
func (mr *MockCmdableMockRecorder) ZDiffWithScores(ctx any, keys ...any) *MockCmdableZDiffWithScoresCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZDiffWithScores", reflect.TypeOf((*MockCmdable)(nil).ZDiffWithScores), varargs...)
	return &MockCmdableZDiffWithScoresCall{Call: call}
}

// MockCmdableZDiffWithScoresCall wrap *gomock.Call
type MockCmdableZDiffWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZDiffWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZDiffWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZDiffWithScoresCall) Do(f func(context.Context, ...string) *redis.ZSliceCmd) *MockCmdableZDiffWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZDiffWithScoresCall) DoAndReturn(f func(context.Context, ...string) *redis.ZSliceCmd) *MockCmdableZDiffWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZIncrBy mocks base method.
func (m *MockCmdable) ZIncrBy(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZIncrBy", ctx, key, increment, member)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// ZIncrBy indicates an expected call of ZIncrBy.
func (mr *MockCmdableMockRecorder) ZIncrBy(ctx, key, increment, member any) *MockCmdableZIncrByCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZIncrBy", reflect.TypeOf((*MockCmdable)(nil).ZIncrBy), ctx, key, increment, member)
	return &MockCmdableZIncrByCall{Call: call}
}

// MockCmdableZIncrByCall wrap *gomock.Call
type MockCmdableZIncrByCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZIncrByCall) Return(arg0 *redis.FloatCmd) *MockCmdableZIncrByCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZIncrByCall) Do(f func(context.Context, string, float64, string) *redis.FloatCmd) *MockCmdableZIncrByCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZIncrByCall) DoAndReturn(f func(context.Context, string, float64, string) *redis.FloatCmd) *MockCmdableZIncrByCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZInter mocks base method.
func (m *MockCmdable) ZInter(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZInter", ctx, store)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZInter indicates an expected call of ZInter.
func (mr *MockCmdableMockRecorder) ZInter(ctx, store any) *MockCmdableZInterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZInter", reflect.TypeOf((*MockCmdable)(nil).ZInter), ctx, store)
	return &MockCmdableZInterCall{Call: call}
}

// MockCmdableZInterCall wrap *gomock.Call
type MockCmdableZInterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZInterCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZInterCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZInterCall) Do(f func(context.Context, *redis.ZStore) *redis.StringSliceCmd) *MockCmdableZInterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZInterCall) DoAndReturn(f func(context.Context, *redis.ZStore) *redis.StringSliceCmd) *MockCmdableZInterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZInterCard mocks base method.
func (m *MockCmdable) ZInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, limit}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZInterCard", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZInterCard indicates an expected call of ZInterCard.
func (mr *MockCmdableMockRecorder) ZInterCard(ctx, limit any, keys ...any) *MockCmdableZInterCardCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, limit}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZInterCard", reflect.TypeOf((*MockCmdable)(nil).ZInterCard), varargs...)
	return &MockCmdableZInterCardCall{Call: call}
}

// MockCmdableZInterCardCall wrap *gomock.Call
type MockCmdableZInterCardCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZInterCardCall) Return(arg0 *redis.IntCmd) *MockCmdableZInterCardCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZInterCardCall) Do(f func(context.Context, int64, ...string) *redis.IntCmd) *MockCmdableZInterCardCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZInterCardCall) DoAndReturn(f func(context.Context, int64, ...string) *redis.IntCmd) *MockCmdableZInterCardCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZInterStore mocks base method.
func (m *MockCmdable) ZInterStore(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZInterStore", ctx, destination, store)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZInterStore indicates an expected call of ZInterStore.
func (mr *MockCmdableMockRecorder) ZInterStore(ctx, destination, store any) *MockCmdableZInterStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZInterStore", reflect.TypeOf((*MockCmdable)(nil).ZInterStore), ctx, destination, store)
	return &MockCmdableZInterStoreCall{Call: call}
}

// MockCmdableZInterStoreCall wrap *gomock.Call
type MockCmdableZInterStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZInterStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableZInterStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZInterStoreCall) Do(f func(context.Context, string, *redis.ZStore) *redis.IntCmd) *MockCmdableZInterStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZInterStoreCall) DoAndReturn(f func(context.Context, string, *redis.ZStore) *redis.IntCmd) *MockCmdableZInterStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZInterWithScores mocks base method.
func (m *MockCmdable) ZInterWithScores(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZInterWithScores", ctx, store)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZInterWithScores indicates an expected call of ZInterWithScores.
func (mr *MockCmdableMockRecorder) ZInterWithScores(ctx, store any) *MockCmdableZInterWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZInterWithScores", reflect.TypeOf((*MockCmdable)(nil).ZInterWithScores), ctx, store)
	return &MockCmdableZInterWithScoresCall{Call: call}
}

// MockCmdableZInterWithScoresCall wrap *gomock.Call
type MockCmdableZInterWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZInterWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZInterWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZInterWithScoresCall) Do(f func(context.Context, *redis.ZStore) *redis.ZSliceCmd) *MockCmdableZInterWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZInterWithScoresCall) DoAndReturn(f func(context.Context, *redis.ZStore) *redis.ZSliceCmd) *MockCmdableZInterWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZLexCount mocks base method.
func (m *MockCmdable) ZLexCount(ctx context.Context, key, min, max string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZLexCount", ctx, key, min, max)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZLexCount indicates an expected call of ZLexCount.
func (mr *MockCmdableMockRecorder) ZLexCount(ctx, key, min, max any) *MockCmdableZLexCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZLexCount", reflect.TypeOf((*MockCmdable)(nil).ZLexCount), ctx, key, min, max)
	return &MockCmdableZLexCountCall{Call: call}
}

// MockCmdableZLexCountCall wrap *gomock.Call
type MockCmdableZLexCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZLexCountCall) Return(arg0 *redis.IntCmd) *MockCmdableZLexCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZLexCountCall) Do(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZLexCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZLexCountCall) DoAndReturn(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZLexCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZMPop mocks base method.
func (m *MockCmdable) ZMPop(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, order, count}
	for _, a := range keys {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZMPop", varargs...)
	ret0, _ := ret[0].(*redis.ZSliceWithKeyCmd)
	return ret0
}

// ZMPop indicates an expected call of ZMPop.
func (mr *MockCmdableMockRecorder) ZMPop(ctx, order, count any, keys ...any) *MockCmdableZMPopCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, order, count}, keys...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZMPop", reflect.TypeOf((*MockCmdable)(nil).ZMPop), varargs...)
	return &MockCmdableZMPopCall{Call: call}
}

// MockCmdableZMPopCall wrap *gomock.Call
type MockCmdableZMPopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZMPopCall) Return(arg0 *redis.ZSliceWithKeyCmd) *MockCmdableZMPopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZMPopCall) Do(f func(context.Context, string, int64, ...string) *redis.ZSliceWithKeyCmd) *MockCmdableZMPopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZMPopCall) DoAndReturn(f func(context.Context, string, int64, ...string) *redis.ZSliceWithKeyCmd) *MockCmdableZMPopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZMScore mocks base method.
func (m *MockCmdable) ZMScore(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZMScore", varargs...)
	ret0, _ := ret[0].(*redis.FloatSliceCmd)
	return ret0
}

// ZMScore indicates an expected call of ZMScore.
func (mr *MockCmdableMockRecorder) ZMScore(ctx, key any, members ...any) *MockCmdableZMScoreCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZMScore", reflect.TypeOf((*MockCmdable)(nil).ZMScore), varargs...)
	return &MockCmdableZMScoreCall{Call: call}
}

// MockCmdableZMScoreCall wrap *gomock.Call
type MockCmdableZMScoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZMScoreCall) Return(arg0 *redis.FloatSliceCmd) *MockCmdableZMScoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZMScoreCall) Do(f func(context.Context, string, ...string) *redis.FloatSliceCmd) *MockCmdableZMScoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZMScoreCall) DoAndReturn(f func(context.Context, string, ...string) *redis.FloatSliceCmd) *MockCmdableZMScoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZPopMax mocks base method.
func (m *MockCmdable) ZPopMax(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range count {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZPopMax", varargs...)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZPopMax indicates an expected call of ZPopMax.
func (mr *MockCmdableMockRecorder) ZPopMax(ctx, key any, count ...any) *MockCmdableZPopMaxCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, count...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZPopMax", reflect.TypeOf((*MockCmdable)(nil).ZPopMax), varargs...)
	return &MockCmdableZPopMaxCall{Call: call}
}

// MockCmdableZPopMaxCall wrap *gomock.Call
type MockCmdableZPopMaxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZPopMaxCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZPopMaxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZPopMaxCall) Do(f func(context.Context, string, ...int64) *redis.ZSliceCmd) *MockCmdableZPopMaxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZPopMaxCall) DoAndReturn(f func(context.Context, string, ...int64) *redis.ZSliceCmd) *MockCmdableZPopMaxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZPopMin mocks base method.
func (m *MockCmdable) ZPopMin(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range count {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZPopMin", varargs...)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZPopMin indicates an expected call of ZPopMin.
func (mr *MockCmdableMockRecorder) ZPopMin(ctx, key any, count ...any) *MockCmdableZPopMinCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, count...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZPopMin", reflect.TypeOf((*MockCmdable)(nil).ZPopMin), varargs...)
	return &MockCmdableZPopMinCall{Call: call}
}

// MockCmdableZPopMinCall wrap *gomock.Call
type MockCmdableZPopMinCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZPopMinCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZPopMinCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZPopMinCall) Do(f func(context.Context, string, ...int64) *redis.ZSliceCmd) *MockCmdableZPopMinCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZPopMinCall) DoAndReturn(f func(context.Context, string, ...int64) *redis.ZSliceCmd) *MockCmdableZPopMinCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRandMember mocks base method.
func (m *MockCmdable) ZRandMember(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRandMember", ctx, key, count)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRandMember indicates an expected call of ZRandMember.
func (mr *MockCmdableMockRecorder) ZRandMember(ctx, key, count any) *MockCmdableZRandMemberCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRandMember", reflect.TypeOf((*MockCmdable)(nil).ZRandMember), ctx, key, count)
	return &MockCmdableZRandMemberCall{Call: call}
}

// MockCmdableZRandMemberCall wrap *gomock.Call
type MockCmdableZRandMemberCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRandMemberCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRandMemberCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRandMemberCall) Do(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableZRandMemberCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRandMemberCall) DoAndReturn(f func(context.Context, string, int) *redis.StringSliceCmd) *MockCmdableZRandMemberCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRandMemberWithScores mocks base method.
func (m *MockCmdable) ZRandMemberWithScores(ctx context.Context, key string, count int) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRandMemberWithScores", ctx, key, count)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZRandMemberWithScores indicates an expected call of ZRandMemberWithScores.
func (mr *MockCmdableMockRecorder) ZRandMemberWithScores(ctx, key, count any) *MockCmdableZRandMemberWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRandMemberWithScores", reflect.TypeOf((*MockCmdable)(nil).ZRandMemberWithScores), ctx, key, count)
	return &MockCmdableZRandMemberWithScoresCall{Call: call}
}

// MockCmdableZRandMemberWithScoresCall wrap *gomock.Call
type MockCmdableZRandMemberWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRandMemberWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZRandMemberWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRandMemberWithScoresCall) Do(f func(context.Context, string, int) *redis.ZSliceCmd) *MockCmdableZRandMemberWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRandMemberWithScoresCall) DoAndReturn(f func(context.Context, string, int) *redis.ZSliceCmd) *MockCmdableZRandMemberWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRange mocks base method.
func (m *MockCmdable) ZRange(ctx context.Context, key string, start, stop int64) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRange", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRange indicates an expected call of ZRange.
func (mr *MockCmdableMockRecorder) ZRange(ctx, key, start, stop any) *MockCmdableZRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRange", reflect.TypeOf((*MockCmdable)(nil).ZRange), ctx, key, start, stop)
	return &MockCmdableZRangeCall{Call: call}
}

// MockCmdableZRangeCall wrap *gomock.Call
type MockCmdableZRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeCall) Do(f func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockCmdableZRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockCmdableZRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRangeArgs mocks base method.
func (m *MockCmdable) ZRangeArgs(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRangeArgs", ctx, z)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRangeArgs indicates an expected call of ZRangeArgs.
func (mr *MockCmdableMockRecorder) ZRangeArgs(ctx, z any) *MockCmdableZRangeArgsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRangeArgs", reflect.TypeOf((*MockCmdable)(nil).ZRangeArgs), ctx, z)
	return &MockCmdableZRangeArgsCall{Call: call}
}

// MockCmdableZRangeArgsCall wrap *gomock.Call
type MockCmdableZRangeArgsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeArgsCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRangeArgsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeArgsCall) Do(f func(context.Context, redis.ZRangeArgs) *redis.StringSliceCmd) *MockCmdableZRangeArgsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeArgsCall) DoAndReturn(f func(context.Context, redis.ZRangeArgs) *redis.StringSliceCmd) *MockCmdableZRangeArgsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRangeArgsWithScores mocks base method.
func (m *MockCmdable) ZRangeArgsWithScores(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRangeArgsWithScores", ctx, z)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZRangeArgsWithScores indicates an expected call of ZRangeArgsWithScores.
func (mr *MockCmdableMockRecorder) ZRangeArgsWithScores(ctx, z any) *MockCmdableZRangeArgsWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRangeArgsWithScores", reflect.TypeOf((*MockCmdable)(nil).ZRangeArgsWithScores), ctx, z)
	return &MockCmdableZRangeArgsWithScoresCall{Call: call}
}

// MockCmdableZRangeArgsWithScoresCall wrap *gomock.Call
type MockCmdableZRangeArgsWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeArgsWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZRangeArgsWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeArgsWithScoresCall) Do(f func(context.Context, redis.ZRangeArgs) *redis.ZSliceCmd) *MockCmdableZRangeArgsWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeArgsWithScoresCall) DoAndReturn(f func(context.Context, redis.ZRangeArgs) *redis.ZSliceCmd) *MockCmdableZRangeArgsWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRangeByLex mocks base method.
func (m *MockCmdable) ZRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRangeByLex", ctx, key, opt)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRangeByLex indicates an expected call of ZRangeByLex.
func (mr *MockCmdableMockRecorder) ZRangeByLex(ctx, key, opt any) *MockCmdableZRangeByLexCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRangeByLex", reflect.TypeOf((*MockCmdable)(nil).ZRangeByLex), ctx, key, opt)
	return &MockCmdableZRangeByLexCall{Call: call}
}

// MockCmdableZRangeByLexCall wrap *gomock.Call
type MockCmdableZRangeByLexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeByLexCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRangeByLexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeByLexCall) Do(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRangeByLexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeByLexCall) DoAndReturn(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRangeByLexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRangeByScore mocks base method.
func (m *MockCmdable) ZRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRangeByScore", ctx, key, opt)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRangeByScore indicates an expected call of ZRangeByScore.
func (mr *MockCmdableMockRecorder) ZRangeByScore(ctx, key, opt any) *MockCmdableZRangeByScoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRangeByScore", reflect.TypeOf((*MockCmdable)(nil).ZRangeByScore), ctx, key, opt)
	return &MockCmdableZRangeByScoreCall{Call: call}
}

// MockCmdableZRangeByScoreCall wrap *gomock.Call
type MockCmdableZRangeByScoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeByScoreCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRangeByScoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeByScoreCall) Do(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRangeByScoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeByScoreCall) DoAndReturn(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRangeByScoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRangeByScoreWithScores mocks base method.
func (m *MockCmdable) ZRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRangeByScoreWithScores", ctx, key, opt)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZRangeByScoreWithScores indicates an expected call of ZRangeByScoreWithScores.
func (mr *MockCmdableMockRecorder) ZRangeByScoreWithScores(ctx, key, opt any) *MockCmdableZRangeByScoreWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRangeByScoreWithScores", reflect.TypeOf((*MockCmdable)(nil).ZRangeByScoreWithScores), ctx, key, opt)
	return &MockCmdableZRangeByScoreWithScoresCall{Call: call}
}

// MockCmdableZRangeByScoreWithScoresCall wrap *gomock.Call
type MockCmdableZRangeByScoreWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeByScoreWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZRangeByScoreWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeByScoreWithScoresCall) Do(f func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd) *MockCmdableZRangeByScoreWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeByScoreWithScoresCall) DoAndReturn(f func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd) *MockCmdableZRangeByScoreWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRangeStore mocks base method.
func (m *MockCmdable) ZRangeStore(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRangeStore", ctx, dst, z)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZRangeStore indicates an expected call of ZRangeStore.
func (mr *MockCmdableMockRecorder) ZRangeStore(ctx, dst, z any) *MockCmdableZRangeStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRangeStore", reflect.TypeOf((*MockCmdable)(nil).ZRangeStore), ctx, dst, z)
	return &MockCmdableZRangeStoreCall{Call: call}
}

// MockCmdableZRangeStoreCall wrap *gomock.Call
type MockCmdableZRangeStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableZRangeStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeStoreCall) Do(f func(context.Context, string, redis.ZRangeArgs) *redis.IntCmd) *MockCmdableZRangeStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeStoreCall) DoAndReturn(f func(context.Context, string, redis.ZRangeArgs) *redis.IntCmd) *MockCmdableZRangeStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRangeWithScores mocks base method.
func (m *MockCmdable) ZRangeWithScores(ctx context.Context, key string, start, stop int64) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRangeWithScores", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZRangeWithScores indicates an expected call of ZRangeWithScores.
func (mr *MockCmdableMockRecorder) ZRangeWithScores(ctx, key, start, stop any) *MockCmdableZRangeWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRangeWithScores", reflect.TypeOf((*MockCmdable)(nil).ZRangeWithScores), ctx, key, start, stop)
	return &MockCmdableZRangeWithScoresCall{Call: call}
}

// MockCmdableZRangeWithScoresCall wrap *gomock.Call
type MockCmdableZRangeWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRangeWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZRangeWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRangeWithScoresCall) Do(f func(context.Context, string, int64, int64) *redis.ZSliceCmd) *MockCmdableZRangeWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRangeWithScoresCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.ZSliceCmd) *MockCmdableZRangeWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRank mocks base method.
func (m *MockCmdable) ZRank(ctx context.Context, key, member string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRank", ctx, key, member)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZRank indicates an expected call of ZRank.
func (mr *MockCmdableMockRecorder) ZRank(ctx, key, member any) *MockCmdableZRankCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRank", reflect.TypeOf((*MockCmdable)(nil).ZRank), ctx, key, member)
	return &MockCmdableZRankCall{Call: call}
}

// MockCmdableZRankCall wrap *gomock.Call
type MockCmdableZRankCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRankCall) Return(arg0 *redis.IntCmd) *MockCmdableZRankCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRankCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableZRankCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRankCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableZRankCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRankWithScore mocks base method.
func (m *MockCmdable) ZRankWithScore(ctx context.Context, key, member string) *redis.RankWithScoreCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRankWithScore", ctx, key, member)
	ret0, _ := ret[0].(*redis.RankWithScoreCmd)
	return ret0
}

// ZRankWithScore indicates an expected call of ZRankWithScore.
func (mr *MockCmdableMockRecorder) ZRankWithScore(ctx, key, member any) *MockCmdableZRankWithScoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRankWithScore", reflect.TypeOf((*MockCmdable)(nil).ZRankWithScore), ctx, key, member)
	return &MockCmdableZRankWithScoreCall{Call: call}
}

// MockCmdableZRankWithScoreCall wrap *gomock.Call
type MockCmdableZRankWithScoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRankWithScoreCall) Return(arg0 *redis.RankWithScoreCmd) *MockCmdableZRankWithScoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRankWithScoreCall) Do(f func(context.Context, string, string) *redis.RankWithScoreCmd) *MockCmdableZRankWithScoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRankWithScoreCall) DoAndReturn(f func(context.Context, string, string) *redis.RankWithScoreCmd) *MockCmdableZRankWithScoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRem mocks base method.
func (m *MockCmdable) ZRem(ctx context.Context, key string, members ...any) *redis.IntCmd {
	m.ctrl.T.Helper()
	varargs := []any{ctx, key}
	for _, a := range members {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ZRem", varargs...)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZRem indicates an expected call of ZRem.
func (mr *MockCmdableMockRecorder) ZRem(ctx, key any, members ...any) *MockCmdableZRemCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, key}, members...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRem", reflect.TypeOf((*MockCmdable)(nil).ZRem), varargs...)
	return &MockCmdableZRemCall{Call: call}
}

// MockCmdableZRemCall wrap *gomock.Call
type MockCmdableZRemCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRemCall) Return(arg0 *redis.IntCmd) *MockCmdableZRemCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRemCall) Do(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableZRemCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRemCall) DoAndReturn(f func(context.Context, string, ...any) *redis.IntCmd) *MockCmdableZRemCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRemRangeByLex mocks base method.
func (m *MockCmdable) ZRemRangeByLex(ctx context.Context, key, min, max string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRemRangeByLex", ctx, key, min, max)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZRemRangeByLex indicates an expected call of ZRemRangeByLex.
func (mr *MockCmdableMockRecorder) ZRemRangeByLex(ctx, key, min, max any) *MockCmdableZRemRangeByLexCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRemRangeByLex", reflect.TypeOf((*MockCmdable)(nil).ZRemRangeByLex), ctx, key, min, max)
	return &MockCmdableZRemRangeByLexCall{Call: call}
}

// MockCmdableZRemRangeByLexCall wrap *gomock.Call
type MockCmdableZRemRangeByLexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRemRangeByLexCall) Return(arg0 *redis.IntCmd) *MockCmdableZRemRangeByLexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRemRangeByLexCall) Do(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZRemRangeByLexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRemRangeByLexCall) DoAndReturn(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZRemRangeByLexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRemRangeByRank mocks base method.
func (m *MockCmdable) ZRemRangeByRank(ctx context.Context, key string, start, stop int64) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRemRangeByRank", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZRemRangeByRank indicates an expected call of ZRemRangeByRank.
func (mr *MockCmdableMockRecorder) ZRemRangeByRank(ctx, key, start, stop any) *MockCmdableZRemRangeByRankCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRemRangeByRank", reflect.TypeOf((*MockCmdable)(nil).ZRemRangeByRank), ctx, key, start, stop)
	return &MockCmdableZRemRangeByRankCall{Call: call}
}

// MockCmdableZRemRangeByRankCall wrap *gomock.Call
type MockCmdableZRemRangeByRankCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRemRangeByRankCall) Return(arg0 *redis.IntCmd) *MockCmdableZRemRangeByRankCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRemRangeByRankCall) Do(f func(context.Context, string, int64, int64) *redis.IntCmd) *MockCmdableZRemRangeByRankCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRemRangeByRankCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.IntCmd) *MockCmdableZRemRangeByRankCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRemRangeByScore mocks base method.
func (m *MockCmdable) ZRemRangeByScore(ctx context.Context, key, min, max string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRemRangeByScore", ctx, key, min, max)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZRemRangeByScore indicates an expected call of ZRemRangeByScore.
func (mr *MockCmdableMockRecorder) ZRemRangeByScore(ctx, key, min, max any) *MockCmdableZRemRangeByScoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRemRangeByScore", reflect.TypeOf((*MockCmdable)(nil).ZRemRangeByScore), ctx, key, min, max)
	return &MockCmdableZRemRangeByScoreCall{Call: call}
}

// MockCmdableZRemRangeByScoreCall wrap *gomock.Call
type MockCmdableZRemRangeByScoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRemRangeByScoreCall) Return(arg0 *redis.IntCmd) *MockCmdableZRemRangeByScoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRemRangeByScoreCall) Do(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZRemRangeByScoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRemRangeByScoreCall) DoAndReturn(f func(context.Context, string, string, string) *redis.IntCmd) *MockCmdableZRemRangeByScoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRevRange mocks base method.
func (m *MockCmdable) ZRevRange(ctx context.Context, key string, start, stop int64) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRevRange", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRevRange indicates an expected call of ZRevRange.
func (mr *MockCmdableMockRecorder) ZRevRange(ctx, key, start, stop any) *MockCmdableZRevRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRevRange", reflect.TypeOf((*MockCmdable)(nil).ZRevRange), ctx, key, start, stop)
	return &MockCmdableZRevRangeCall{Call: call}
}

// MockCmdableZRevRangeCall wrap *gomock.Call
type MockCmdableZRevRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRevRangeCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRevRangeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRevRangeCall) Do(f func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockCmdableZRevRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRevRangeCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockCmdableZRevRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRevRangeByLex mocks base method.
func (m *MockCmdable) ZRevRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRevRangeByLex", ctx, key, opt)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRevRangeByLex indicates an expected call of ZRevRangeByLex.
func (mr *MockCmdableMockRecorder) ZRevRangeByLex(ctx, key, opt any) *MockCmdableZRevRangeByLexCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRevRangeByLex", reflect.TypeOf((*MockCmdable)(nil).ZRevRangeByLex), ctx, key, opt)
	return &MockCmdableZRevRangeByLexCall{Call: call}
}

// MockCmdableZRevRangeByLexCall wrap *gomock.Call
type MockCmdableZRevRangeByLexCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRevRangeByLexCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRevRangeByLexCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRevRangeByLexCall) Do(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRevRangeByLexCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRevRangeByLexCall) DoAndReturn(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRevRangeByLexCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRevRangeByScore mocks base method.
func (m *MockCmdable) ZRevRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRevRangeByScore", ctx, key, opt)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZRevRangeByScore indicates an expected call of ZRevRangeByScore.
func (mr *MockCmdableMockRecorder) ZRevRangeByScore(ctx, key, opt any) *MockCmdableZRevRangeByScoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRevRangeByScore", reflect.TypeOf((*MockCmdable)(nil).ZRevRangeByScore), ctx, key, opt)
	return &MockCmdableZRevRangeByScoreCall{Call: call}
}

// MockCmdableZRevRangeByScoreCall wrap *gomock.Call
type MockCmdableZRevRangeByScoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRevRangeByScoreCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZRevRangeByScoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRevRangeByScoreCall) Do(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRevRangeByScoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRevRangeByScoreCall) DoAndReturn(f func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockCmdableZRevRangeByScoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRevRangeByScoreWithScores mocks base method.
func (m *MockCmdable) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRevRangeByScoreWithScores", ctx, key, opt)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZRevRangeByScoreWithScores indicates an expected call of ZRevRangeByScoreWithScores.
func (mr *MockCmdableMockRecorder) ZRevRangeByScoreWithScores(ctx, key, opt any) *MockCmdableZRevRangeByScoreWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRevRangeByScoreWithScores", reflect.TypeOf((*MockCmdable)(nil).ZRevRangeByScoreWithScores), ctx, key, opt)
	return &MockCmdableZRevRangeByScoreWithScoresCall{Call: call}
}

// MockCmdableZRevRangeByScoreWithScoresCall wrap *gomock.Call
type MockCmdableZRevRangeByScoreWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRevRangeByScoreWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZRevRangeByScoreWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRevRangeByScoreWithScoresCall) Do(f func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd) *MockCmdableZRevRangeByScoreWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRevRangeByScoreWithScoresCall) DoAndReturn(f func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd) *MockCmdableZRevRangeByScoreWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRevRangeWithScores mocks base method.
func (m *MockCmdable) ZRevRangeWithScores(ctx context.Context, key string, start, stop int64) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRevRangeWithScores", ctx, key, start, stop)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZRevRangeWithScores indicates an expected call of ZRevRangeWithScores.
func (mr *MockCmdableMockRecorder) ZRevRangeWithScores(ctx, key, start, stop any) *MockCmdableZRevRangeWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRevRangeWithScores", reflect.TypeOf((*MockCmdable)(nil).ZRevRangeWithScores), ctx, key, start, stop)
	return &MockCmdableZRevRangeWithScoresCall{Call: call}
}

// MockCmdableZRevRangeWithScoresCall wrap *gomock.Call
type MockCmdableZRevRangeWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRevRangeWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZRevRangeWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRevRangeWithScoresCall) Do(f func(context.Context, string, int64, int64) *redis.ZSliceCmd) *MockCmdableZRevRangeWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRevRangeWithScoresCall) DoAndReturn(f func(context.Context, string, int64, int64) *redis.ZSliceCmd) *MockCmdableZRevRangeWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRevRank mocks base method.
func (m *MockCmdable) ZRevRank(ctx context.Context, key, member string) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRevRank", ctx, key, member)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZRevRank indicates an expected call of ZRevRank.
func (mr *MockCmdableMockRecorder) ZRevRank(ctx, key, member any) *MockCmdableZRevRankCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRevRank", reflect.TypeOf((*MockCmdable)(nil).ZRevRank), ctx, key, member)
	return &MockCmdableZRevRankCall{Call: call}
}

// MockCmdableZRevRankCall wrap *gomock.Call
type MockCmdableZRevRankCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRevRankCall) Return(arg0 *redis.IntCmd) *MockCmdableZRevRankCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRevRankCall) Do(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableZRevRankCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRevRankCall) DoAndReturn(f func(context.Context, string, string) *redis.IntCmd) *MockCmdableZRevRankCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZRevRankWithScore mocks base method.
func (m *MockCmdable) ZRevRankWithScore(ctx context.Context, key, member string) *redis.RankWithScoreCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZRevRankWithScore", ctx, key, member)
	ret0, _ := ret[0].(*redis.RankWithScoreCmd)
	return ret0
}

// ZRevRankWithScore indicates an expected call of ZRevRankWithScore.
func (mr *MockCmdableMockRecorder) ZRevRankWithScore(ctx, key, member any) *MockCmdableZRevRankWithScoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZRevRankWithScore", reflect.TypeOf((*MockCmdable)(nil).ZRevRankWithScore), ctx, key, member)
	return &MockCmdableZRevRankWithScoreCall{Call: call}
}

// MockCmdableZRevRankWithScoreCall wrap *gomock.Call
type MockCmdableZRevRankWithScoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZRevRankWithScoreCall) Return(arg0 *redis.RankWithScoreCmd) *MockCmdableZRevRankWithScoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZRevRankWithScoreCall) Do(f func(context.Context, string, string) *redis.RankWithScoreCmd) *MockCmdableZRevRankWithScoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZRevRankWithScoreCall) DoAndReturn(f func(context.Context, string, string) *redis.RankWithScoreCmd) *MockCmdableZRevRankWithScoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZScan mocks base method.
func (m *MockCmdable) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZScan", ctx, key, cursor, match, count)
	ret0, _ := ret[0].(*redis.ScanCmd)
	return ret0
}

// ZScan indicates an expected call of ZScan.
func (mr *MockCmdableMockRecorder) ZScan(ctx, key, cursor, match, count any) *MockCmdableZScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZScan", reflect.TypeOf((*MockCmdable)(nil).ZScan), ctx, key, cursor, match, count)
	return &MockCmdableZScanCall{Call: call}
}

// MockCmdableZScanCall wrap *gomock.Call
type MockCmdableZScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZScanCall) Return(arg0 *redis.ScanCmd) *MockCmdableZScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZScanCall) Do(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableZScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZScanCall) DoAndReturn(f func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockCmdableZScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZScore mocks base method.
func (m *MockCmdable) ZScore(ctx context.Context, key, member string) *redis.FloatCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZScore", ctx, key, member)
	ret0, _ := ret[0].(*redis.FloatCmd)
	return ret0
}

// ZScore indicates an expected call of ZScore.
func (mr *MockCmdableMockRecorder) ZScore(ctx, key, member any) *MockCmdableZScoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZScore", reflect.TypeOf((*MockCmdable)(nil).ZScore), ctx, key, member)
	return &MockCmdableZScoreCall{Call: call}
}

// MockCmdableZScoreCall wrap *gomock.Call
type MockCmdableZScoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZScoreCall) Return(arg0 *redis.FloatCmd) *MockCmdableZScoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZScoreCall) Do(f func(context.Context, string, string) *redis.FloatCmd) *MockCmdableZScoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZScoreCall) DoAndReturn(f func(context.Context, string, string) *redis.FloatCmd) *MockCmdableZScoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZUnion mocks base method.
func (m *MockCmdable) ZUnion(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZUnion", ctx, store)
	ret0, _ := ret[0].(*redis.StringSliceCmd)
	return ret0
}

// ZUnion indicates an expected call of ZUnion.
func (mr *MockCmdableMockRecorder) ZUnion(ctx, store any) *MockCmdableZUnionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZUnion", reflect.TypeOf((*MockCmdable)(nil).ZUnion), ctx, store)
	return &MockCmdableZUnionCall{Call: call}
}

// MockCmdableZUnionCall wrap *gomock.Call
type MockCmdableZUnionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZUnionCall) Return(arg0 *redis.StringSliceCmd) *MockCmdableZUnionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZUnionCall) Do(f func(context.Context, redis.ZStore) *redis.StringSliceCmd) *MockCmdableZUnionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZUnionCall) DoAndReturn(f func(context.Context, redis.ZStore) *redis.StringSliceCmd) *MockCmdableZUnionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZUnionStore mocks base method.
func (m *MockCmdable) ZUnionStore(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZUnionStore", ctx, dest, store)
	ret0, _ := ret[0].(*redis.IntCmd)
	return ret0
}

// ZUnionStore indicates an expected call of ZUnionStore.
func (mr *MockCmdableMockRecorder) ZUnionStore(ctx, dest, store any) *MockCmdableZUnionStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZUnionStore", reflect.TypeOf((*MockCmdable)(nil).ZUnionStore), ctx, dest, store)
	return &MockCmdableZUnionStoreCall{Call: call}
}

// MockCmdableZUnionStoreCall wrap *gomock.Call
type MockCmdableZUnionStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZUnionStoreCall) Return(arg0 *redis.IntCmd) *MockCmdableZUnionStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZUnionStoreCall) Do(f func(context.Context, string, *redis.ZStore) *redis.IntCmd) *MockCmdableZUnionStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZUnionStoreCall) DoAndReturn(f func(context.Context, string, *redis.ZStore) *redis.IntCmd) *MockCmdableZUnionStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ZUnionWithScores mocks base method.
func (m *MockCmdable) ZUnionWithScores(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ZUnionWithScores", ctx, store)
	ret0, _ := ret[0].(*redis.ZSliceCmd)
	return ret0
}

// ZUnionWithScores indicates an expected call of ZUnionWithScores.
func (mr *MockCmdableMockRecorder) ZUnionWithScores(ctx, store any) *MockCmdableZUnionWithScoresCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ZUnionWithScores", reflect.TypeOf((*MockCmdable)(nil).ZUnionWithScores), ctx, store)
	return &MockCmdableZUnionWithScoresCall{Call: call}
}

// MockCmdableZUnionWithScoresCall wrap *gomock.Call
type MockCmdableZUnionWithScoresCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCmdableZUnionWithScoresCall) Return(arg0 *redis.ZSliceCmd) *MockCmdableZUnionWithScoresCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCmdableZUnionWithScoresCall) Do(f func(context.Context, redis.ZStore) *redis.ZSliceCmd) *MockCmdableZUnionWithScoresCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCmdableZUnionWithScoresCall) DoAndReturn(f func(context.Context, redis.ZStore) *redis.ZSliceCmd) *MockCmdableZUnionWithScoresCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
