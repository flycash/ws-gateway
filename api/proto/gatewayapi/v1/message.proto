syntax = "proto3";

package gatewayapi.v1;

import "google/protobuf/any.proto";

option go_package = "v1/gatewayapi;gatewayapiv1";

// 通用协议格式
// 上行消息说明:
//    上行请求消息是指前端主动发送给后端的消息,通常使用“业务命名_REQUEST后缀”命名
//    上行响应消息是指后端对收到的上行请求消息的响应消息,通常使用"业务名+_RESPONSE后缀"命名,其中“业务名”应与对应的上行请求消息的“业务名”相同.
// 下行消息说明:
//    下行(推送)请求消息是指后端主动发送给前端的消息,通常使用"PUSH_业务名_REQUEST"命名
//    下行(推送)响应消息是指前端对收到的下行(推送)请求消息的响应消息,通常使用“PUSH_业务名_RESPONSE”命名,其中“业务名”应与对应的下行(推送)请求消息的“业务名”相同.
// 以 A -> B 为例
message Message {
  enum CommandType {
    COMMAND_TYPE_INVALID_UNSPECIFIED = 0;
    COMMAND_TYPE_HEARTBEAT = 1; // 心跳消息,body为空即可,前端主动发送、后端原样返回
    // A -> gateway 的消息
    COMMAND_TYPE_CHANNEL_MESSAGE_REQUEST = 2; // 上行聊天消息请求
    COMMAND_TYPE_CHANNEL_MESSAGE_RESPONSE = 3; // 上行聊天消息响应
    // gateway -> B 的消息
    COMMAND_TYPE_PUSH_CHANNEL_MESSAGE_REQUEST = 4; // 下行聊天推送请求
    COMMAND_TYPE_PUSH_CHANNEL_MESSAGE_RESPONSE = 5; // 下行聊天推送响应
    // 添加其他命令类型
  }
  CommandType cmd = 1; // 消息类型
  // A -> gateway，是 A 生成；
  // biz + key 唯一
  string key = 2; // UUID, 后续当前端支持超时重传,后端需要用此 key 来去重
  google.protobuf.Any body = 3; // 业务相关的具体消息体
  int64 biz_id = 4; // 执行业务分发
}

// simple-im 启动一个 grpc 服务端
// 而后 simple-im
service BackendService {
  rpc OnReceive(OnReceiveRequest) returns (OnReceiveResponse);
}

message OnReceiveRequest {
  string key = 1;
  google.protobuf.Any body = 2;
}

message OnReceiveResponse {
  int64 msg_id = 1; // 业务方生成 的 ID，其实跟 gateway 没什么关系
  int64 biz_id = 2;
}

// Kafka 也复用这个消息定义
message PushMessage {
  int64 biz_id = 1; // biz_id 记录一下哪个业务方过来的，没实际意义
  int64 receiver_id = 2; // 目前来看，只有用户 ID，要根据这个来找到 websocket 来把消息发送出去
  google.protobuf.Any body = 3; // 业务相关的具体消息体
  string key = 4;
}

// 如果不用 Kafka，就应该提供这条路
service PushService {
  rpc Push(PushRequest) returns (PushResponse);
}

message PushRequest {
  PushMessage msg = 1;
}

message PushResponse {

}